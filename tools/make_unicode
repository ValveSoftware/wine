#!/usr/bin/perl -w
#
# Generate code page .c files from ftp.unicode.org descriptions
#
# Copyright 2000 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
#

use strict;

# base URLs for www.unicode.org files
my $MAPPINGS = "http://www.unicode.org/Public/MAPPINGS";
my $UNIDATA = "http://www.unicode.org/Public/11.0.0/ucd";
my $REPORTS = "http://www.unicode.org/reports";
my $RFCS = "http://www.rfc-editor.org/rfc";

# Sort keys file
my $SORTKEYS = "tr10/allkeys.txt";

# RFC3454 (stringprep data)
my $STRINGPREP = "rfc3454.txt";

# Defaults mapping
my $DEFAULTS = "tools/unicode-defaults";

# Default char for undefined mappings
my $DEF_CHAR = ord '?';

my @allfiles =
(
    [ 37,    "VENDORS/MICSFT/EBCDIC/CP037.TXT",   0, "IBM EBCDIC US Canada", 0, 0x6f ],
    [ 424,   "VENDORS/MISC/CP424.TXT",            0, "IBM EBCDIC Hebrew" ],
    [ 437,   "VENDORS/MICSFT/PC/CP437.TXT",       1, "OEM United States" ],
    [ 500,   "VENDORS/MICSFT/EBCDIC/CP500.TXT",   0, "IBM EBCDIC International", 0, 0x6f ],
    [ 737,   "VENDORS/MICSFT/PC/CP737.TXT",       1, "OEM Greek 437G" ],
    [ 775,   "VENDORS/MICSFT/PC/CP775.TXT",       1, "OEM Baltic" ],
    [ 850,   "VENDORS/MICSFT/PC/CP850.TXT",       1, "OEM Multilingual Latin 1" ],
    [ 852,   "VENDORS/MICSFT/PC/CP852.TXT",       1, "OEM Slovak Latin 2" ],
    [ 855,   "VENDORS/MICSFT/PC/CP855.TXT",       1, "OEM Cyrillic" ],
    [ 856,   "VENDORS/MISC/CP856.TXT",            0, "Hebrew PC" ],
    [ 857,   "VENDORS/MICSFT/PC/CP857.TXT",       1, "OEM Turkish", 0xf8bb ],
    [ 860,   "VENDORS/MICSFT/PC/CP860.TXT",       1, "OEM Portuguese" ],
    [ 861,   "VENDORS/MICSFT/PC/CP861.TXT",       1, "OEM Icelandic" ],
    [ 862,   "VENDORS/MICSFT/PC/CP862.TXT",       1, "OEM Hebrew" ],
    [ 863,   "VENDORS/MICSFT/PC/CP863.TXT",       1, "OEM Canadian French" ],
    [ 864,   "VENDORS/MICSFT/PC/CP864.TXT",       0, "OEM Arabic", 0xf8bb ],
    [ 865,   "VENDORS/MICSFT/PC/CP865.TXT",       1, "OEM Nordic" ],
    [ 866,   "VENDORS/MICSFT/PC/CP866.TXT",       1, "OEM Russian" ],
    [ 869,   "VENDORS/MICSFT/PC/CP869.TXT",       1, "OEM Greek" ],
    [ 874,   "VENDORS/MICSFT/WindowsBestFit/bestfit874.txt",  1, "ANSI/OEM Thai" ],
    [ 875,   "VENDORS/MICSFT/EBCDIC/CP875.TXT",               0, "IBM EBCDIC Greek", 0, 0x6f ],
    [ 878,   "VENDORS/MISC/KOI8-R.TXT",                       0, "Russian KOI8" ],
    [ 932,   "VENDORS/MICSFT/WindowsBestFit/bestfit932.txt",  0, "ANSI/OEM Japanese Shift-JIS" ],
    [ 936,   "VENDORS/MICSFT/WindowsBestFit/bestfit936.txt",  0, "ANSI/OEM Simplified Chinese GBK" ],
    [ 949,   "VENDORS/MICSFT/WindowsBestFit/bestfit949.txt",  0, "ANSI/OEM Korean Unified Hangul" ],
    [ 950,   "VENDORS/MICSFT/WindowsBestFit/bestfit950.txt",  0, "ANSI/OEM Traditional Chinese Big5" ],
    [ 1006,  "VENDORS/MISC/CP1006.TXT",                       0, "IBM Arabic" ],
    [ 1026,  "VENDORS/MICSFT/EBCDIC/CP1026.TXT",              0, "IBM EBCDIC Latin 5 Turkish", 0, 0x6f ],
    [ 1250,  "VENDORS/MICSFT/WindowsBestFit/bestfit1250.txt", 0, "ANSI Eastern Europe" ],
    [ 1251,  "VENDORS/MICSFT/WindowsBestFit/bestfit1251.txt", 0, "ANSI Cyrillic" ],
    [ 1252,  "VENDORS/MICSFT/WindowsBestFit/bestfit1252.txt", 0, "ANSI Latin 1" ],
    [ 1253,  "VENDORS/MICSFT/WindowsBestFit/bestfit1253.txt", 0, "ANSI Greek" ],
    [ 1254,  "VENDORS/MICSFT/WindowsBestFit/bestfit1254.txt", 0, "ANSI Turkish" ],
    [ 1255,  "VENDORS/MICSFT/WindowsBestFit/bestfit1255.txt", 0, "ANSI Hebrew" ],
    [ 1256,  "VENDORS/MICSFT/WindowsBestFit/bestfit1256.txt", 0, "ANSI Arabic" ],
    [ 1257,  "VENDORS/MICSFT/WindowsBestFit/bestfit1257.txt", 0, "ANSI Baltic" ],
    [ 1258,  "VENDORS/MICSFT/WindowsBestFit/bestfit1258.txt", 0, "ANSI/OEM Viet Nam" ],
    [ 1361,  "VENDORS/MICSFT/WindowsBestFit/bestfit1361.txt", 0, "Korean Johab" ],
    [ 10000, "VENDORS/MICSFT/MAC/ROMAN.TXT",      0, "Mac Roman" ],
    [ 10001, "VENDORS/APPLE/JAPANESE.TXT",        0, "Mac Japanese" ],
    [ 10002, "VENDORS/APPLE/CHINTRAD.TXT",        0, "Mac Traditional Chinese" ],
    [ 10003, "VENDORS/APPLE/KOREAN.TXT",          0, "Mac Korean", 0xf8e5 ],
    [ 10004, "VENDORS/APPLE/ARABIC.TXT",          0, "Mac Arabic", 0xf826 ],
    [ 10005, "VENDORS/APPLE/HEBREW.TXT",          0, "Mac Hebrew", 0xf7fa ],
    [ 10006, "VENDORS/MICSFT/MAC/GREEK.TXT",      0, "Mac Greek" ],
    [ 10007, "VENDORS/MICSFT/MAC/CYRILLIC.TXT",   0, "Mac Cyrillic" ],
    [ 10008, "VENDORS/APPLE/CHINSIMP.TXT",        0, "Mac Simplified Chinese" ],
    [ 10010, "VENDORS/APPLE/ROMANIAN.TXT",        0, "Mac Romanian" ],
    [ 10017, "VENDORS/APPLE/CYRILLIC.TXT",        0, "Mac Ukrainian" ],
    [ 10021, "VENDORS/APPLE/THAI.TXT",            0, "Mac Thai" ],
    [ 10029, "VENDORS/MICSFT/MAC/LATIN2.TXT",     0, "Mac Latin 2" ],
    [ 10079, "VENDORS/MICSFT/MAC/ICELAND.TXT",    0, "Mac Icelandic" ],
    [ 10081, "VENDORS/MICSFT/MAC/TURKISH.TXT",    0, "Mac Turkish", 0xf89f ],
    [ 10082, "VENDORS/APPLE/CROATIAN.TXT",        0, "Mac Croatian" ],
    [ 20127, undef,                               0, "US-ASCII (7bit)" ],
    [ 20866, "VENDORS/MISC/KOI8-R.TXT",           0, "Russian KOI8" ],
    [ 20932, "OBSOLETE/EASTASIA/JIS/JIS0208.TXT", 0, "EUC-JP", 0, 0x3f, 0x30fb  ],
    [ 21866, "VENDORS/MISC/KOI8-U.TXT",           0, "Ukrainian KOI8" ],
    [ 28591, "ISO8859/8859-1.TXT",                0, "ISO 8859-1 Latin 1" ],
    [ 28592, "ISO8859/8859-2.TXT",                0, "ISO 8859-2 Latin 2 (East European)" ],
    [ 28593, "ISO8859/8859-3.TXT",                0, "ISO 8859-3 Latin 3 (South European)", 0xf7f5 ],
    [ 28594, "ISO8859/8859-4.TXT",                0, "ISO 8859-4 Latin 4 (Baltic old)" ],
    [ 28595, "ISO8859/8859-5.TXT",                0, "ISO 8859-5 Cyrillic" ],
    [ 28596, "ISO8859/8859-6.TXT",                0, "ISO 8859-6 Arabic", 0xf7c8 ],
    [ 28597, "ISO8859/8859-7.TXT",                0, "ISO 8859-7 Greek", 0xf7c5 ],
    [ 28598, "ISO8859/8859-8.TXT",                0, "ISO 8859-8 Hebrew", 0xf79c ],
    [ 28599, "ISO8859/8859-9.TXT",                0, "ISO 8859-9 Latin 5 (Turkish)" ],
    [ 28600, "ISO8859/8859-10.TXT",               0, "ISO 8859-10 Latin 6 (Nordic)" ],
    [ 28603, "ISO8859/8859-13.TXT",               0, "ISO 8859-13 Latin 7 (Baltic)" ],
    [ 28604, "ISO8859/8859-14.TXT",               0, "ISO 8859-14 Latin 8 (Celtic)" ],
    [ 28605, "ISO8859/8859-15.TXT",               0, "ISO 8859-15 Latin 9 (Euro)" ],
    [ 28606, "ISO8859/8859-16.TXT",               0, "ISO 8859-16 Latin 10 (Balkan)" ]
);


my %ctype =
(
    "upper"  => 0x0001,
    "lower"  => 0x0002,
    "digit"  => 0x0004,
    "space"  => 0x0008,
    "punct"  => 0x0010,
    "cntrl"  => 0x0020,
    "blank"  => 0x0040,
    "xdigit" => 0x0080,
    "alpha"  => 0x0100,
    "defin"  => 0x0200
);

my %bracket_types =
(
    "o" => 0x0000,
    "c" => 0x0001,
);

my %indic_types =
(
    "Other"    => 0x0000,
    "Bindu"    => 0x0001,
    "Visarga"  => 0x0002,
    "Avagraha" => 0x0003,
    "Nukta"    => 0x0004,
    "Virama"   => 0x0005,
    "Vowel_Independent"  => 0x0006,
    "Vowel_Dependent"  => 0x0007,
    "Vowel"  => 0x0008,
    "Consonant_Placeholder"  => 0x0009,
    "Consonant"  => 0x000a,
    "Consonant_Dead"  => 0x000b,
    "Consonant_Succeeding_Repha" => 0x000c,
    "Consonant_Subjoined"  => 0x000d,
    "Consonant_Medial"  => 0x000e,
    "Consonant_Final"  => 0x000f,
    "Consonant_Head_Letter"  => 0x0010,
    "Modifying_Letter"  => 0x0011,
    "Tone_Letter"  => 0x0012,
    "Tone_Mark"  => 0x0013,
    "Register_Shifter"  => 0x0014,
    "Consonant_Preceding_Repha" => 0x0015,
    "Pure_Killer" => 0x0016,
    "Invisible_Stacker" => 0x0017,
    "Gemination_Mark" => 0x0018,
    "Cantillation_Mark" => 0x0019,
    "Non_Joiner" => 0x001a,
    "Joiner" => 0x001b,
    "Number_Joiner" => 0x001c,
    "Number" => 0x001d,
    "Brahmi_Joining_Number" => 0x001e,
    "Consonant_With_Stacker" => 0x001f,
    "Consonant_Prefixed" => 0x0020,
    "Syllable_Modifier" => 0x0021,
    "Consonant_Killer" => 0x0022,
    "Consonant_Initial_Postfixed" => 0x0023,
);

my %matra_types =
(
    "Right"    => 0x01,
    "Left"  => 0x02,
    "Visual_Order_Left" => 0x03,
    "Left_And_Right"    => 0x04,
    "Top"   => 0x05,
    "Bottom"  => 0x06,
    "Top_And_Bottom"  => 0x07,
    "Top_And_Right"  => 0x08,
    "Top_And_Left"  => 0x09,
    "Top_And_Left_And_Right"  => 0x0a,
    "Bottom_And_Right"  => 0x0b,
    "Top_And_Bottom_And_Right"  => 0x0c,
    "Overstruck"  => 0x0d,
    "Invisible"  => 0x0e,
    "Bottom_And_Left"  => 0x0f
);

my %nameprep_flags =
(
    "unassigned" => 0x01,
    "prohibited" => 0x02,
    "bidi_ral"   => 0x04,
    "bidi_l"     => 0x08
);

my %break_types =
(
    "BK"  => 0x0001,
    "CR"  => 0x0002,
    "LF"  => 0x0003,
    "CM"  => 0x0004,
    "SG"  => 0x0005,
    "GL"  => 0x0006,
    "CB"  => 0x0007,
    "SP"  => 0x0008,
    "ZW"  => 0x0009,
    "NL"  => 0x000a,
    "WJ"  => 0x000b,
    "JL"  => 0x000c,
    "JV"  => 0x000d,
    "JT"  => 0x000e,
    "H2"  => 0x000f,
    "H3"  => 0x0010,
    "XX"  => 0x0011,
    "OP"  => 0x0012,
    "CL"  => 0x0013,
    "CP"  => 0x0014,
    "QU"  => 0x0015,
    "NS"  => 0x0016,
    "EX"  => 0x0017,
    "SY"  => 0x0018,
    "IS"  => 0x0019,
    "PR"  => 0x001a,
    "PO"  => 0x001b,
    "NU"  => 0x001c,
    "AL"  => 0x001d,
    "ID"  => 0x001e,
    "IN"  => 0x001f,
    "HY"  => 0x0020,
    "BB"  => 0x0021,
    "BA"  => 0x0022,
    "SA"  => 0x0023,
    "AI"  => 0x0024,
    "B2"  => 0x0025,
    "HL"  => 0x0026,
    "CJ"  => 0x0027,
    "RI"  => 0x0028,
    "EB"  => 0x0029,
    "EM"  => 0x002a,
    "ZWJ" => 0x002b,
);

my %vertical_types =
(
    "R"  => 0x0000,
    "U"  => 0x0001,
    "Tr" => 0x0002,
    "Tu" => 0x0003,
);

my %categories =
(
    "Lu" => $ctype{"defin"}|$ctype{"alpha"}|$ctype{"upper"}, # Letter, Uppercase
    "Ll" => $ctype{"defin"}|$ctype{"alpha"}|$ctype{"lower"}, # Letter, Lowercase
    "Lt" => $ctype{"defin"}|$ctype{"alpha"}|$ctype{"upper"}|$ctype{"lower"},    # Letter, Titlecase
    "Mn" => $ctype{"defin"},                    # Mark, Non-Spacing
    "Mc" => $ctype{"defin"},                    # Mark, Spacing Combining
    "Me" => $ctype{"defin"},                    # Mark, Enclosing
    "Nd" => $ctype{"defin"}|$ctype{"digit"},    # Number, Decimal Digit
    "Nl" => $ctype{"defin"}|$ctype{"alpha"},    # Number, Letter
    "No" => $ctype{"defin"},                    # Number, Other
    "Zs" => $ctype{"defin"}|$ctype{"space"},    # Separator, Space
    "Zl" => $ctype{"defin"}|$ctype{"space"},    # Separator, Line
    "Zp" => $ctype{"defin"}|$ctype{"space"},    # Separator, Paragraph
    "Cc" => $ctype{"defin"}|$ctype{"cntrl"},    # Other, Control
    "Cf" => $ctype{"defin"}|$ctype{"cntrl"},    # Other, Format
    "Cs" => $ctype{"defin"},                    # Other, Surrogate
    "Co" => $ctype{"defin"},                    # Other, Private Use
    "Cn" => $ctype{"defin"},                    # Other, Not Assigned
    "Lm" => $ctype{"defin"}|$ctype{"alpha"},    # Letter, Modifier
    "Lo" => $ctype{"defin"}|$ctype{"alpha"},    # Letter, Other
    "Pc" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Connector
    "Pd" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Dash
    "Ps" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Open
    "Pe" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Close
    "Pi" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Initial quote
    "Pf" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Final quote
    "Po" => $ctype{"defin"}|$ctype{"punct"},    # Punctuation, Other
    "Sm" => $ctype{"defin"},                    # Symbol, Math
    "Sc" => $ctype{"defin"},                    # Symbol, Currency
    "Sk" => $ctype{"defin"},                    # Symbol, Modifier
    "So" => $ctype{"defin"}                     # Symbol, Other
);

# a few characters need additional categories that cannot be determined automatically
my %special_categories =
(
    "xdigit" => [ ord('0')..ord('9'),ord('A')..ord('F'),ord('a')..ord('f'),
                  0xff10..0xff19, 0xff21..0xff26, 0xff41..0xff46 ],
    "space"  => [ 0x09..0x0d, 0x85 ],
    "blank"  => [ 0x09, 0x20, 0xa0, 0x3000, 0xfeff ],
    "cntrl"  => [ 0x070f, 0x200c, 0x200d,
                  0x200e, 0x200f, 0x202a, 0x202b, 0x202c, 0x202d, 0x202e,
                  0x206a, 0x206b, 0x206c, 0x206d, 0x206e, 0x206f, 0xfeff,
                  0xfff9, 0xfffa, 0xfffb ],
    "punct"  => [ 0x24, 0x2b, 0x3c..0x3e, 0x5e, 0x60, 0x7c, 0x7e, 0xa2..0xbe,
                  0xd7, 0xf7 ],
    "digit"  => [ 0xb2, 0xb3, 0xb9 ],
    "lower"  => [ 0x2071, 0x207f ]
);

my %directions =
(
    "L"   => 1,    # Left-to-Right
    "R"   => 2,    # Right-to-Left
    "AL"  => 12,   # Right-to-Left Arabic
    "EN"  => 3,    # European Number
    "ES"  => 4,    # European Number Separator
    "ET"  => 5,    # European Number Terminator
    "AN"  => 6,    # Arabic Number
    "CS"  => 7,    # Common Number Separator
    "NSM" => 13,   # Non-Spacing Mark
    "BN"  => 14,   # Boundary Neutral
    "B"   => 8,    # Paragraph Separator
    "S"   => 9,    # Segment Separator
    "WS"  => 10,   # Whitespace
    "ON"  => 11,   # Other Neutrals
    "LRE" => 15,   # Left-to-Right Embedding
    "LRO" => 15,   # Left-to-Right Override
    "RLE" => 15,   # Right-to-Left Embedding
    "RLO" => 15,   # Right-to-Left Override
    "PDF" => 15,   # Pop Directional Format
    "LRI" => 15,   # Left-to-Right Isolate
    "RLI" => 15,   # Right-to-Left Isolate
    "FSI" => 15,   # First Strong Isolate
    "PDI" => 15    # Pop Directional Isolate
);

my %joining_types =
(
   "U" => 0,    # Non_Joining
   "T" => 1,    # Transparent
   "R" => 2,    # Right_Joining
   "L" => 3,    # Left_Joining
   "D" => 4,    # Dual_Joining
   "C" => 5,    # Join_Causing
);

my @cp2uni = ();
my @lead_bytes = ();
my @uni2cp = ();
my @unicode_defaults = ();
my @unicode_aliases = ();
my @tolower_table = ();
my @toupper_table = ();
my @digitmap_table = ();
my @compatmap_table = ();
my @category_table = ();
my @joining_table = ();
my @direction_table = ();
my @decomp_table = ();
my @compose_table = ();
my @comb_class_table = ();
my @full_comp_table = ();
my $default_char;
my $default_wchar;

my %joining_forms =
(
   "isolated" => [],
   "final" => [],
   "initial" => [],
   "medial" => []
);

################################################################
# fetch a unicode.org file and open it
sub open_data_file($$)
{
    my ($base, $name) = @_;
    (my $dir = "data/$name") =~ s/\/[^\/]+$//;
    local *FILE;
    unless (-f "data/$name")
    {
        print "Fetching $base/$name...\n";
        system "mkdir", "-p", $dir;
        !system "wget", "-q", "-O", "data/$name", "$base/$name" or die "cannot fetch $base/$name";
    }
    open FILE, "<data/$name" or die "cannot open data/$name";
    return *FILE;
}

################################################################
# read in the defaults file
sub READ_DEFAULTS($)
{
    my $filename = shift;
    my $start;

    # first setup a few default mappings

    open DEFAULTS, "$filename" or die "Cannot open $filename";
    print "Loading $filename\n";
    while (<DEFAULTS>)
    {
        next if /^\#/;  # skip comments
        next if /^$/;  # skip empty lines
        if (/^(([0-9a-fA-F]+)(,[0-9a-fA-F]+)*)\s+([0-9a-fA-F]+|'.'|none)\s+(\#.*)?/)
        {
            my @src = map hex, split /,/,$1;
            my $dst = $4;
            my $comment = $5;
            if ($#src > 0) { push @unicode_aliases, \@src; }
            next if ($dst eq "none");
            $dst = ($dst =~ /\'.\'/) ? ord substr($dst,1,1) : hex $dst;
            foreach my $src (@src)
            {
                die "Duplicate value" if defined($unicode_defaults[$src]);
                $unicode_defaults[$src] = $dst;
            }
            next;
        }
        die "Unrecognized line $_\n";
    }
    close DEFAULTS;

    # now build mappings from the decomposition field of the Unicode database

    my $UNICODE_DATA = open_data_file( $UNIDATA, "UnicodeData.txt" );
    while (<$UNICODE_DATA>)
    {
	# Decode the fields ...
	my ($code, $name, $cat, $comb, $bidi,
            $decomp, $dec, $dig, $num, $mirror,
            $oldname, $comment, $upper, $lower, $title) = split /;/;
        my $dst;
        my $src = hex $code;

        die "unknown category $cat" unless defined $categories{$cat};
        die "unknown directionality $bidi" unless defined $directions{$bidi};

        $category_table[$src] = $categories{$cat};
        $direction_table[$src] = $directions{$bidi};
        $joining_table[$src] = $joining_types{"T"} if $cat eq "Mn" || $cat eq "Me" || $cat eq "Cf";

        if ($lower ne "")
        {
            $tolower_table[$src] = hex $lower;
        }
        if ($upper ne "")
        {
            $toupper_table[$src] = hex $upper;
        }
        if ($dec ne "")
        {
            $category_table[$src] |= $ctype{"digit"};
        }
        if ($dig ne "")
        {
            $digitmap_table[$src] = ord $dig;
        }

        # copy the category and direction for everything between First/Last pairs
        if ($name =~ /, First>/) { $start = $src; }
        if ($name =~ /, Last>/)
        {
            while ($start < $src)
            {
                $category_table[$start] = $category_table[$src];
                $direction_table[$start] = $direction_table[$src];
                $start++;
            }
        }

        if ($comb != 0)
        {
            $comb_class_table[$src] = (hex $comb);
        }

        next if $decomp eq "";  # no decomposition, skip it

        # store decomposition table
        if ($decomp =~ /^<([a-zA-Z]+)>(\s+[0-9a-fA-F]+)+$/)
        {
            my @seq = ();
            for my $ch (split /\s+/, (split /\s+/, $decomp, 2)[1])
            {
                push @seq, (hex $ch);
            }
            $decomp_table[$src] = [1, \@seq];
        }
        elsif ($decomp =~ /^([0-9a-fA-F]+)(\s+([0-9a-fA-F]+))*$/)
        {
            my @seq = ();
            for my $ch (split /\s+/, $decomp)
            {
                # we don't support surrogates at the moment
                next if hex $ch > 0xffff;
                push @seq, (hex $ch);
            }
            $decomp_table[$src] = [0, \@seq];
        }

        if ($decomp =~ /^<([a-zA-Z]+)>\s+([0-9a-fA-F]+)$/)
        {
            # decomposition of the form "<foo> 1234" -> use char if type is known
            if (($src >= 0xf900 && $src < 0xfb00) || ($src >= 0xfe30 && $src < 0xfffd))
            {
                # Single char decomposition in the compatibility range
                $compatmap_table[$src] = hex $2;
            }
            if ($1 eq "isolated" || $1 eq "final" || $1 eq "initial" || $1 eq "medial")
            {
                ${joining_forms{$1}}[hex $2] = $src;
                next;
            }
            next unless ($1 eq "font" ||
                         $1 eq "noBreak" ||
                         $1 eq "circle" ||
                         $1 eq "super" ||
                         $1 eq "sub" ||
                         $1 eq "wide" ||
                         $1 eq "narrow" ||
                         $1 eq "compat" ||
                         $1 eq "small");
            $dst = hex $2;
        }
        elsif ($decomp =~ /^<compat>\s+0020\s+([0-9a-fA-F]+)/)
        {
            # decomposition "<compat> 0020 1234" -> combining accent
            $dst = hex $1;
        }
        elsif ($decomp =~ /^([0-9a-fA-F]+)/)
        {
            # decomposition contains only char values without prefix -> use first char
            $dst = hex $1;
            $category_table[$src] |= $category_table[$dst] if defined $category_table[$dst];
            if ($decomp =~ /^([0-9a-fA-F]+)\s+([0-9a-fA-F]+)$/)
            {
                push @compose_table, [ hex $1, hex $2, $src ];
            }
            elsif ($decomp =~ /^(<[a-z]+>\s)*([0-9a-fA-F]+)$/ &&
                   (($src >= 0xf900 && $src < 0xfb00) || ($src >= 0xfe30 && $src < 0xfffd)))
            {
                $compatmap_table[$src] = hex $2;
            }
        }
        else
        {
            next;
        }

        next if defined($unicode_defaults[$src]);  # may have been set in the defaults file

        # check for loops
        for (my $i = $dst; ; $i = $unicode_defaults[$i])
        {
            die sprintf("loop detected for %04x -> %04x",$src,$dst) if $i == $src;
            last unless defined($unicode_defaults[$i]);
        }
        $unicode_defaults[$src] = $dst;
    }
    close $UNICODE_DATA;

    # patch the category of some special characters

    foreach my $cat (keys %special_categories)
    {
        my $flag = $ctype{$cat};
        foreach my $i (@{$special_categories{$cat}}) { $category_table[$i] |= $flag; }
    }

    my $UNICODE_DERIVED = open_data_file( $UNIDATA, "DerivedNormalizationProps.txt" );
    while (<$UNICODE_DERIVED>)
    {
        next unless (/^([0-9a-fA-F.]+)\s+;\s+Full_Composition_Exclusion/);
        my ($first, $last) = split /\.\./,$1;
        $first = hex $first;
        if (defined $last)
        {
            $last = hex $last;
            while ($last gt $first)
            {
                $full_comp_table[$last] = 1;
                $last--;
            }
        }
        $full_comp_table[$first] = 1;
    }
    close $UNICODE_DERIVED;
}


################################################################
# define a new lead byte
sub add_lead_byte($)
{
    my $ch = shift;
    push @lead_bytes, $ch;
    $cp2uni[$ch] = 0;
}

################################################################
# define a new char mapping
sub add_mapping($$)
{
    my ($cp, $uni) = @_;
    $cp2uni[$cp] = $uni unless defined($cp2uni[$cp]);
    $uni2cp[$uni] = $cp unless defined($uni2cp[$uni]);
    if ($cp > 0xff && !defined($cp2uni[$cp >> 8]))
    {
        add_lead_byte( $cp >> 8 );
    }
}

################################################################
# parse a standard codepage file
sub read_codepage_file($)
{
    my $name = shift;
    my $INPUT = open_data_file( $MAPPINGS, $name );

    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        next if (/^0x([0-9a-fA-F]+)\s+\#UNDEFINED/);  # undefined char

        if (/^0x([0-9a-fA-F]+)\s+\#DBCS LEAD BYTE/)
        {
            add_lead_byte( hex $1 );
            next;
        }
        # 0x12 0x3456
        if (/^0x([0-9a-fA-F]+)\s+0x([0-9a-fA-F]+)\s+(\#.*)?/)
        {
            add_mapping( hex $1, hex $2 );
            next;
        }
        # 0x12 0x3456+0x7890
        if (/^0x([0-9a-fA-F]+)\s+0x([0-9a-fA-F]+)\+.*\s+(\#.*)?/)
        {
            add_mapping( hex $1, hex $2 );
            next;
        }
        # 0x12 <LR>+0x3456
        if (/^0x([0-9a-fA-F]+)\s+<LR>\+0x([0-9a-fA-F]+)\s+(\#.*)?/)
        {
            add_mapping( hex $1, hex $2 );
            next;
        }
        # 0x12 <RL>+0x3456
        if (/^0x([0-9a-fA-F]+)\s+<RL>\+0x([0-9a-fA-F]+)\s+(\#.*)?/)
        {
            my $uni = hex $2;
            add_mapping( hex $1, $uni ) if $uni >= 0x80;
            next;
        }
        die "$name: Unrecognized line $_\n";
    }
    close $INPUT;
}


################################################################
# fill input data for the 20127 (us-ascii) codepage
sub fill_20127_codepage()
{
    for (my $i = 0; $i < 128; $i++) { $cp2uni[$i] = $uni2cp[$i] = $i; }
    for (my $i = 128; $i < 256; $i++) { $cp2uni[$i] = $i & 0x7f; }
}

################################################################
# get a mapping including glyph chars for MB_USEGLYPHCHARS

sub get_glyphs_mapping(@)
{
    $_[0x01] = 0x263a;  # (WHITE SMILING FACE)
    $_[0x02] = 0x263b;  # (BLACK SMILING FACE)
    $_[0x03] = 0x2665;  # (BLACK HEART SUIT)
    $_[0x04] = 0x2666;  # (BLACK DIAMOND SUIT)
    $_[0x05] = 0x2663;  # (BLACK CLUB SUIT)
    $_[0x06] = 0x2660;  # (BLACK SPADE SUIT)
    $_[0x07] = 0x2022;  # (BULLET)
    $_[0x08] = 0x25d8;  # (INVERSE BULLET)
    $_[0x09] = 0x25cb;  # (WHITE CIRCLE)
    $_[0x0a] = 0x25d9;  # (INVERSE WHITE CIRCLE)
    $_[0x0b] = 0x2642;  # (MALE SIGN)
    $_[0x0c] = 0x2640;  # (FEMALE SIGN)
    $_[0x0d] = 0x266a;  # (EIGHTH NOTE)
    $_[0x0e] = 0x266b;  # (BEAMED EIGHTH NOTES)
    $_[0x0f] = 0x263c;  # (WHITE SUN WITH RAYS)
    $_[0x10] = 0x25ba;  # (BLACK RIGHT-POINTING POINTER)
    $_[0x11] = 0x25c4;  # (BLACK LEFT-POINTING POINTER)
    $_[0x12] = 0x2195;  # (UP DOWN ARROW)
    $_[0x13] = 0x203c;  # (DOUBLE EXCLAMATION MARK)
    $_[0x14] = 0x00b6;  # (PILCROW SIGN)
    $_[0x15] = 0x00a7;  # (SECTION SIGN)
    $_[0x16] = 0x25ac;  # (BLACK RECTANGLE)
    $_[0x17] = 0x21a8;  # (UP DOWN ARROW WITH BASE)
    $_[0x18] = 0x2191;  # (UPWARDS ARROW)
    $_[0x19] = 0x2193;  # (DOWNWARDS ARROW)
    $_[0x1a] = 0x2192;  # (RIGHTWARDS ARROW)
    $_[0x1b] = 0x2190;  # (LEFTWARDS ARROW)
    $_[0x1c] = 0x221f;  # (RIGHT ANGLE)
    $_[0x1d] = 0x2194;  # (LEFT RIGHT ARROW)
    $_[0x1e] = 0x25b2;  # (BLACK UP-POINTING TRIANGLE)
    $_[0x1f] = 0x25bc;  # (BLACK DOWN-POINTING TRIANGLE)
    $_[0x7f] = 0x2302;  # (HOUSE)
    return @_;
}

################################################################
# build EUC-JP table from the JIS 0208 file
# FIXME: for proper EUC-JP we should probably read JIS 0212 too
# but this would require 3-byte DBCS characters
sub READ_JIS0208_FILE($)
{
    my $name = shift;

    # ASCII chars
    for (my $i = 0x00; $i <= 0x7f; $i++)
    {
        $cp2uni[$i] = $i;
        $uni2cp[$i] = $i;
    }

    # JIS X 0201 right plane
    for (my $i = 0xa1; $i <= 0xdf; $i++)
    {
        $cp2uni[0x8e00 + $i] = 0xfec0 + $i;
        $uni2cp[0xfec0 + $i] = 0x8e00 + $i;
    }

    # lead bytes
    foreach my $i (0x8e, 0x8f, 0xa1 .. 0xfe)
    {
        add_lead_byte($i);
    }

    # undefined chars
    foreach my $i (0x80 .. 0x8d, 0x90 .. 0xa0, 0xff)
    {
        $cp2uni[$i] = $DEF_CHAR;
    }

    # Shift-JIS compatibility
    $uni2cp[0x00a5] = 0x5c;
    $uni2cp[0x203e] = 0x7e;

    # Fix backslash conversion
    $cp2uni[0xa1c0] = 0xff3c;
    $uni2cp[0xff3c] = 0xa1c0;

    my $INPUT = open_data_file( $MAPPINGS, $name );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^0x[0-9a-fA-F]+\s+0x([0-9a-fA-F]+)\s+0x([0-9a-fA-F]+)\s+(\#.*)?/)
        {
            my $cp = 0x8080 + hex $1;
            my $uni = hex $2;
            $cp2uni[$cp] = $uni unless defined($cp2uni[$cp]);
            $uni2cp[$uni] = $cp unless defined($uni2cp[$uni]);
            next;
        }
        die "$name: Unrecognized line $_\n";
    }
    close $INPUT;
}


################################################################
# build the sort keys table
sub READ_SORTKEYS_FILE()
{
    my @sortkeys = ();
    for (my $i = 0; $i < 65536; $i++) { $sortkeys[$i] = [ -1, 0, 0, 0, 0 ] };

    my $INPUT = open_data_file( $REPORTS, $SORTKEYS );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        next if /^\@version/;  # skip @version header
        if (/^([0-9a-fA-F]+)\s+;\s+\[([*.])([0-9a-fA-F]{4})\.([0-9a-fA-F]{4})\.([0-9a-fA-F]{4})\.([0-9a-fA-F]+)\]/)
        {
            my ($uni,$variable) = (hex $1, $2);
            next if $uni > 65535;
            $sortkeys[$uni] = [ $uni, hex $3, hex $4, hex $5, hex $6 ];
            next;
        }
        if (/^([0-9a-fA-F]+\s+)+;\s+\[[*.]([0-9a-fA-F]{4})\.([0-9a-fA-F]{4})\.([0-9a-fA-F]{4})\.([0-9a-fA-F]+)\]/)
        {
            # multiple character sequence, ignored for now
            next;
        }
        die "$SORTKEYS: Unrecognized line $_\n";
    }
    close $INPUT;

    # compress the keys to 32 bit:
    # key 1 to 16 bits, key 2 to 8 bits, key 3 to 4 bits, key 4 to 1 bit

    @sortkeys = sort { ${$a}[1] <=> ${$b}[1] or 
                       ${$a}[2] <=> ${$b}[2] or
                       ${$a}[3] <=> ${$b}[3] or
                       ${$a}[4] <=> ${$b}[4] or
                       $a cmp $b; } @sortkeys;

    my ($n2, $n3) = (1, 1);
    my @keys = (-1, -1, -1, -1, -1 );
    my @flatkeys = ();

    for (my $i = 0; $i < 65536; $i++)
    {
        my @current = @{$sortkeys[$i]};
        next if $current[0] == -1;
        if ($current[1] == $keys[1])
        {
            if ($current[2] == $keys[2])
            {
                if ($current[3] == $keys[3])
                {
                    # nothing
                }
                else
                {
                    $keys[3] = $current[3];
                    $n3++;
                    die if ($n3 >= 16);
                }
            }
            else
            {
                $keys[2] = $current[2];
                $keys[3] = $current[3];
                $n2++;
                $n3 = 1;
                die if ($n2 >= 256);
            }
        }
        else
        {
            $keys[1] = $current[1];
            $keys[2] = $current[2];
            $keys[3] = $current[3];
            $n2 = 1;
            $n3 = 1;
        }

        if ($current[2]) { $current[2] = $n2; }
        if ($current[3]) { $current[3] = $n3; }
        if ($current[4]) { $current[4] = 1; }

        $flatkeys[$current[0]] = ($current[1] << 16) | ($current[2] << 8) | ($current[3] << 4) | $current[4];
    }
    return @flatkeys;
}


################################################################
# build the sort keys table
sub DUMP_SORTKEYS($@)
{
    my ($filename, @keys) = @_;

    # count the number of 256-key ranges that contain something

    my @offsets = ();
    my $ranges = 2;
    for (my $i = 0; $i < 256; $i++) { $offsets[$i] = 256; }
    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $keys[$i];
        $offsets[$i >> 8] = $ranges * 256;
        $ranges++;
        $i |= 255;
    }

    # output the range offsets

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    printf "Building $filename\n";
    printf OUTPUT "/* Unicode collation element table */\n";
    printf OUTPUT "/* generated from %s */\n", "$REPORTS/$SORTKEYS";
    printf OUTPUT "/* DO NOT EDIT!! */\n\n";

    printf OUTPUT "const unsigned int collation_table[%d] =\n{\n", $ranges*256;
    printf OUTPUT "    /* index */\n";
    printf OUTPUT "%s,\n", DUMP_ARRAY( "0x%08x", 0, @offsets );

    # output the default values

    printf OUTPUT "    /* defaults */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%08x", 0, (0xffffffff) x 256 );

    # output all the key ranges

    for (my $i = 0; $i < 256; $i++)
    {
        next if $offsets[$i] == 256;
        printf OUTPUT ",\n    /* 0x%02x00 .. 0x%02xff */\n", $i, $i;
        printf OUTPUT "%s", DUMP_ARRAY( "0x%08x", 0xffffffff, @keys[($i<<8) .. ($i<<8)+255] );
    }
    printf OUTPUT "\n};\n";
    close OUTPUT;
    save_file($filename);
}


################################################################
# add default mappings once the file had been read
sub add_default_mappings($)
{
    my $first_private = shift;

    # Apply aliases

    foreach my $alias (@unicode_aliases)
    {
        my $target = undef;
        foreach my $src (@$alias)
        {
            if (defined($uni2cp[$src]))
            {
                $target = $uni2cp[$src];
                last;
            }
        }
        next unless defined($target);

        # At least one char of the alias set is defined, set the others to the same value
        foreach my $src (@$alias)
        {
            $uni2cp[$src] = $target unless defined($uni2cp[$src]);
        }
    }

    # For every src -> target mapping in the defaults table,
    # make uni2cp[src] = uni2cp[target] if uni2cp[target] is defined

    for (my $src = 0; $src < 65536; $src++)
    {
        next if defined($uni2cp[$src]);  # source has a definition already
        next unless defined($unicode_defaults[$src]);  # no default for this char
        my $target = $unicode_defaults[$src];

        # do a recursive mapping until we find a target char that is defined
        while (!defined($uni2cp[$target]) &&
               defined($unicode_defaults[$target])) { $target = $unicode_defaults[$target]; }

        if (defined($uni2cp[$target])) { $uni2cp[$src] = $uni2cp[$target]; }
    }

    # Add a private char mapping for undefined chars

    if ($first_private)
    {
        for (my $i = 32; $i < 256; $i++)
        {
            next if defined($cp2uni[$i]);
            $cp2uni[$i] = $first_private;
            $uni2cp[$first_private] = $i;
            $first_private++;
        }
    }

    # Add an identity mapping for all undefined chars

    for (my $i = 0; $i < 256; $i++)
    {
        next if defined($cp2uni[$i]);
        next if defined($uni2cp[$i]);
        $cp2uni[$i] = $uni2cp[$i] = $i;
    }
}

################################################################
# dump an array of integers
sub DUMP_ARRAY($$@)
{
    my ($format,$default,@array) = @_;
    my $i;
    my $ret = "    ";
    for ($i = 0; $i < $#array; $i++)
    {
        $ret .= sprintf($format, defined $array[$i] ? $array[$i] : $default);
        $ret .= (($i % 8) != 7) ? ", " : ",\n    ";
    }
    $ret .= sprintf($format, defined $array[$i] ? $array[$i] : $default);
    return $ret;
}


################################################################
# dump a unicode->ascii mapping table
sub dump_uni2cp_table($$)
{
    my ($width, $def) = @_;

    # count the number of unicode->ascii subtables that contain something

    my @lowerbounds;
    my @upperbounds;
    my $index = 0;
    my @filled = (-1) x 256;
    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $uni2cp[$i];
        if ($filled[$i >> 8] == -1)
        {
          $lowerbounds[$index] = $i & 0xff;
          $upperbounds[$index] = 0xff - $lowerbounds[$index];
          $filled[$i >> 8] = $index * 256;
          $index++;
        }
        else
        {
          $upperbounds[$index-1] = 0xff - ($i & 0xff);
        }
    }

    # add defaults mapping at the end
    $filled[256] = $index * 256;
    $lowerbounds[$index] = 255;
    $upperbounds[$index] = 0;
    $index++;

    # collapse blocks upwards if possible
    my $removed = 0;
    $index = 0;
    for (my $i = 0; $i < 257; $i++)
    {
        next if $filled[$i] == -1;
        if ($upperbounds[$index - 1] > $lowerbounds[$index])
        {
           $removed += $lowerbounds[$index];
        }
        else
        {
           $removed += $upperbounds[$index - 1];
           $lowerbounds[$index] = $upperbounds[$index - 1];
        }
        $filled[$i] -= $removed;
        $index++;
    }

    # output all the subtables into a single array

    printf OUTPUT "static const unsigned %s uni2cp_low[%d] =\n{\n",
                  $width == 8 ? "char" : "short", ($index + 1) * 256 - $removed;

    my $format = $width == 8 ? "0x%02x" : "0x%04x";
    for (my $i = $index = 0; $i < 257; $i++)
    {
        next if $filled[$i] == -1;
        my $start = ($i << 8) + $lowerbounds[$index];
        my $end = ($i << 8) + 255;
        if ($i == 256)
        {
            print OUTPUT "    /* defaults */\n";
            printf OUTPUT "%s\n};\n\n", DUMP_ARRAY( $format, 0, ($def) x ($end - $start + 1) );
        }
        else
        {
            printf OUTPUT "    /* 0x%04x .. 0x%04x */\n", $start, $end;
            printf OUTPUT "%s,\n", DUMP_ARRAY( $format, $def, @uni2cp[$start .. $end] );
        }
        $index++;
    }

    # output a table of the offsets of the subtables in the previous array

    for (my $i = 0; $i < 256; $i++)
    {
        if ($filled[$i] == -1) { $filled[$i] = $filled[256]; }
    }
    printf OUTPUT "static const unsigned short uni2cp_high[256] =\n";
    printf OUTPUT "{\n%s\n};\n\n", DUMP_ARRAY( "0x%04x", 0, @filled[0..255] );
}

################################################################
# dump an SBCS mapping table
sub dump_sbcs_table($$$$$)
{
    my ($codepage, $has_glyphs, $name, $def, $defw) = @_;
    my $i;

    # output the ascii->unicode table

    if ($has_glyphs)
    {
        printf OUTPUT "static const WCHAR cp2uni[512] =\n";
        printf OUTPUT "{\n%s", DUMP_ARRAY( "0x%04x", $defw, @cp2uni[0 .. 255] );
        printf OUTPUT ",\n    /* glyphs */\n%s\n};\n\n",
                      DUMP_ARRAY( "0x%04x", $defw, get_glyphs_mapping(@cp2uni[0 .. 255]) );
    }
    else
    {
        printf OUTPUT "static const WCHAR cp2uni[256] =\n";
        printf OUTPUT "{\n%s\n};\n\n", DUMP_ARRAY( "0x%04x", $defw, @cp2uni[0 .. 255] );
    }

    dump_uni2cp_table( 8, $def );

    # output the code page descriptor

    printf OUTPUT "const struct sbcs_table DECLSPEC_HIDDEN cptable_%03d =\n{\n", $codepage;
    printf OUTPUT "    { %d, 1, 0x%04x, 0x%04x, \"%s\" },\n",
                  $codepage, $def, $defw, $name;
    printf OUTPUT "    cp2uni,\n";
    if ($has_glyphs) { printf OUTPUT "    cp2uni + 256,\n"; }
    else { printf OUTPUT "    cp2uni,\n"; }
    printf OUTPUT "    uni2cp_low,\n";
    printf OUTPUT "    uni2cp_high\n};\n";
}


################################################################
# dump a DBCS mapping table
sub dump_dbcs_table($$$$@)
{
    my ($codepage, $name, $def, $defw, @lb_ranges) = @_;

    # build a list of lead bytes that are actually used

    my @lblist = ();
    LBLOOP: for (my $y = 0; $y <= $#lead_bytes; $y++)
    {
        $cp2uni[$lead_bytes[$y]] = $defw;
        my $base = $lead_bytes[$y] << 8;
        for (my $x = 0; $x < 256; $x++)
        {
            if (defined $cp2uni[$base+$x])
            {
                push @lblist,$lead_bytes[$y];
                next LBLOOP;
            }
        }
    }
    my $unused = ($#lead_bytes > $#lblist);

    # output the ascii->unicode table for the single byte chars

    printf OUTPUT "static const WCHAR cp2uni[%d] =\n", 256 * ($#lblist + 2 + $unused);
    printf OUTPUT "{\n%s,\n", DUMP_ARRAY( "0x%04x", $defw, @cp2uni[0 .. 255] );

    # output the default table for unused lead bytes

    if ($unused)
    {
        printf OUTPUT "    /* unused lead bytes */\n";
        printf OUTPUT "%s,\n", DUMP_ARRAY( "0x%04x", 0, ($defw) x 256 );
    }

    # output the ascii->unicode table for each DBCS lead byte

    for (my $y = 0; $y <= $#lblist; $y++)
    {
        my $base = $lblist[$y] << 8;
        printf OUTPUT "    /* lead byte %02x */\n", $lblist[$y];
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", $defw, @cp2uni[$base .. $base+255] );
        printf OUTPUT ($y < $#lblist) ? ",\n" : "\n};\n\n";
    }

    # output the lead byte subtables offsets

    my @offsets = (0) x 256;
    for (my $x = 0; $x <= $#lblist; $x++) { $offsets[$lblist[$x]] = $x + 1; }
    if ($unused)
    {
        # increment all lead bytes offset to take into account the unused table
        for (my $x = 0; $x <= $#lead_bytes; $x++) { $offsets[$lead_bytes[$x]]++; }
    }
    printf OUTPUT "static const unsigned char cp2uni_leadbytes[256] =\n";
    printf OUTPUT "{\n%s\n};\n\n", DUMP_ARRAY( "0x%02x", 0, @offsets );

    dump_uni2cp_table( 16, $def );

    # output the code page descriptor

    printf OUTPUT "const struct dbcs_table DECLSPEC_HIDDEN cptable_%03d =\n{\n", $codepage;
    printf OUTPUT "    { %d, 2, 0x%04x, 0x%04x, \"%s\" },\n",
                  $codepage, $def, $defw, $name;
    printf OUTPUT "    cp2uni,\n";
    printf OUTPUT "    cp2uni_leadbytes,\n";
    printf OUTPUT "    uni2cp_low,\n";
    printf OUTPUT "    uni2cp_high,\n";
    printf OUTPUT "    {\n    %s\n    }\n", DUMP_ARRAY( "0x%02x", 0, @lb_ranges, 0, 0 );
    printf OUTPUT "};\n";
}


################################################################
# get the list of defined lead byte ranges
sub get_lb_ranges()
{
    my @list = ();
    my @ranges = ();
    my $i = 0;
    foreach $i (@lead_bytes) { $list[$i] = 1; }
    my $on = 0;
    for (my $i = 0; $i < 256; $i++)
    {
        if ($on)
        {
            if (!defined $list[$i]) { push @ranges, $i-1; $on = 0; }
        }
        else
        {
            if ($list[$i]) { push @ranges, $i; $on = 1; }
        }
    }
    if ($on) { push @ranges, 0xff; }
    return @ranges;
}

################################################################
# dump the Indic Syllabic Category table
sub dump_indic($)
{
    my $filename = shift;
    my @indic_table;

    my $INPUT = open_data_file( $UNIDATA, "IndicSyllabicCategory.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([a-zA-Z_]+)\s*#/)
        {
            my $type = $2;
            die "unknown indic $type" unless defined $indic_types{$type};
            if (hex $1 < 65536)
            {
                $indic_table[hex $1] = $indic_types{$type};
            }
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)..\s*([0-9a-fA-F]+)\s*;\s*([A-Za-z_]+)\s*#/)
        {
            my $type = $3;
            die "unknown indic $type" unless defined $indic_types{$type};
            if (hex $1 < 65536 and hex $2 < 65536)
            {
                foreach my $i (hex $1 .. hex $2)
                {
                    $indic_table[$i] = $indic_types{$type};
                }
            }
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    $INPUT = open_data_file( $UNIDATA, "IndicPositionalCategory.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([a-zA-Z]+)\s*#/)
        {
            my $type = $2;
            die "unknown matra $type" unless defined $matra_types{$type};
            $indic_table[hex $1] += $matra_types{$type} << 8;
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)..\s*([0-9a-fA-F]+)\s*;\s*([A-Za-z_]+)\s*#/)
        {
            my $type = $3;
            die "unknown matra $type" unless defined $matra_types{$type};
            foreach my $i (hex $1 .. hex $2)
            {
                $indic_table[$i] += $matra_types{$type} << 8;
            }
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode Indic Syllabic Category */\n";
    print OUTPUT "/* generated from $UNIDATA/IndicSyllabicCategory.txt */\n";
    print OUTPUT "/*       and from $UNIDATA/IndicPositionalCategory.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "indic_syllabic_table", $indic_types{'Other'}, @indic_table );

    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the Line Break Properties table
sub dump_linebreak($)
{
    my $filename = shift;
    my @break_table;
    my $next_group = 0;

    my $INPUT = open_data_file( $UNIDATA, "LineBreak.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([0-9A-Z][0-9A-Z][0-9A-Z])+\s*/)
        {
            my $type = $2;
            die "unknown breaktype $type" unless defined $break_types{$type};
            $break_table[hex $1] = $break_types{$type};
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)..\s*([0-9a-fA-F]+)\s*;\s*([0-9A-Z][0-9A-Z][0-9A-Z])+\s*/)
        {
            my $type = $3;
            die "unknown breaktype $type" unless defined $break_types{$type};
            foreach my $i (hex $1 .. hex $2)
            {
                $break_table[$i] = $break_types{$type};
            }
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)\s*;\s*([0-9A-Z][0-9A-Z])+\s*/)
        {
            my $type = $2;
            die "unknown breaktype $type" unless defined $break_types{$type};
            $break_table[hex $1] = $break_types{$type};
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)..\s*([0-9a-fA-F]+)\s*;\s*([0-9A-Z][0-9A-Z])+\s*/)
        {
            my $type = $3;
            die "unknown breaktype $type" unless defined $break_types{$type};
            foreach my $i (hex $1 .. hex $2)
            {
                $break_table[$i] = $break_types{$type};
            }
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode Line Break Properties */\n";
    print OUTPUT "/* generated from $UNIDATA/LineBreak.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "wine_linebreak_table", $break_types{'XX'}, @break_table );

    close OUTPUT;
    save_file($filename);
}

my %scripts =
(
    "Unknown"                => 0,
    "Common"                 => 1,
    "Inherited"              => 2,
    "Arabic"                 => 3,
    "Armenian"               => 4,
    "Avestan"                => 5,
    "Balinese"               => 6,
    "Bamum"                  => 7,
    "Batak"                  => 8,
    "Bengali"                => 9,
    "Bopomofo"               => 10,
    "Brahmi"                 => 11,
    "Braille"                => 12,
    "Buginese"               => 13,
    "Buhid"                  => 14,
    "Canadian_Aboriginal"    => 15,
    "Carian"                 => 16,
    "Cham"                   => 17,
    "Cherokee"               => 18,
    "Coptic"                 => 19,
    "Cuneiform"              => 20,
    "Cypriot"                => 21,
    "Cyrillic"               => 22,
    "Deseret"                => 23,
    "Devanagari"             => 24,
    "Egyptian_Hieroglyphs"   => 25,
    "Ethiopic"               => 26,
    "Georgian"               => 27,
    "Glagolitic"             => 28,
    "Gothic"                 => 29,
    "Greek"                  => 30,
    "Gujarati"               => 31,
    "Gurmukhi"               => 32,
    "Han"                    => 33,
    "Hangul"                 => 34,
    "Hanunoo"                => 35,
    "Hebrew"                 => 36,
    "Hiragana"               => 37,
    "Imperial_Aramaic"       => 38,
    "Inscriptional_Pahlavi"  => 39,
    "Inscriptional_Parthian" => 40,
    "Javanese"               => 41,
    "Kaithi"                 => 42,
    "Kannada"                => 43,
    "Katakana"               => 44,
    "Kayah_Li"               => 45,
    "Kharoshthi"             => 46,
    "Khmer"                  => 47,
    "Lao"                    => 48,
    "Latin"                  => 49,
    "Lepcha"                 => 50,
    "Limbu"                  => 51,
    "Linear_B"               => 52,
    "Lisu"                   => 53,
    "Lycian"                 => 54,
    "Lydian"                 => 55,
    "Malayalam"              => 56,
    "Mandaic"                => 57,
    "Meetei_Mayek"           => 58,
    "Mongolian"              => 59,
    "Myanmar"                => 60,
    "New_Tai_Lue"            => 61,
    "Nko"                    => 62,
    "Ogham"                  => 63,
    "Ol_Chiki"               => 64,
    "Old_Italic"             => 65,
    "Old_Persian"            => 66,
    "Old_South_Arabian"      => 67,
    "Old_Turkic"             => 68,
    "Oriya"                  => 69,
    "Osmanya"                => 70,
    "Phags_Pa"               => 71,
    "Phoenician"             => 72,
    "Rejang"                 => 73,
    "Runic"                  => 74,
    "Samaritan"              => 75,
    "Saurashtra"             => 76,
    "Shavian"                => 77,
    "Sinhala"                => 78,
    "Sundanese"              => 79,
    "Syloti_Nagri"           => 80,
    "Syriac"                 => 81,
    "Tagalog"                => 82,
    "Tagbanwa"               => 83,
    "Tai_Le"                 => 84,
    "Tai_Tham"               => 85,
    "Tai_Viet"               => 86,
    "Tamil"                  => 87,
    "Telugu"                 => 88,
    "Thaana"                 => 89,
    "Thai"                   => 90,
    "Tibetan"                => 91,
    "Tifinagh"               => 92,
    "Ugaritic"               => 93,
    "Vai"                    => 94,
    "Yi"                     => 95,
    # Win8/Win8.1
    "Chakma"                 => 96,
    "Meroitic_Cursive"       => 97,
    "Meroitic_Hieroglyphs"   => 98,
    "Miao"                   => 99,
    "Sharada"                => 100,
    "Sora_Sompeng"           => 101,
    "Takri"                  => 102,
    # Win10
    "Bassa_Vah"              => 103,
    "Caucasian_Albanian"     => 104,
    "Duployan"               => 105,
    "Elbasan"                => 106,
    "Grantha"                => 107,
    "Khojki"                 => 108,
    "Khudawadi"              => 109,
    "Linear_A"               => 110,
    "Mahajani"               => 111,
    "Manichaean"             => 112,
    "Mende_Kikakui"          => 113,
    "Modi"                   => 114,
    "Mro"                    => 115,
    "Nabataean"              => 116,
    "Old_North_Arabian"      => 117,
    "Old_Permic"             => 118,
    "Pahawh_Hmong"           => 119,
    "Palmyrene"              => 120,
    "Pau_Cin_Hau"            => 121,
    "Psalter_Pahlavi"        => 122,
    "Siddham"                => 123,
    "Tirhuta"                => 124,
    "Warang_Citi"            => 125,
    # Win10 RS1
    "Adlam"                  => 126,
    "Ahom"                   => 127,
    "Anatolian_Hieroglyphs"  => 128,
    "Bhaiksuki"              => 129,
    "Hatran"                 => 130,
    "Marchen"                => 131,
    "Multani"                => 132,
    "Newa"                   => 133,
    "Old_Hungarian"          => 134,
    "Osage"                  => 135,
    "SignWriting"            => 136,
    "Tangut"                 => 137,
    # Win10 RS4
    "Masaram_Gondi"          => 138,
    "Nushu"                  => 139,
    "Soyombo"                => 140,
    "Zanabazar_Square"       => 141,
);

################################################################
# dump Script IDs table
sub dump_scripts($)
{
    my $filename = shift;
    my $header = $filename;
    my @scripts_table;
    my $script_index;
    my $i;

    my $INPUT = open_data_file( $UNIDATA, "Scripts.txt" );
    # Fill the table
    # Unknown script id is always 0, so undefined scripts are automatically treated as such
    while (<$INPUT>)
    {
        my $type = "";

        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([a-zA-Z_]+)\s*/)
        {
            $type = $2;
            if (defined $scripts{$type})
            {
                $scripts_table[hex $1] = $scripts{$type};
            }
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)..\s*([0-9a-fA-F]+)\s*;\s*([a-zA-Z_]+)\s*/)
        {
            $type = $3;
            if (defined $scripts{$type})
            {
                foreach my $i (hex $1 .. hex $2)
                {
                    $scripts_table[$i] = $scripts{$type};
                }
            }
            next;
        }
    }

    close $INPUT;

    $header = "$filename.h";
    open OUTPUT,">$header.new" or die "Cannot create $header";
    print "Building $header\n";
    print OUTPUT "/* Unicode Script IDs */\n";
    print OUTPUT "/* generated from $UNIDATA/Scripts.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";

    print OUTPUT "enum unicode_script_id {\n";
    foreach my $script (sort { $scripts{$a} <=> $scripts{$b} } keys %scripts)
    {
        print OUTPUT "    Script_$script = $scripts{$script},\n";
    }
    print OUTPUT "    Script_LastId = ", (scalar keys %scripts) - 1, "\n";
    print OUTPUT "};\n";

    close OUTPUT;
    save_file($header);

    $filename = "$filename.c";
    open OUTPUT,">$filename.new" or die "Cannot create $header";
    print "Building $filename\n";
    print OUTPUT "/* Unicode Script IDs */\n";
    print OUTPUT "/* generated from $UNIDATA/Scripts.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "wine_scripts_table", 0, @scripts_table );
    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the BiDi mirroring table
sub dump_mirroring($)
{
    my $filename = shift;
    my @mirror_table = ();

    my $INPUT = open_data_file( $UNIDATA, "BidiMirroring.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([0-9a-fA-F]+)/)
        {
            $mirror_table[hex $1] = hex $2;
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode BiDi mirroring */\n";
    print OUTPUT "/* generated from $UNIDATA/BidiMirroring.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";
    DUMP_CASE_TABLE( "DECLSPEC_HIDDEN wine_mirror_map", @mirror_table );
    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the Bidi Brackets
sub dump_bracket($)
{
    my $filename = shift;
    my @bracket_table;

    my $INPUT = open_data_file( $UNIDATA, "BidiBrackets.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([0-9a-fA-F]+);\s*([con])/)
        {
            my $type = $3;
            die "unknown bracket $type" unless defined $bracket_types{$type};
            die "characters too distant $1 and $2" if abs(hex($2) - hex($1)) >= 128;
            $bracket_table[hex $1] = (hex($2) - hex($1)) % 255;
            $bracket_table[hex $1] += $bracket_types{$type} << 8;
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode Bidirectional Bracket table */\n";
    print OUTPUT "/* generated from $UNIDATA/BidiBrackets.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "bidi_bracket_table", 0, @bracket_table );

    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the Arabic shaping table
sub dump_shaping($)
{
    my $filename = shift;
    my %groups;
    my $next_group = 0;

    $groups{"No_Joining_Group"} = $next_group++;

    my $INPUT = open_data_file( $UNIDATA, "ArabicShaping.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;.*;\s*([RLDCUT])\s*;\s*(\w+)/)
        {
            my $type = $2;
            my $group = $3;
            $groups{$group} = $next_group++ unless defined $groups{$group};
            $joining_table[hex $1] = $joining_types{$type} | ($groups{$group} << 8);
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode Arabic shaping */\n";
    print OUTPUT "/* generated from $UNIDATA/ArabicShaping.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "wine_shaping_table", 0, @joining_table );

    print OUTPUT "\nconst unsigned short DECLSPEC_HIDDEN wine_shaping_forms[256][4] =\n{\n";
    for (my $i = 0x600; $i <= 0x6ff; $i++)
    {
        printf OUTPUT "    { 0x%04x, 0x%04x, 0x%04x, 0x%04x },\n",
            ${joining_forms{"isolated"}}[$i] || $i,
            ${joining_forms{"final"}}[$i] || $i,
            ${joining_forms{"initial"}}[$i] || $i,
            ${joining_forms{"medial"}}[$i] || $i;
    }
    print OUTPUT "};\n";

    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the Vertical Orientation table
sub dump_vertical($)
{
    my $filename = shift;
    my @vertical_table;

    my $INPUT = open_data_file( $UNIDATA, "VerticalOrientation.txt" );
    while (<$INPUT>)
    {
        next if /^\#/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        if (/^\s*([0-9a-fA-F]+)\s*;\s*([a-zA-Z_]+)\s*/)
        {
            my $type = $2;
            die "unknown vertical $type" unless defined $vertical_types{$type};
            if (hex $1 < 65536)
            {
                $vertical_table[hex $1] = $vertical_types{$type};
            }
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)..\s*([0-9a-fA-F]+)\s*;\s*([A-Za-z_]+)\s*/)
        {
            my $type = $3;
            die "unknown vertical $type" unless defined $vertical_types{$type};
            foreach my $i (hex $1 .. hex $2)
            {
                $vertical_table[$i] = $vertical_types{$type};
            }
            next;
        }
        die "malformed line $_";
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode Vertical Orientation */\n";
    print OUTPUT "/* generated from $UNIDATA/VerticalOrientation.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "vertical_orientation_table", $vertical_types{'R'}, @vertical_table );

    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the digit folding tables
sub dump_digit_folding($)
{
    my $filename = shift;
    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode digit folding mappings */\n";
    print OUTPUT "/* generated from $UNIDATA/UnicodeData.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    DUMP_CASE_TABLE( "DECLSPEC_HIDDEN wine_digitmap",  @digitmap_table );
    print OUTPUT "\n";
    DUMP_CASE_TABLE( "DECLSPEC_HIDDEN wine_compatmap", @compatmap_table );
    close OUTPUT;
    save_file($filename);
}


################################################################
# dump the case mapping tables
sub DUMP_CASE_MAPPINGS($)
{
    my $filename = shift;
    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode case mappings */\n";
    print OUTPUT "/* generated from $UNIDATA/UnicodeData.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    DUMP_CASE_TABLE( "wine_casemap_lower", @tolower_table );
    print OUTPUT "\n";
    DUMP_CASE_TABLE( "wine_casemap_upper", @toupper_table );
    close OUTPUT;
    save_file($filename);
}


################################################################
# dump a case mapping table
sub DUMP_CASE_TABLE($@)
{
    my ($name,@table) = @_;

    # count the number of sub tables that contain something
    # also compute the low and upper populated bounds

    my @lowerbounds = ( 0, 0 );
    my @upperbounds = ( 0, 255 );
    my $index = 0;
    my @filled = ();
    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $table[$i];
        if (!defined $filled[$i >> 8])
        {
          $lowerbounds[$index] = $i & 0xff;
          $upperbounds[$index] = 0xff - $lowerbounds[$index];
          $filled[$i >> 8] = $index * 256 + 512;
          $index++;
        }
        else
        {
          $upperbounds[$index-1] = 0xff - ($i & 0xff);
        }
        $table[$i] = ($table[$i] - $i) & 0xffff;
    }

    # Collapse blocks upwards if possible
    my $removed = 0;
    $index = 0;
    for (my $i = 0; $i < 256; $i++)
    {
        next unless defined $filled[$i];
        if ($upperbounds[$index - 1] > $lowerbounds[$index])
        {
           $removed = $removed + $lowerbounds[$index];
        }
        else
        {
           $removed = $removed + $upperbounds[$index - 1];
           $lowerbounds[$index] = $upperbounds[$index - 1];
        }
        $filled[$i] = $filled[$i] - $removed;
        $index++;
    }

    # dump the table

    printf OUTPUT "const WCHAR %s[%d] =\n", $name, $index * 256 + 512 - $removed;
    printf OUTPUT "{\n    /* index */\n";
    printf OUTPUT "%s,\n", DUMP_ARRAY( "0x%04x", 256, @filled );
    printf OUTPUT "    /* defaults */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, (0) x 256 );
    $index = 0;
    for (my $i = 0; $i < 256; $i++)
    {
        next unless $filled[$i];
        printf OUTPUT ",\n    /* 0x%02x%02x .. 0x%02xff */\n", $i, $lowerbounds[$index], $i;
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0,
                      @table[($i<<8) + $lowerbounds[$index] .. ($i<<8)+255] );
        $index++;
    }
    printf OUTPUT "\n};\n";
}

################################################################
# compress a mapping table by removing identical rows
sub compress_array($$@)
{
    my $rows = shift;
    my $def = shift;
    my @table = @_;
    my $len = @table / $rows;
    my @array = (0) x $rows;
    my %sequences;

    # try to merge table rows
    for (my $row = 0; $row < $rows; $row++)
    {
        my @table_row = map { defined($_) ? $_ : $def; } @table[($row * $len)..($row * $len + $len - 1)];
        my $rowtxt = pack "S*", @table_row;
        if (defined($sequences{$rowtxt}))
        {
            # reuse an existing row
            $array[$row] = $sequences{$rowtxt};
        }
        else
        {
            # create a new row
            $sequences{$rowtxt} = $array[$row] = $#array + 1;
            push @array, @table_row;
        }
    }
    return @array;
}

################################################################
# dump a simple char -> 16-bit value mapping table
sub dump_simple_mapping($$@)
{
    my $name = shift;
    my $def = shift;
    my @array = compress_array( 256, $def, @_[0..65535] );

    printf OUTPUT "const unsigned short %s[%d] =\n{\n", $name, $#array+1;
    printf OUTPUT "    /* offsets */\n%s,\n", DUMP_ARRAY( "0x%04x", 0, @array[0..255] );
    printf OUTPUT "    /* values */\n%s\n};\n", DUMP_ARRAY( "0x%04x", 0, @array[256..$#array] );
}

################################################################
# dump a char -> 16-bit value mapping table using two-level tables
sub dump_two_level_mapping($$@)
{
    my $name = shift;
    my $def = shift;
    my @row_array = compress_array( 4096, $def, @_[0..65535] );
    my @array = compress_array( 256, 0, @row_array[0..4095] );

    for (my $i = 256; $i < @array; $i++) { $array[$i] += @array - 4096; }

    printf OUTPUT "const unsigned short DECLSPEC_HIDDEN %s[%d] =\n{\n", $name, @array + @row_array - 4096;
    printf OUTPUT "    /* level 1 offsets */\n%s,\n", DUMP_ARRAY( "0x%04x", 0, @array[0..255] );
    printf OUTPUT "    /* level 2 offsets */\n%s,\n", DUMP_ARRAY( "0x%04x", 0, @array[256..$#array] );
    printf OUTPUT "    /* values */\n%s\n};\n", DUMP_ARRAY( "0x%04x", 0, @row_array[4096..$#row_array] );
}

################################################################
# dump a binary case mapping table in l_intl.nls format
sub dump_binary_case_table(@)
{
    my (@table) = @_;

    my %difftables_hash = ();
    my @difftables;
    my %offtables2_hash = ();
    my @offtables2 = ();
    
    my @offtable = ();
    for (my $i = 0; $i < 256; $i++)
    {
        my @offtable2 = ();
        for(my $j = 0; $j < 16; $j++) # offset table for xx00-xxFF characters
        {
            my @difftable;
            for (my $k = 0; $k < 16; $k++) # case map table for xxx0-xxxF characters
            {
                my $char = ($i<<8) + ($j<<4) + $k;
                $difftable[$k] = (defined $table[$char]) ? (($table[$char]-$char) & 0xffff) : 0;
            }

            my $diff_key = pack "S*", @difftable;
            my $offset3 = $difftables_hash{$diff_key};
            if (!defined $offset3)
            {
                $offset3 = scalar @difftables;
                $difftables_hash{$diff_key} = $offset3;
                push @difftables, @difftable;
            }
            $offtable2[$j] = $offset3;
        }

        my $offtable2_key = pack "S*", @offtable2;
        my $offset2 = $offtables2_hash{$offtable2_key};
        if (!defined $offset2)
        {
            $offset2 = scalar @offtables2;
            $offtables2_hash{$offtable2_key} = $offset2;
            push @offtables2, \@offtable2;
        }
        $offtable[$i] = $offset2;
    }

    my @output;
    my $offset = 0x100; # offset of first subtable in words
    foreach (@offtable)
    {
        push @output, 0x10 * $_ + $offset; # offset of subtable in words
    }

    $offset = 0x100 + 0x10 * scalar @offtables2; # offset of first difftable in words
    foreach(@offtables2)
    {
        my $table = $_;
        foreach(@$table)
        {
            push @output, $_ + $offset; # offset of difftable in words
        }
    }

    my $len = 1 + scalar @output + scalar @difftables;
    return pack "S<*", $len, @output, @difftables;
}


################################################################
# dump case mappings for l_intl.nls
sub dump_intl_nls($)
{
    my $filename = shift;
    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    printf "Building $filename\n";

    binmode OUTPUT;
    print OUTPUT pack "S<", 1;  # version
    print OUTPUT dump_binary_case_table( @toupper_table );
    print OUTPUT dump_binary_case_table( @tolower_table );
    close OUTPUT;
    save_file($filename);
}


sub load_nameprep_range_table($$$)
{
    my ($INPUT, $val, $table_ref) = @_;

    while (<$INPUT>)
    {
        if (/^\s*([0-9a-fA-F]+)-([0-9a-fA-F]+)/)
        {
            my $last = hex $2;
            $last = 65535 if($last >= 65536);
            foreach my $i (hex $1 .. $last)
            {
                $table_ref->[$i] |= $val;
            }
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+)/)
        {
            if (hex $1 < 65536)
            {
                $table_ref->[hex $1] |= $val;
            }
            next;
        }

        return if (/End\sTable/);
    }
}

sub load_nameprep_map_table($$)
{
    my ($INPUT, $table_ref) = @_;

    while (<$INPUT>)
    {
        if (/^\s*([0-9a-fA-F]+);\s;/)
        {
            # special value for map to nothing
            $table_ref->[hex $1] = [0xffff, 0xffff, 0xffff];
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+);\s([0-9a-fA-F]+);/)
        {
            $table_ref->[hex $1] = [hex $2, 0, 0];
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+);\s([0-9a-fA-F]+)\s([0-9a-fA-F]+);/)
        {
            $table_ref->[hex $1] = [hex $2, hex $3, 0];
            next;
        }
        elsif (/^\s*([0-9a-fA-F]+);\s([0-9a-fA-F]+)\s([0-9a-fA-F]+)\s([0-9a-fA-F]+);/)
        {
            $table_ref->[hex $1] = [hex $2, hex $3, hex $4];
            next;
        }

        return if (/End\sTable/);
    }
}

################################################################
# dump mapping table, prohibited characters set, unassigned
# characters, bidirectional rules used by nameprep algorithm
sub dump_nameprep($)
{
    my $filename = shift;
    my @mapping_table = ();
    my @flags_table;

    my $INPUT = open_data_file( $RFCS, $STRINGPREP );
    while (<$INPUT>)
    {
        next unless /Start\sTable/;

        load_nameprep_range_table($INPUT, $nameprep_flags{"unassigned"}, \@flags_table) if (/A.1/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.1.2/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.2.2/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.3/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.4/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.5/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.6/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.7/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.8/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"prohibited"}, \@flags_table) if (/C.9/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"bidi_ral"}, \@flags_table) if (/D.1/);
        load_nameprep_range_table($INPUT, $nameprep_flags{"bidi_l"}, \@flags_table) if (/D.2/);

        load_nameprep_map_table($INPUT, \@mapping_table) if (/B.1/);
        load_nameprep_map_table($INPUT, \@mapping_table) if (/B.2/);
    }
    close $INPUT;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Nameprep algorithm related data */\n";
    print OUTPUT "/* generated from $RFCS/$STRINGPREP */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    dump_two_level_mapping( "nameprep_char_type", 0, @flags_table );

    ######### mapping table
    # first determine all the 16-char subsets that contain something
    my @filled = ();
    my $pos = 16*3;  # for the null subset
    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $mapping_table[$i];
        $filled[$i >> 4] = $pos;
        $pos += 16*3;
        $i |= 15;
    }
    my $total = $pos;

    # now count the 256-char subsets that contain something
    my @filled_idx = (256) x 256;
    $pos = 256 + 16;
    for (my $i = 0; $i < 4096; $i++)
    {
        next unless $filled[$i];
        $filled_idx[$i >> 4] = $pos;
        $pos += 16;
        $i |= 15;
    }
    my $null_offset = $pos;
    $total += $pos;

    # add the index offsets to the subsets positions
    for (my $i = 0; $i < 4096; $i++)
    {
        next unless $filled[$i];
        $filled[$i] += $null_offset;
    }

    # dump the main index
    printf OUTPUT "const unsigned short DECLSPEC_HIDDEN nameprep_mapping[%d] =\n", $total;
    printf OUTPUT "{\n    /* index */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @filled_idx );
    printf OUTPUT ",\n    /* null sub-index */\n%s", DUMP_ARRAY( "0x%04x", 0, ($null_offset) x 16 );

    # dump the second-level indexes
    for (my $i = 0; $i < 256; $i++)
    {
        next unless ($filled_idx[$i] > 256);
        my @table = @filled[($i<<4)..($i<<4)+15];
        for (my $j = 0; $j < 16; $j++) { $table[$j] ||= $null_offset; }
        printf OUTPUT ",\n    /* sub-index %02x */\n", $i;
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @table );
    }

    # dump the 16-char subsets
    printf OUTPUT ",\n    /* null mapping */\n";
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, (0) x 48 );

    for (my $i = 0; $i < 4096; $i++)
    {
        next unless $filled[$i];
        my @table = (0) x 48;
        for (my $j = 0; $j < 16; $j++)
        {
            if (defined $mapping_table[($i<<4) + $j])
            {
                $table[3 * $j] = ${$mapping_table[($i << 4) + $j]}[0];
                $table[3 * $j + 1] = ${$mapping_table[($i << 4) + $j]}[1];
                $table[3 * $j + 2] = ${$mapping_table[($i << 4) + $j]}[2];
            }
        }
        printf OUTPUT ",\n    /* 0x%03x0 .. 0x%03xf */\n", $i, $i;
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @table );
    }

    printf OUTPUT "\n};\n";

    close OUTPUT;
    save_file($filename);
}

################################################################
# dump the ctype tables
sub DUMP_CTYPE_TABLES($)
{
    my $filename = shift;
    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    printf "Building $filename\n";
    printf OUTPUT "/* Unicode ctype tables */\n";
    printf OUTPUT "/* Automatically generated; DO NOT EDIT!! */\n\n";
    printf OUTPUT "#include \"wine/unicode.h\"\n\n";

    # add the direction in the high 4 bits of the category
    for (my $i = 0; $i < 65536; $i++)
    {
        $category_table[$i] |= $direction_table[$i] << 12 if defined $direction_table[$i];
    }

    dump_simple_mapping( "wine_wctype_table", 0, @category_table );

    close OUTPUT;
    save_file($filename);
}


################################################################
# dump the char composition table
sub dump_compose_table($)
{
    my $filename = shift;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode char composition */\n";
    print OUTPUT "/* generated from $UNIDATA/UnicodeData.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    my @filled = ();
    foreach my $i (@compose_table)
    {
        my @comp = @$i;
        push @{$filled[$comp[1]]}, [ $comp[0], $comp[2] ];
    }

    # count how many different second chars we have

    my $count = 0;
    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $filled[$i];
        $count++;
    }

    # build the table of second chars and offsets

    my $pos = $count + 1;
    my @table = ();
    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $filled[$i];
        push @table, $i, $pos;
        $pos += @{$filled[$i]};
    }
    # terminator with last position
    push @table, 0, $pos;
    printf OUTPUT "static const WCHAR table[0x%x] =\n{\n", 2*$pos;
    printf OUTPUT "    /* second chars + offsets */\n%s", DUMP_ARRAY( "0x%04x", 0, @table );

    # build the table of first chars and mappings

    for (my $i = 0; $i < 65536; $i++)
    {
        next unless defined $filled[$i];
        my @table = ();
        my @list = sort { $a->[0] <=> $b->[0] } @{$filled[$i]};
        for (my $j = 0; $j <= $#list; $j++)
        {
            push @table, $list[$j][0], $list[$j][1];
        }
        printf OUTPUT ",\n    /* 0x%04x */\n%s", $i, DUMP_ARRAY( "0x%04x", 0, @table );
    }
    print OUTPUT "\n};\n\n";
    print OUTPUT <<"EOF";
#include "decompose.c"

static inline int binary_search( WCHAR ch, int low, int high )
{
    while (low <= high)
    {
        int pos = (low + high) / 2;
        if (table[2 * pos] < ch) low = pos + 1;
        else if (table[2 * pos] > ch) high = pos - 1;
        else return pos;
    }
    return -1;
}

WCHAR DECLSPEC_HIDDEN wine_compose( const WCHAR *str )
{
    int pos, idx = 1, start = 0, count = $count;
    for (;;)
    {
        if ((pos = binary_search( str[idx], start, count - 1 )) == -1) return 0;
        if (!idx--) return table[2 * pos + 1];
        start = table[2 * pos + 1];
        count = table[2 * pos + 3];
    }
}

static inline int is_blocked(WCHAR *ptr1, WCHAR *ptr2)
{
    if (ptr1 >= ptr2) return -1;

    while (++ptr1 < ptr2)
    {
        const WCHAR *map1, *map2;
        map1 = unicode_table_lookup( *ptr1, 0, idx1_comb, 8, idx2_comb, 4,
                                     offsets_comb, 4, data_comb, 0 );
        map2 = unicode_table_lookup( *ptr2, 0, idx1_comb, 8, idx2_comb, 4,
                                     offsets_comb, 4, data_comb, 0 );
        if (*map1 == 0 || *map2 <= *map1) return 1;
    }
    return 0;
}

static inline int is_fullexcl(WCHAR ch)
{
    const WCHAR *map = unicode_table_lookup( ch, 0, idx1_fullcomp, 8, idx2_fullcomp,
                                             4, offsets_fullcomp, 4, data_fullcomp, 0 );
    return (int)*map;
}

int unicode_canonical_composition( WCHAR *str, int strlen )
{
    int i, j;
    WCHAR dum[3] = {0};

    if (strlen == 0) strlen = strlenW( str );

    for (i = 1; i < strlen; i++)
    {
        WCHAR *ptr_comp = str+i-1, comp;
        if (str[i] == 0) break;
        while (ptr_comp - str > 0)
        {
            if (is_starter( *ptr_comp )) break;
            --ptr_comp;
        }
        if (!is_starter( *ptr_comp ) || is_blocked( ptr_comp, str+i )) continue;
        dum[0] = *ptr_comp;
        dum[1] = str[i];
        comp = wine_compose( dum );
        if (!comp || is_fullexcl( comp )) continue;
        *ptr_comp = comp;
        for (j = i; j < strlen-1; j++) str[j] = str[j+1];
        strlen--;
        i--;
    }

    return strlen;
}
EOF
    close OUTPUT;
    save_file($filename);
}

sub do_decomp
{
    my ($char, $table_ref, $compat) = @_;

    return ($char) unless defined $table_ref->[$char];
    my $data = $table_ref->[$char];
    return ($char) if $data->[0] && !$compat;
    my @mapping = ();
    for my $ch (@{$data->[1]})
    {
        push @mapping, $ch;
    }
    return @mapping;
}

sub expand_pairs
{
    my @data = @_;
    my @result = ();

    for my $ch (@data)
    {
        if ($ch <= 0xFFFF)
        {
            push @result, $ch;
        }
        elsif ($ch >= 2097152) # 2**21
        {
            die sprintf "Invalid Unicode character %04x\n", $ch;
        }
        else
        {
            my $hx = $ch & 0xFFFF;
            my $hu = ($ch >> 16) & ((1 << 5) - 1);
            my $hw = ($hu - 1) & 0xFFFF;
            my $hi = 0xD800 | ($hw << 6) | ($hx >> 10);
            my $lx = $ch & 0xFFFF;
            my $lo = (0xDC00 | ($lx & ((1 << 10) - 1))) & 0xFFFF;
            push @result, $hi;
            push @result, $lo;
        }
    }
    return @result;
}

################################################################
# dump the char decomposition table
sub dump_decompose_table($)
{
    my $filename = shift;

    open OUTPUT,">$filename.new" or die "Cannot create $filename";
    print "Building $filename\n";
    print OUTPUT "/* Unicode char decomposition */\n";
    print OUTPUT "/* generated from $UNIDATA/UnicodeData.txt */\n";
    print OUTPUT "/* DO NOT EDIT!! */\n\n";
    print OUTPUT "#include \"wine/unicode.h\"\n\n";

    # limit code points to BMP
    my $utflim = 65536;
    my %nfd_lookup = ();
    my %nfkd_lookup = ();
    my %decomp_lookup = ();
    my %comb_lookup = ();
    my %fullcomp_lookup = ();
    my @decomp_data = (0);
    my @comb_data = (0);
    my @full_comp_data = (0);
    my $pos = 1;
    my $pos_comb = 1;
    my $pos_fullcomp = 1;
    my $lastchar_decomp;
    my $lastchar_comb;
    my $lastchar_fullcomp;

    for (my $i = 0; $i < $utflim; $i++)
    {
        next unless defined $decomp_table[$i] || defined $comb_class_table[$i] || defined $full_comp_table[$i];

        if (defined $decomp_table[$i])
        {
            $lastchar_decomp = $i;
            # fully expand input and mappings

            my @char;
            push @char, $i;
            push @char, 0;
            my $char = pack "n*", @char;

            my @nfd = do_decomp( $i, \@decomp_table, 0 );
            push @nfd, 0;
            my $nfd = pack "n*", @nfd;

            my @nfkd = do_decomp( $i, \@decomp_table, 1 );
            push @nfkd, 0;
            my $nfkd = pack "n*", @nfkd;

            # lookup or add mappings

            if ($nfd eq $char)
            {
                $nfd = undef;
            }
            elsif (exists $decomp_lookup{$nfd})
            {
                $nfd_lookup{$i} = $decomp_lookup{$nfd};
            }
            else
            {
                push @decomp_data, @nfd;
                $decomp_lookup{$nfd} = $pos;
                $nfd_lookup{$i} = $pos;
                $pos += @nfd;
            }

            if ($nfkd eq $char)
            {
                $nfkd = undef;
            }
            elsif (exists $decomp_lookup{$nfkd})
            {
                $nfkd_lookup{$i} = $decomp_lookup{$nfkd};
            }
            else
            {
                push @decomp_data, @nfkd;
                $decomp_lookup{$nfkd} = $pos;
                $nfkd_lookup{$i} = $pos;
                $pos += @nfkd;
            }
        }
        if (defined $comb_class_table[$i])
        {
            push @comb_data, $comb_class_table[$i];
            $lastchar_comb = $i;
            $comb_lookup{$i} = $pos_comb;
            $pos_comb++;
        }
        if (defined $full_comp_table[$i])
        {
            push @full_comp_data, $full_comp_table[$i];
            $lastchar_fullcomp = $i;
            $fullcomp_lookup{$i} = $pos_fullcomp;
            $pos_fullcomp++;
        }
    }

    printf OUTPUT "static const UINT last_decomposable = 0x%x;\n\n", $lastchar_decomp;

    # dump decomposition data

    printf OUTPUT "static const WCHAR data_decomp[%d] =\n", $pos;
    print OUTPUT "{\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @decomp_data );
    print OUTPUT "\n};\n\n";

    # find 256-char subsets that contain something

    my $filled_pos = 1;
    my $filled_lim = ($lastchar_decomp >> 8) + 1;
    my @filled = (0) x $filled_lim;
    for (my $i = 0; $i < $utflim; $i++)
    {
        last if $i > $lastchar_decomp;
        next unless exists $nfd_lookup{$i} || exists $nfkd_lookup{$i};
        $filled[$i >> 8] = $filled_pos++;
        $i |= 255;
    }

    # dump index of 256-char subsets

    printf OUTPUT "static const BYTE idx1_decomp[%d] =\n", $filled_lim;
    print OUTPUT "{\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%02x", 0, @filled );
    print OUTPUT "\n};\n\n";

    # for 256-char subsets, find non-empty 16-char subsets

    my $sub_filled_pos = 1;
    my %sub_filled = ();
    for (my $i = 0; $i < $filled_lim; $i++)
    {
        next unless $filled[$i];
        for (my $j = 0; $j < 256; $j++)
        {
            my $idx = ($i << 8) | $j;
            next unless exists $nfd_lookup{$idx} || exists $nfkd_lookup{$idx};
            $sub_filled{$idx >> 4} = $sub_filled_pos++;
            $j |= 15;
        }
    }

    # dump index of 16-char subsets

    printf OUTPUT "static const USHORT idx2_decomp[%d] =\n", $filled_pos * 16;
    print OUTPUT "{\n";
    my @null_idx = (0) x 16;
    print OUTPUT "    /* null sub-index */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @null_idx );
    for (my $i = 0; $i < $filled_lim; $i++)
    {
        next unless $filled[$i];
        printf OUTPUT ",\n    /* sub-index 0x%02x */\n", $filled[$i];

        my @sub_idx;
        for (my $j = 0; $j < 16; $j++)
        {
            my $idx = ($i << 4) | $j;
            $sub_idx[$j] = $sub_filled{$idx} || 0;
        }
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @sub_idx );
    }
    print OUTPUT "\n};\n\n";

    # dump the 16-char subsets

    printf OUTPUT "static const USHORT offsets_decomp[%d] =\n", 32 * $sub_filled_pos;
    print OUTPUT "{\n";
    print OUTPUT "    /* (nfd, nfkd) x 16 */\n";
    my @null_table = (0) x 32;
    print OUTPUT "    /* no decomposition */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @null_table );
    for my $key (sort {$a <=> $b} keys %sub_filled)
    {
        printf OUTPUT ",\n    /* 0x%03x0 .. 0x%03xf */\n", $key, $key;
        my @sub_table;
        for (my $j = 0; $j < 16; $j++)
        {
            my $idx = ($key << 4) | $j;
            $sub_table[2 * $j] = $nfd_lookup{$idx} || 0;
            $sub_table[2 * $j + 1] = $nfkd_lookup{$idx} || 0;
        }
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @sub_table );
    }
    print OUTPUT "\n};\n\n";

    # now for Compatibility Class

    printf OUTPUT "static const WCHAR data_comb[%d] =\n", $pos_comb;
    print OUTPUT "{\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @comb_data );
    print OUTPUT "\n};\n\n";

    my $comb_pos = 1;
    my $comb_lim = ($lastchar_comb >> 8) + 1;
    my @comb_filled = (0) x $comb_lim;
    for (my $i = 0; $i < $utflim; $i++)
    {
        last if $i > $lastchar_comb;
        next unless defined $comb_class_table[$i];
        $comb_filled[$i >> 8] = $comb_pos++;
        $i |= 255;
    }
    printf OUTPUT "static const BYTE idx1_comb[%d] =\n", $comb_lim;
    print OUTPUT "{\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%02x", 0, @comb_filled );
    print OUTPUT "\n};\n\n";

    my $sub_comb_filled_pos = 1;
    my %sub_comb_filled = ();
    for (my $i = 0; $i < $comb_lim; $i++)
    {
        next unless $comb_filled[$i];
        for (my $j = 0; $j < 256; $j++)
        {
            my $idx = ($i << 8) | $j;
            next unless defined $comb_class_table[$idx];
            $sub_comb_filled{$idx >> 4} = $sub_comb_filled_pos++;
            $j |= 15;
        }
    }

    printf OUTPUT "static const USHORT idx2_comb[%d] =\n", $comb_pos * 16;
    print OUTPUT "{\n";
    @null_idx = (0) x 16;
    print OUTPUT "    /* all-zero 256-char blocks get mapped to here */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @null_idx );
    for (my $i = 0; $i < $comb_lim; $i++)
    {
        next unless $comb_filled[$i];
        printf OUTPUT ",\n    /* sub-index 0x%02x */\n", $comb_filled[$i];

        my @sub_idx;
        for (my $j = 0; $j < 16; $j++)
        {
            my $idx = ($i << 4) | $j;
            $sub_idx[$j] = $sub_comb_filled{$idx} || 0;
        }
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @sub_idx );
    }
    print OUTPUT "\n};\n\n";

    printf OUTPUT "static const USHORT offsets_comb[%d] =\n", 16 * $sub_comb_filled_pos;
    print OUTPUT "{\n";
    @null_table = (0) x 16;
    print OUTPUT "    /* all-zero 16-char blocks get mapped to here */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @null_table );
    for my $key (sort {$a <=> $b} keys %sub_comb_filled)
    {
        printf OUTPUT ",\n    /* 0x%03x0 .. 0x%03xf */\n", $key, $key;
        my @sub_table;
        for (my $j = 0; $j < 16; $j++)
        {
            my $idx = ($key << 4) | $j;
            $sub_table[$j] = $comb_lookup{$idx} || 0;
        }
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @sub_table );
    }
    print OUTPUT "\n};\n\n";

    # now for Full Composition Exclusion

    printf OUTPUT "const WCHAR data_fullcomp[%d] =\n", $pos_fullcomp;
    print OUTPUT "{\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @full_comp_data );
    print OUTPUT "\n};\n\n";

    my $fullcomp_pos = 1;
    my $fullcomp_lim = ($lastchar_fullcomp >> 8) + 1;
    my @fullcomp_filled = (0) x $fullcomp_lim;
    for (my $i = 0; $i < $utflim; $i++)
    {
        last if $i > $lastchar_fullcomp;
        next unless defined $full_comp_table[$i];
        $fullcomp_filled[$i >> 8] = $fullcomp_pos++;
        $i |= 255;
    }
    printf OUTPUT "const BYTE idx1_fullcomp[%d] =\n", $fullcomp_lim;
    print OUTPUT "{\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%02x", 0, @fullcomp_filled );
    print OUTPUT "\n};\n\n";

    my $sub_fullcomp_filled_pos = 1;
    my %sub_fullcomp_filled = ();
    for (my $i = 0; $i < $fullcomp_lim; $i++)
    {
        next unless $fullcomp_filled[$i];
        for (my $j = 0; $j < 256; $j++)
        {
            my $idx = ($i << 8) | $j;
            next unless defined $full_comp_table[$idx];
            $sub_fullcomp_filled{$idx >> 4} = $sub_fullcomp_filled_pos++;
            $j |= 15;
        }
    }

    printf OUTPUT "const USHORT idx2_fullcomp[%d] =\n", $fullcomp_pos * 16;
    print OUTPUT "{\n";
    @null_idx = (0) x 16;
    print OUTPUT "    /* all-zero 256-char blocks get mapped to here */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @null_idx );
    for (my $i = 0; $i < $fullcomp_lim; $i++)
    {
        next unless $fullcomp_filled[$i];
        printf OUTPUT ",\n    /* sub-index 0x%02x */\n", $fullcomp_filled[$i];

        my @sub_idx;
        for (my $j = 0; $j < 16; $j++)
        {
            my $idx = ($i << 4) | $j;
            $sub_idx[$j] = $sub_fullcomp_filled{$idx} || 0;
        }
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @sub_idx );
    }
    print OUTPUT "\n};\n\n";

    printf OUTPUT "const USHORT offsets_fullcomp[%d] =\n", 16 * $sub_fullcomp_filled_pos;
    print OUTPUT "{\n";
    @null_table = (0) x 16;
    print OUTPUT "    /* all-zero 16-char blocks get mapped to here */\n";
    printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @null_table );
    for my $key (sort {$a <=> $b} keys %sub_fullcomp_filled)
    {
        printf OUTPUT ",\n    /* 0x%03x0 .. 0x%03xf */\n", $key, $key;
        my @sub_table;
        for (my $j = 0; $j < 16; $j++)
        {
            my $idx = ($key << 4) | $j;
            $sub_table[$j] = $fullcomp_lookup{$idx} || 0;
        }
        printf OUTPUT "%s", DUMP_ARRAY( "0x%04x", 0, @sub_table );
    }
    print OUTPUT "\n};\n\n";

    print OUTPUT <<"EOF";
static const WCHAR *unicode_table_lookup( UINT cp, int compat, const BYTE *idx1, UINT scale_idx1,
                                          const USHORT *idx2, UINT scale_idx2, const USHORT *offsets,
                                          UINT scale_off, const WCHAR *data, UINT scale_data )
{
    USHORT a, b, c, d;

    a = idx1[cp >> scale_idx1];
    b = idx2[(a << scale_idx2) + ((cp >> scale_idx2) & 0xf)];
    c = (b << scale_off) + ((cp & 0xf) << scale_data);
    if (compat) ++c;
    d = offsets[c];

    return &data[d];
}

static inline int reorderable_pair( WCHAR ch1, WCHAR ch2 )
{
    const WCHAR *cc1, *cc2;

    if (ch1 == 0 || ch2 == 0) return 0;

    cc1 = unicode_table_lookup( ch1, 0, idx1_comb, 8, idx2_comb, 4,
                                offsets_comb, 4, data_comb, 0 );
    cc2 = unicode_table_lookup( ch2, 0, idx1_comb, 8, idx2_comb, 4,
                                offsets_comb, 4, data_comb, 0 );
    if (*cc2 < *cc1) return 1;
    else return 0;
}

static int decompose_char_recursive( int compat, UINT ch, WCHAR *dst, int dstlen )
{
    int total_decomp = 0;
    int size_decomp;
    const WCHAR *map;

    if (ch < 0xa0) /* fast path */
    {
        if (dstlen) *dst = (WCHAR)ch;
        return 1;
    }
    else if (ch > last_decomposable ||
             !*(map = unicode_table_lookup( ch, compat, idx1_decomp, 8,
                idx2_decomp, 4, offsets_decomp, 5, data_decomp, 1 )))
    {
        if (dstlen) *dst = (WCHAR)ch;
        return 1;
    }
    else {
        while (*map)
        {
            size_decomp = decompose_char_recursive( compat, *map, dst, dstlen );
            dstlen -= size_decomp;
            if (dstlen < 0) dstlen = 0;
            dst += size_decomp;
            map++;
            total_decomp += size_decomp;
        }
        return total_decomp;
    }
}

int wine_unicode_decompose_string( int compat, const WCHAR *src,
                                   int srclen, WCHAR *dst, int dstlen )
{
    UINT ch;
    int srcpos = 0, dstpos = 0;
    int decomp_len;

    if (dstlen < 0) dstlen = 0;

    while (srcpos < srclen)
    {
        ch = src[srcpos];

        decomp_len = decompose_char_recursive( compat, ch, dst+dstpos, dstlen );
        dstpos += decomp_len;

        if (dstlen > 0)
        {
            dstlen -= decomp_len;
            while (dstlen < 0)
            {
                dstpos--;
                dstlen++;
            }
        }

        ++srcpos;
    }

    return dstpos;
}

int is_starter( WCHAR ch )
{
    const WCHAR *map = unicode_table_lookup( ch, 0, idx1_comb, 8, idx2_comb, 4,
                                             offsets_comb, 4, data_comb, 0 );
    return (*map == 0) ? 1 : 0;
}

void unicode_canon_order( WCHAR *str, int strlen )
{
    int i, j, m;
    int sublen = 0, tot_sublen = 0;
    WCHAR *substr = str;

    for (m = 1; m <= strlen; m++)
    {
        if (m == strlen || is_starter( str[m] )) sublen = m - tot_sublen;
        else continue;

        for (i = 0; i < sublen; i++)
        {
            for (j = 1; j < sublen; j++)
            {
                if (reorderable_pair( substr[j-1], substr[j] ))
                {
                    WCHAR swp = substr[j-1];
                    substr[j-1] = substr[j];
                    substr[j] = swp;
                }
            }
        }
        tot_sublen += m;
        substr = str+m;
    }
}
EOF
    close OUTPUT;
    save_file($filename);
}

################################################################
# output a codepage definition file from the global tables
sub output_codepage_file($$$$)
{
    my ($codepage, $filename, $comment, $has_glyphs) = @_;

    my $output = sprintf "libs/port/c_%03d.c", $codepage;
    open OUTPUT,">$output.new" or die "Cannot create $output";

    printf "Building %s from %s (%s)\n", $output, $filename || "hardcoded data", $comment;

    # dump all tables

    printf OUTPUT "/* code page %03d (%s) */\n", $codepage, $comment;
    if ($filename)
    {
        print OUTPUT "/* generated from $MAPPINGS/$filename */\n";
        print OUTPUT "/* DO NOT EDIT!! */\n\n";
    }
    else
    {
        printf OUTPUT "/* Automatically generated; DO NOT EDIT!! */\n\n";
    }
    printf OUTPUT "#include \"wine/unicode.h\"\n\n";

    if (!@lead_bytes) { dump_sbcs_table( $codepage, $has_glyphs, $comment, $default_char, $default_wchar ); }
    else { dump_dbcs_table( $codepage, $comment, $default_char, $default_wchar, get_lb_ranges() ); }
    close OUTPUT;
    save_file($output);
}

################################################################
# read a "bestfit" Windows mapping file
sub read_bestfit_file($)
{
    my ($filename) = @_;
    my $state = "";
    my ($codepage, $width, $count);
    my ($lb_cur, $lb_end);

    my $INPUT = open_data_file( $MAPPINGS, $filename ) or die "Cannot open $filename";

    while (<$INPUT>)
    {
        next if /^;/;  # skip comments
        next if /^\s*$/;  # skip empty lines
        next if /\x1a/;  # skip ^Z
        last if /^ENDCODEPAGE/;

        if (/^CODEPAGE\s+(\d+)/)
        {
            $codepage = $1;
            next;
        }
        if (/^CPINFO\s+(\d+)\s+0x([0-9a-fA-f]+)\s+0x([0-9a-fA-F]+)/)
        {
            $width = $1;
            $default_char = hex $2;
            $default_wchar = hex $3;
            next;
        }
        if (/^(MBTABLE|WCTABLE|DBCSRANGE|DBCSTABLE)\s+(\d+)/)
        {
            $state = $1;
            $count = $2;
            next;
        }
        if (/^0x([0-9a-fA-F]+)\s+0x([0-9a-fA-F]+)/)
        {
            if ($state eq "MBTABLE")
            {
                my $cp = hex $1;
                my $uni = hex $2;
                $cp2uni[$cp] = $uni unless defined($cp2uni[$cp]);
                next;
            }
            if ($state eq "WCTABLE")
            {
                my $uni = hex $1;
                my $cp = hex $2;
                $uni2cp[$uni] = $cp unless defined($uni2cp[$uni]);
                next;
            }
            if ($state eq "DBCSRANGE")
            {
                my $start = hex $1;
                my $end = hex $2;
                for (my $i = $start; $i <= $end; $i++) { add_lead_byte( $i ); }
                $lb_cur = $start;
                $lb_end = $end;
                next;
            }
            if ($state eq "DBCSTABLE")
            {
                my $mb = hex $1;
                my $uni = hex $2;
                my $cp = ($lb_cur << 8) | $mb;
                $cp2uni[$cp] = $uni unless defined($cp2uni[$cp]);
                if (!--$count)
                {
                    if (++$lb_cur > $lb_end) { $state = "DBCSRANGE"; }
                }
                next;
            }
        }
        die "$filename: Unrecognized line $_\n";
    }
    close $INPUT;
}


################################################################
# read an input file and generate the corresponding .c file
sub HANDLE_FILE(@)
{
    my ($codepage,$filename,$has_glyphs,$comment,$first_private,$def,$defw) = @_;

    @cp2uni = ();
    @lead_bytes = ();
    @uni2cp = ();
    $default_char = $def || $DEF_CHAR;
    $default_wchar = $defw || $DEF_CHAR;

    # some codepage files are special
    if ($codepage == 20932)
    {
        READ_JIS0208_FILE( $filename );
        add_default_mappings( $first_private );
    }
    elsif ($codepage == 20127)
    {
        fill_20127_codepage();
        add_default_mappings( $first_private );
    }
    elsif ($filename =~ /\/bestfit/)
    {
        read_bestfit_file( $filename );
    }
    else
    {
        read_codepage_file( $filename );
        if ($codepage == 10001)
        {
            # add Shift-JIS mappings
            read_bestfit_file( "VENDORS/MICSFT/WindowsBestFit/bestfit932.txt" );
        }
        else
        {
            add_default_mappings( $first_private );
        }
    }

    output_codepage_file( $codepage, $filename, $comment, $has_glyphs );
}


################################################################
# save a file if modified
sub save_file($)
{
    my $file = shift;
    if (-f $file && !system "cmp $file $file.new >/dev/null")
    {
        unlink "$file.new";
    }
    else
    {
        rename "$file.new", "$file";
    }
}


################################################################
# output the list of codepage tables into the cptable.c file
sub output_cptable($)
{
    my $output = shift;
    my @tables_decl = ();

    printf "Building %s\n", $output;

    foreach my $file (@allfiles)
    {
        my ($codepage,$filename) = @$file;
        push @tables_decl, sprintf("extern union cptable cptable_%03d;\n",$codepage);
    }

    push @tables_decl, sprintf("\nstatic const union cptable * const cptables[%d] =\n{\n",$#allfiles+1);
    foreach my $file (@allfiles)
    {
        my ($codepage,$filename) = @$file;
        push @tables_decl, sprintf("    &cptable_%03d,\n", $codepage);
    }
    push @tables_decl, "};";
    REPLACE_IN_FILE( $output, @tables_decl );
}

################################################################
# replace the contents of a file between ### cpmap ### marks

sub REPLACE_IN_FILE($@)
{
    my $name = shift;
    my @data = @_;
    my @lines = ();
    open(FILE,$name) or die "Can't open $name";
    while (<FILE>)
    {
	push @lines, $_;
	last if /\#\#\# cpmap begin \#\#\#/;
    }
    push @lines, @data;
    while (<FILE>)
    {
	if (/\#\#\# cpmap end \#\#\#/) { push @lines, "\n", $_; last; }
    }
    push @lines, <FILE>;
    open(FILE,">$name.new") or die "Can't modify $name";
    print FILE @lines;
    close(FILE);
    save_file($name);
}

################################################################
# main routine

chdir ".." if -f "./make_unicode";
READ_DEFAULTS( $DEFAULTS );
DUMP_CASE_MAPPINGS( "libs/wine/casemap.c" );
DUMP_SORTKEYS( "libs/wine/collation.c", READ_SORTKEYS_FILE() );
dump_compose_table( "libs/port/compose.c" );
dump_decompose_table( "libs/port/decompose.c" );
DUMP_CTYPE_TABLES( "libs/wine/wctype.c" );
dump_digit_folding( "libs/port/digitmap.c" );
dump_mirroring( "dlls/usp10/mirror.c" );
dump_mirroring( "dlls/dwrite/mirror.c" );
dump_bracket( "dlls/usp10/bracket.c" );
dump_bracket( "dlls/dwrite/bracket.c" );
dump_shaping( "dlls/usp10/shaping.c" );
dump_linebreak( "dlls/usp10/linebreak.c" );
dump_linebreak( "dlls/dwrite/linebreak.c" );
dump_scripts( "dlls/dwrite/scripts" );
dump_indic( "dlls/usp10/indicsyllable.c" );
dump_intl_nls("loader/l_intl.nls");
dump_vertical( "dlls/gdi32/vertical.c" );
dump_vertical( "dlls/wineps.drv/vertical.c" );
dump_nameprep( "dlls/kernel32/nameprep.c" );

foreach my $file (@allfiles) { HANDLE_FILE( @{$file} ); }

output_cptable("libs/port/cptable.c");

exit 0;

# Local Variables:
# compile-command: "./make_unicode"
# End:
