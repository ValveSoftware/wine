/* Automatically generated from Vulkan vk.xml; DO NOT EDIT!
 *
 * This file is generated from Vulkan vk.xml file covered
 * by the following copyright and permission notice:
 *
 * Copyright 2015-2023 The Khronos Group Inc.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#if 0
#pragma makedep unix
#endif

#include "config.h"

#include <stdlib.h>

#include "vulkan_private.h"

WINE_DEFAULT_DEBUG_CHANNEL(vulkan);

typedef struct VkAcquireNextImageInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
    uint64_t DECLSPEC_ALIGN(8) timeout;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkFence DECLSPEC_ALIGN(8) fence;
    uint32_t deviceMask;
} VkAcquireNextImageInfoKHR32;

typedef struct VkPerformanceConfigurationAcquireInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceConfigurationTypeINTEL type;
} VkPerformanceConfigurationAcquireInfoINTEL32;

typedef struct VkAcquireProfilingLockInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAcquireProfilingLockFlagsKHR flags;
    uint64_t DECLSPEC_ALIGN(8) timeout;
} VkAcquireProfilingLockInfoKHR32;

typedef struct VkCommandBufferAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCommandPool DECLSPEC_ALIGN(8) commandPool;
    VkCommandBufferLevel level;
    uint32_t commandBufferCount;
} VkCommandBufferAllocateInfo32;

typedef struct VkDescriptorSetVariableDescriptorCountAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t descriptorSetCount;
    PTR32 pDescriptorCounts;
} VkDescriptorSetVariableDescriptorCountAllocateInfo32;
typedef VkDescriptorSetVariableDescriptorCountAllocateInfo32 VkDescriptorSetVariableDescriptorCountAllocateInfoEXT32;

typedef struct VkDescriptorSetAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
    uint32_t descriptorSetCount;
    PTR32 pSetLayouts;
} VkDescriptorSetAllocateInfo32;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV32;

typedef struct VkExportMemoryAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExportMemoryAllocateInfo32;
typedef VkExportMemoryAllocateInfo32 VkExportMemoryAllocateInfoKHR32;

typedef struct VkImportMemoryWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
    HANDLE handle;
    LPCWSTR name;
} VkImportMemoryWin32HandleInfoKHR32;

typedef struct VkExportMemoryWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pAttributes;
    DWORD dwAccess;
    LPCWSTR name;
} VkExportMemoryWin32HandleInfoKHR32;

typedef struct VkImportMemoryFdInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
    int fd;
} VkImportMemoryFdInfoKHR32;

typedef struct VkMemoryAllocateFlagsInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryAllocateFlags flags;
    uint32_t deviceMask;
} VkMemoryAllocateFlagsInfo32;
typedef VkMemoryAllocateFlagsInfo32 VkMemoryAllocateFlagsInfoKHR32;

typedef struct VkMemoryDedicatedAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkMemoryDedicatedAllocateInfo32;
typedef VkMemoryDedicatedAllocateInfo32 VkMemoryDedicatedAllocateInfoKHR32;

typedef struct VkImportMemoryHostPointerInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
    PTR32 pHostPointer;
} VkImportMemoryHostPointerInfoEXT32;

typedef struct VkMemoryPriorityAllocateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float priority;
} VkMemoryPriorityAllocateInfoEXT32;

typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) opaqueCaptureAddress;
} VkMemoryOpaqueCaptureAddressAllocateInfo32;
typedef VkMemoryOpaqueCaptureAddressAllocateInfo32 VkMemoryOpaqueCaptureAddressAllocateInfoKHR32;

typedef struct VkMemoryAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) allocationSize;
    uint32_t memoryTypeIndex;
} VkMemoryAllocateInfo32;

typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 conditionalRenderingEnable;
} VkCommandBufferInheritanceConditionalRenderingInfoEXT32;

typedef struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceTransformFlagBitsKHR transform;
    VkRect2D renderArea;
} VkCommandBufferInheritanceRenderPassTransformInfoQCOM32;

typedef struct VkCommandBufferInheritanceViewportScissorInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 viewportScissor2D;
    uint32_t viewportDepthCount;
    PTR32 pViewportDepths;
} VkCommandBufferInheritanceViewportScissorInfoNV32;

typedef struct VkCommandBufferInheritanceRenderingInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderingFlags flags;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentFormats;
    VkFormat depthAttachmentFormat;
    VkFormat stencilAttachmentFormat;
    VkSampleCountFlagBits rasterizationSamples;
} VkCommandBufferInheritanceRenderingInfo32;
typedef VkCommandBufferInheritanceRenderingInfo32 VkCommandBufferInheritanceRenderingInfoKHR32;

typedef struct VkAttachmentSampleCountInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentSamples;
    VkSampleCountFlagBits depthStencilAttachmentSamples;
} VkAttachmentSampleCountInfoAMD32;
typedef VkAttachmentSampleCountInfoAMD32 VkAttachmentSampleCountInfoNV32;

typedef struct VkMultiviewPerViewAttributesInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 perViewAttributes;
    VkBool32 perViewAttributesPositionXOnly;
} VkMultiviewPerViewAttributesInfoNVX32;

typedef struct VkCommandBufferInheritanceInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t subpass;
    VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
    VkBool32 occlusionQueryEnable;
    VkQueryControlFlags queryFlags;
    VkQueryPipelineStatisticFlags pipelineStatistics;
} VkCommandBufferInheritanceInfo32;

typedef struct VkDeviceGroupCommandBufferBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceMask;
} VkDeviceGroupCommandBufferBeginInfo32;
typedef VkDeviceGroupCommandBufferBeginInfo32 VkDeviceGroupCommandBufferBeginInfoKHR32;

typedef struct VkCommandBufferBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCommandBufferUsageFlags flags;
    PTR32 pInheritanceInfo;
} VkCommandBufferBeginInfo32;

typedef struct VkBindAccelerationStructureMemoryInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    uint32_t deviceIndexCount;
    PTR32 pDeviceIndices;
} VkBindAccelerationStructureMemoryInfoNV32;

typedef struct VkBindBufferMemoryDeviceGroupInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceIndexCount;
    PTR32 pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfo32;
typedef VkBindBufferMemoryDeviceGroupInfo32 VkBindBufferMemoryDeviceGroupInfoKHR32;

typedef struct VkBindBufferMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
} VkBindBufferMemoryInfo32;
typedef VkBindBufferMemoryInfo32 VkBindBufferMemoryInfoKHR32;

typedef struct VkBindImageMemoryDeviceGroupInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceIndexCount;
    PTR32 pDeviceIndices;
    uint32_t splitInstanceBindRegionCount;
    PTR32 pSplitInstanceBindRegions;
} VkBindImageMemoryDeviceGroupInfo32;
typedef VkBindImageMemoryDeviceGroupInfo32 VkBindImageMemoryDeviceGroupInfoKHR32;

typedef struct VkBindImageMemorySwapchainInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
    uint32_t imageIndex;
} VkBindImageMemorySwapchainInfoKHR32;

typedef struct VkBindImagePlaneMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageAspectFlagBits planeAspect;
} VkBindImagePlaneMemoryInfo32;
typedef VkBindImagePlaneMemoryInfo32 VkBindImagePlaneMemoryInfoKHR32;

typedef struct VkBindImageMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
} VkBindImageMemoryInfo32;
typedef VkBindImageMemoryInfo32 VkBindImageMemoryInfoKHR32;

typedef struct VkAccelerationStructureGeometryMotionTrianglesDataNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) vertexData;
} VkAccelerationStructureGeometryMotionTrianglesDataNV32;

typedef struct VkAccelerationStructureTrianglesOpacityMicromapEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndexType indexType;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) indexBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) indexStride;
    uint32_t baseTriangle;
    uint32_t usageCountsCount;
    PTR32 pUsageCounts;
    PTR32 ppUsageCounts;
    VkMicromapEXT DECLSPEC_ALIGN(8) micromap;
} VkAccelerationStructureTrianglesOpacityMicromapEXT32;

typedef struct VkAccelerationStructureGeometryTrianglesDataKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat vertexFormat;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) vertexData;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexStride;
    uint32_t maxVertex;
    VkIndexType indexType;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) indexData;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) transformData;
} VkAccelerationStructureGeometryTrianglesDataKHR32;

typedef struct VkAccelerationStructureGeometryAabbsDataKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) data;
    VkDeviceSize DECLSPEC_ALIGN(8) stride;
} VkAccelerationStructureGeometryAabbsDataKHR32;

typedef struct VkAccelerationStructureGeometryInstancesDataKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 arrayOfPointers;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) data;
} VkAccelerationStructureGeometryInstancesDataKHR32;

typedef union VkAccelerationStructureGeometryDataKHR32
{
    VkAccelerationStructureGeometryTrianglesDataKHR32 DECLSPEC_ALIGN(8) triangles;
    VkAccelerationStructureGeometryAabbsDataKHR32 DECLSPEC_ALIGN(8) aabbs;
    VkAccelerationStructureGeometryInstancesDataKHR32 DECLSPEC_ALIGN(8) instances;
} VkAccelerationStructureGeometryDataKHR32;

typedef struct VkAccelerationStructureGeometryKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkGeometryTypeKHR geometryType;
    VkAccelerationStructureGeometryDataKHR32 DECLSPEC_ALIGN(8) geometry;
    VkGeometryFlagsKHR flags;
} VkAccelerationStructureGeometryKHR32;

typedef struct VkAccelerationStructureBuildGeometryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureTypeKHR type;
    VkBuildAccelerationStructureFlagsKHR flags;
    VkBuildAccelerationStructureModeKHR mode;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) srcAccelerationStructure;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) dstAccelerationStructure;
    uint32_t geometryCount;
    PTR32 pGeometries;
    PTR32 ppGeometries;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) scratchData;
} VkAccelerationStructureBuildGeometryInfoKHR32;

typedef struct VkMicromapBuildInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapTypeEXT type;
    VkBuildMicromapFlagsEXT flags;
    VkBuildMicromapModeEXT mode;
    VkMicromapEXT DECLSPEC_ALIGN(8) dstMicromap;
    uint32_t usageCountsCount;
    PTR32 pUsageCounts;
    PTR32 ppUsageCounts;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) data;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) scratchData;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) triangleArray;
    VkDeviceSize DECLSPEC_ALIGN(8) triangleArrayStride;
} VkMicromapBuildInfoEXT32;

typedef struct VkConditionalRenderingBeginInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkConditionalRenderingFlagsEXT flags;
} VkConditionalRenderingBeginInfoEXT32;

typedef struct VkDebugUtilsLabelEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pLabelName;
    float color[4];
} VkDebugUtilsLabelEXT32;

typedef struct VkSampleLocationsInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlagBits sampleLocationsPerPixel;
    VkExtent2D sampleLocationGridSize;
    uint32_t sampleLocationsCount;
    PTR32 pSampleLocations;
} VkSampleLocationsInfoEXT32;

typedef struct VkAttachmentSampleLocationsEXT32
{
    uint32_t attachmentIndex;
    VkSampleLocationsInfoEXT32 sampleLocationsInfo;
} VkAttachmentSampleLocationsEXT32;

typedef struct VkSubpassSampleLocationsEXT32
{
    uint32_t subpassIndex;
    VkSampleLocationsInfoEXT32 sampleLocationsInfo;
} VkSubpassSampleLocationsEXT32;

typedef struct VkDeviceGroupRenderPassBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceMask;
    uint32_t deviceRenderAreaCount;
    PTR32 pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfo32;
typedef VkDeviceGroupRenderPassBeginInfo32 VkDeviceGroupRenderPassBeginInfoKHR32;

typedef struct VkRenderPassSampleLocationsBeginInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentInitialSampleLocationsCount;
    PTR32 pAttachmentInitialSampleLocations;
    uint32_t postSubpassSampleLocationsCount;
    PTR32 pPostSubpassSampleLocations;
} VkRenderPassSampleLocationsBeginInfoEXT32;

typedef struct VkRenderPassAttachmentBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentCount;
    PTR32 pAttachments;
} VkRenderPassAttachmentBeginInfo32;
typedef VkRenderPassAttachmentBeginInfo32 VkRenderPassAttachmentBeginInfoKHR32;

typedef struct VkRenderPassTransformBeginInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceTransformFlagBitsKHR transform;
} VkRenderPassTransformBeginInfoQCOM32;

typedef struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t perViewRenderAreaCount;
    PTR32 pPerViewRenderAreas;
} VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32;

typedef struct VkRenderPassBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
    VkRect2D renderArea;
    uint32_t clearValueCount;
    PTR32 pClearValues;
} VkRenderPassBeginInfo32;

typedef struct VkSubpassBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubpassContents contents;
} VkSubpassBeginInfo32;
typedef VkSubpassBeginInfo32 VkSubpassBeginInfoKHR32;

typedef struct VkRenderingAttachmentInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
    VkResolveModeFlagBits resolveMode;
    VkImageView DECLSPEC_ALIGN(8) resolveImageView;
    VkImageLayout resolveImageLayout;
    VkAttachmentLoadOp loadOp;
    VkAttachmentStoreOp storeOp;
    VkClearValue clearValue;
} VkRenderingAttachmentInfo32;
typedef VkRenderingAttachmentInfo32 VkRenderingAttachmentInfoKHR32;

typedef struct VkMultisampledRenderToSingleSampledInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multisampledRenderToSingleSampledEnable;
    VkSampleCountFlagBits rasterizationSamples;
} VkMultisampledRenderToSingleSampledInfoEXT32;

typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
    VkExtent2D shadingRateAttachmentTexelSize;
} VkRenderingFragmentShadingRateAttachmentInfoKHR32;

typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
} VkRenderingFragmentDensityMapAttachmentInfoEXT32;

typedef struct VkRenderingInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderingFlags flags;
    VkRect2D renderArea;
    uint32_t layerCount;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachments;
    PTR32 pDepthAttachment;
    PTR32 pStencilAttachment;
} VkRenderingInfo32;
typedef VkRenderingInfo32 VkRenderingInfoKHR32;

typedef struct VkBufferUsageFlags2CreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferUsageFlags2KHR DECLSPEC_ALIGN(8) usage;
} VkBufferUsageFlags2CreateInfoKHR32;

typedef struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32;

typedef struct VkDescriptorBufferBindingInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) address;
    VkBufferUsageFlags usage;
} VkDescriptorBufferBindingInfoEXT32;

typedef struct VkCopyCommandTransformInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceTransformFlagBitsKHR transform;
} VkCopyCommandTransformInfoQCOM32;

typedef struct VkImageBlit232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresourceLayers srcSubresource;
    VkOffset3D srcOffsets[2];
    VkImageSubresourceLayers dstSubresource;
    VkOffset3D dstOffsets[2];
} VkImageBlit232;
typedef VkImageBlit232 VkImageBlit2KHR32;

typedef struct VkBlitImageCubicWeightsInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCubicFilterWeightsQCOM cubicWeights;
} VkBlitImageCubicWeightsInfoQCOM32;

typedef struct VkBlitImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
    VkFilter filter;
} VkBlitImageInfo232;
typedef VkBlitImageInfo232 VkBlitImageInfo2KHR32;

typedef struct VkGeometryTrianglesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) vertexData;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexOffset;
    uint32_t vertexCount;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexStride;
    VkFormat vertexFormat;
    VkBuffer DECLSPEC_ALIGN(8) indexData;
    VkDeviceSize DECLSPEC_ALIGN(8) indexOffset;
    uint32_t indexCount;
    VkIndexType indexType;
    VkBuffer DECLSPEC_ALIGN(8) transformData;
    VkDeviceSize DECLSPEC_ALIGN(8) transformOffset;
} VkGeometryTrianglesNV32;

typedef struct VkGeometryAABBNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) aabbData;
    uint32_t numAABBs;
    uint32_t stride;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
} VkGeometryAABBNV32;

typedef struct VkGeometryDataNV32
{
    VkGeometryTrianglesNV32 DECLSPEC_ALIGN(8) triangles;
    VkGeometryAABBNV32 DECLSPEC_ALIGN(8) aabbs;
} VkGeometryDataNV32;

typedef struct VkGeometryNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkGeometryTypeKHR geometryType;
    VkGeometryDataNV32 DECLSPEC_ALIGN(8) geometry;
    VkGeometryFlagsKHR flags;
} VkGeometryNV32;

typedef struct VkAccelerationStructureInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureTypeNV type;
    VkBuildAccelerationStructureFlagsNV flags;
    uint32_t instanceCount;
    uint32_t geometryCount;
    PTR32 pGeometries;
} VkAccelerationStructureInfoNV32;

typedef struct VkCopyAccelerationStructureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) src;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) dst;
    VkCopyAccelerationStructureModeKHR mode;
} VkCopyAccelerationStructureInfoKHR32;

typedef struct VkCopyAccelerationStructureToMemoryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) src;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) dst;
    VkCopyAccelerationStructureModeKHR mode;
} VkCopyAccelerationStructureToMemoryInfoKHR32;

typedef struct VkBufferCopy32
{
    VkDeviceSize DECLSPEC_ALIGN(8) srcOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferCopy32;

typedef struct VkBufferCopy232
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) srcOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferCopy232;
typedef VkBufferCopy232 VkBufferCopy2KHR32;

typedef struct VkCopyBufferInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
    VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyBufferInfo232;
typedef VkCopyBufferInfo232 VkCopyBufferInfo2KHR32;

typedef struct VkBufferImageCopy32
{
    VkDeviceSize DECLSPEC_ALIGN(8) bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkBufferImageCopy32;

typedef struct VkBufferImageCopy232
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkBufferImageCopy232;
typedef VkBufferImageCopy232 VkBufferImageCopy2KHR32;

typedef struct VkCopyBufferToImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyBufferToImageInfo232;
typedef VkCopyBufferToImageInfo232 VkCopyBufferToImageInfo2KHR32;

typedef struct VkImageCopy232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresourceLayers srcSubresource;
    VkOffset3D srcOffset;
    VkImageSubresourceLayers dstSubresource;
    VkOffset3D dstOffset;
    VkExtent3D extent;
} VkImageCopy232;
typedef VkImageCopy232 VkImageCopy2KHR32;

typedef struct VkCopyImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageInfo232;
typedef VkCopyImageInfo232 VkCopyImageInfo2KHR32;

typedef struct VkCopyImageToBufferInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageToBufferInfo232;
typedef VkCopyImageToBufferInfo232 VkCopyImageToBufferInfo2KHR32;

typedef struct VkCopyMemoryToAccelerationStructureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) src;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) dst;
    VkCopyAccelerationStructureModeKHR mode;
} VkCopyMemoryToAccelerationStructureInfoKHR32;

typedef struct VkCopyMemoryToMicromapInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) src;
    VkMicromapEXT DECLSPEC_ALIGN(8) dst;
    VkCopyMicromapModeEXT mode;
} VkCopyMemoryToMicromapInfoEXT32;

typedef struct VkCopyMicromapInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapEXT DECLSPEC_ALIGN(8) src;
    VkMicromapEXT DECLSPEC_ALIGN(8) dst;
    VkCopyMicromapModeEXT mode;
} VkCopyMicromapInfoEXT32;

typedef struct VkCopyMicromapToMemoryInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapEXT DECLSPEC_ALIGN(8) src;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) dst;
    VkCopyMicromapModeEXT mode;
} VkCopyMicromapToMemoryInfoEXT32;

typedef struct VkCuLaunchInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCuFunctionNVX DECLSPEC_ALIGN(8) function;
    uint32_t gridDimX;
    uint32_t gridDimY;
    uint32_t gridDimZ;
    uint32_t blockDimX;
    uint32_t blockDimY;
    uint32_t blockDimZ;
    uint32_t sharedMemBytes;
    PTR32 paramCount;
    PTR32 pParams;
    PTR32 extraCount;
    PTR32 pExtras;
} VkCuLaunchInfoNVX32;

typedef struct VkDebugMarkerMarkerInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pMarkerName;
    float color[4];
} VkDebugMarkerMarkerInfoEXT32;

typedef struct VkDecompressMemoryRegionNV32
{
    VkDeviceAddress DECLSPEC_ALIGN(8) srcAddress;
    VkDeviceAddress DECLSPEC_ALIGN(8) dstAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) compressedSize;
    VkDeviceSize DECLSPEC_ALIGN(8) decompressedSize;
    VkMemoryDecompressionMethodFlagsNV DECLSPEC_ALIGN(8) decompressionMethod;
} VkDecompressMemoryRegionNV32;

typedef struct VkSubpassFragmentDensityMapOffsetEndInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t fragmentDensityOffsetCount;
    PTR32 pFragmentDensityOffsets;
} VkSubpassFragmentDensityMapOffsetEndInfoQCOM32;

typedef struct VkSubpassEndInfo32
{
    VkStructureType sType;
    PTR32 pNext;
} VkSubpassEndInfo32;
typedef VkSubpassEndInfo32 VkSubpassEndInfoKHR32;

typedef struct VkIndirectCommandsStreamNV32
{
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
} VkIndirectCommandsStreamNV32;

typedef struct VkGeneratedCommandsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    VkIndirectCommandsLayoutNV DECLSPEC_ALIGN(8) indirectCommandsLayout;
    uint32_t streamCount;
    PTR32 pStreams;
    uint32_t sequencesCount;
    VkBuffer DECLSPEC_ALIGN(8) preprocessBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) preprocessOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) preprocessSize;
    VkBuffer DECLSPEC_ALIGN(8) sequencesCountBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) sequencesCountOffset;
    VkBuffer DECLSPEC_ALIGN(8) sequencesIndexBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) sequencesIndexOffset;
} VkGeneratedCommandsInfoNV32;

typedef struct VkOpticalFlowExecuteInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOpticalFlowExecuteFlagsNV flags;
    uint32_t regionCount;
    PTR32 pRegions;
} VkOpticalFlowExecuteInfoNV32;

typedef struct VkMemoryBarrier32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
} VkMemoryBarrier32;

typedef struct VkExternalMemoryAcquireUnmodifiedEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 acquireUnmodifiedMemory;
} VkExternalMemoryAcquireUnmodifiedEXT32;

typedef struct VkBufferMemoryBarrier32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferMemoryBarrier32;

typedef struct VkImageMemoryBarrier32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
    VkImageLayout oldLayout;
    VkImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageSubresourceRange subresourceRange;
} VkImageMemoryBarrier32;

typedef struct VkMemoryBarrier232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
} VkMemoryBarrier232;
typedef VkMemoryBarrier232 VkMemoryBarrier2KHR32;

typedef struct VkBufferMemoryBarrier232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferMemoryBarrier232;
typedef VkBufferMemoryBarrier232 VkBufferMemoryBarrier2KHR32;

typedef struct VkImageMemoryBarrier232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
    VkImageLayout oldLayout;
    VkImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageSubresourceRange subresourceRange;
} VkImageMemoryBarrier232;
typedef VkImageMemoryBarrier232 VkImageMemoryBarrier2KHR32;

typedef struct VkDependencyInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDependencyFlags dependencyFlags;
    uint32_t memoryBarrierCount;
    PTR32 pMemoryBarriers;
    uint32_t bufferMemoryBarrierCount;
    PTR32 pBufferMemoryBarriers;
    uint32_t imageMemoryBarrierCount;
    PTR32 pImageMemoryBarriers;
} VkDependencyInfo32;
typedef VkDependencyInfo32 VkDependencyInfoKHR32;

typedef struct VkDescriptorImageInfo32
{
    VkSampler DECLSPEC_ALIGN(8) sampler;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
} VkDescriptorImageInfo32;

typedef struct VkDescriptorBufferInfo32
{
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) range;
} VkDescriptorBufferInfo32;

typedef struct VkWriteDescriptorSetInlineUniformBlock32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t dataSize;
    PTR32 pData;
} VkWriteDescriptorSetInlineUniformBlock32;
typedef VkWriteDescriptorSetInlineUniformBlock32 VkWriteDescriptorSetInlineUniformBlockEXT32;

typedef struct VkWriteDescriptorSetAccelerationStructureKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t accelerationStructureCount;
    PTR32 pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureKHR32;

typedef struct VkWriteDescriptorSetAccelerationStructureNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t accelerationStructureCount;
    PTR32 pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureNV32;

typedef struct VkWriteDescriptorSet32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSet DECLSPEC_ALIGN(8) dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    VkDescriptorType descriptorType;
    PTR32 pImageInfo;
    PTR32 pBufferInfo;
    PTR32 pTexelBufferView;
} VkWriteDescriptorSet32;

typedef struct VkImageResolve232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresourceLayers srcSubresource;
    VkOffset3D srcOffset;
    VkImageSubresourceLayers dstSubresource;
    VkOffset3D dstOffset;
    VkExtent3D extent;
} VkImageResolve232;
typedef VkImageResolve232 VkImageResolve2KHR32;

typedef struct VkResolveImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkResolveImageInfo232;
typedef VkResolveImageInfo232 VkResolveImageInfo2KHR32;

typedef struct VkCoarseSampleOrderCustomNV32
{
    VkShadingRatePaletteEntryNV shadingRate;
    uint32_t sampleCount;
    uint32_t sampleLocationCount;
    PTR32 pSampleLocations;
} VkCoarseSampleOrderCustomNV32;

typedef struct VkDepthBiasRepresentationInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDepthBiasRepresentationEXT depthBiasRepresentation;
    VkBool32 depthBiasExact;
} VkDepthBiasRepresentationInfoEXT32;

typedef struct VkDepthBiasInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float depthBiasConstantFactor;
    float depthBiasClamp;
    float depthBiasSlopeFactor;
} VkDepthBiasInfoEXT32;

typedef struct VkPerformanceMarkerInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) marker;
} VkPerformanceMarkerInfoINTEL32;

typedef struct VkPerformanceOverrideInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceOverrideTypeINTEL type;
    VkBool32 enable;
    uint64_t DECLSPEC_ALIGN(8) parameter;
} VkPerformanceOverrideInfoINTEL32;

typedef struct VkPerformanceStreamMarkerInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t marker;
} VkPerformanceStreamMarkerInfoINTEL32;

typedef struct VkVertexInputBindingDescription2EXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t binding;
    uint32_t stride;
    VkVertexInputRate inputRate;
    uint32_t divisor;
} VkVertexInputBindingDescription2EXT32;

typedef struct VkVertexInputAttributeDescription2EXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t location;
    uint32_t binding;
    VkFormat format;
    uint32_t offset;
} VkVertexInputAttributeDescription2EXT32;

typedef struct VkShadingRatePaletteNV32
{
    uint32_t shadingRatePaletteEntryCount;
    PTR32 pShadingRatePaletteEntries;
} VkShadingRatePaletteNV32;

typedef struct VkStridedDeviceAddressRegionKHR32
{
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) stride;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkStridedDeviceAddressRegionKHR32;

typedef struct VkCopyImageToImageInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkHostImageCopyFlagsEXT flags;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageToImageInfoEXT32;

typedef struct VkImageToMemoryCopyEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pHostPointer;
    uint32_t memoryRowLength;
    uint32_t memoryImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkImageToMemoryCopyEXT32;

typedef struct VkCopyImageToMemoryInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkHostImageCopyFlagsEXT flags;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageToMemoryInfoEXT32;

typedef struct VkMemoryToImageCopyEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pHostPointer;
    uint32_t memoryRowLength;
    uint32_t memoryImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkMemoryToImageCopyEXT32;

typedef struct VkCopyMemoryToImageInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkHostImageCopyFlagsEXT flags;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyMemoryToImageInfoEXT32;

typedef struct VkOpaqueCaptureDescriptorDataCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 opaqueCaptureDescriptorData;
} VkOpaqueCaptureDescriptorDataCreateInfoEXT32;

typedef struct VkAccelerationStructureMotionInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxInstances;
    VkAccelerationStructureMotionInfoFlagsNV flags;
} VkAccelerationStructureMotionInfoNV32;

typedef struct VkAccelerationStructureCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureCreateFlagsKHR createFlags;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkAccelerationStructureTypeKHR type;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
} VkAccelerationStructureCreateInfoKHR32;

typedef struct VkAccelerationStructureCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) compactedSize;
    VkAccelerationStructureInfoNV32 info;
} VkAccelerationStructureCreateInfoNV32;

typedef struct VkDedicatedAllocationBufferCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV32;

typedef struct VkExternalMemoryBufferCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExternalMemoryBufferCreateInfo32;
typedef VkExternalMemoryBufferCreateInfo32 VkExternalMemoryBufferCreateInfoKHR32;

typedef struct VkBufferOpaqueCaptureAddressCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) opaqueCaptureAddress;
} VkBufferOpaqueCaptureAddressCreateInfo32;
typedef VkBufferOpaqueCaptureAddressCreateInfo32 VkBufferOpaqueCaptureAddressCreateInfoKHR32;

typedef struct VkBufferDeviceAddressCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
} VkBufferDeviceAddressCreateInfoEXT32;

typedef struct VkBufferCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferCreateFlags flags;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkBufferUsageFlags usage;
    VkSharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
} VkBufferCreateInfo32;

typedef struct VkBufferViewCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferViewCreateFlags flags;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkFormat format;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) range;
} VkBufferViewCreateInfo32;

typedef struct VkCommandPoolCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCommandPoolCreateFlags flags;
    uint32_t queueFamilyIndex;
} VkCommandPoolCreateInfo32;

typedef struct VkPipelineCreationFeedback32
{
    VkPipelineCreationFeedbackFlags flags;
    uint64_t DECLSPEC_ALIGN(8) duration;
} VkPipelineCreationFeedback32;
typedef VkPipelineCreationFeedback32 VkPipelineCreationFeedbackEXT32;

typedef struct VkSpecializationMapEntry32
{
    uint32_t constantID;
    uint32_t offset;
    PTR32 size;
} VkSpecializationMapEntry32;

typedef struct VkSpecializationInfo32
{
    uint32_t mapEntryCount;
    PTR32 pMapEntries;
    PTR32 dataSize;
    PTR32 pData;
} VkSpecializationInfo32;

typedef struct VkShaderModuleCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderModuleCreateFlags flags;
    PTR32 codeSize;
    PTR32 pCode;
} VkShaderModuleCreateInfo32;

typedef struct VkShaderModuleValidationCacheCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkValidationCacheEXT DECLSPEC_ALIGN(8) validationCache;
} VkShaderModuleValidationCacheCreateInfoEXT32;

typedef struct VkDebugUtilsObjectNameInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkObjectType objectType;
    uint64_t DECLSPEC_ALIGN(8) objectHandle;
    PTR32 pObjectName;
} VkDebugUtilsObjectNameInfoEXT32;

typedef struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t requiredSubgroupSize;
} VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32;
typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT32;
typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 VkShaderRequiredSubgroupSizeCreateInfoEXT32;

typedef struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t identifierSize;
    PTR32 pIdentifier;
} VkPipelineShaderStageModuleIdentifierCreateInfoEXT32;

typedef struct VkPipelineRobustnessCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRobustnessBufferBehaviorEXT storageBuffers;
    VkPipelineRobustnessBufferBehaviorEXT uniformBuffers;
    VkPipelineRobustnessBufferBehaviorEXT vertexInputs;
    VkPipelineRobustnessImageBehaviorEXT images;
} VkPipelineRobustnessCreateInfoEXT32;

typedef struct VkPipelineShaderStageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineShaderStageCreateFlags flags;
    VkShaderStageFlagBits stage;
    VkShaderModule DECLSPEC_ALIGN(8) module;
    PTR32 pName;
    PTR32 pSpecializationInfo;
} VkPipelineShaderStageCreateInfo32;

typedef struct VkPipelineCreateFlags2CreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags2KHR DECLSPEC_ALIGN(8) flags;
} VkPipelineCreateFlags2CreateInfoKHR32;

typedef struct VkPipelineCreationFeedbackCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pPipelineCreationFeedback;
    uint32_t pipelineStageCreationFeedbackCount;
    PTR32 pPipelineStageCreationFeedbacks;
} VkPipelineCreationFeedbackCreateInfo32;
typedef VkPipelineCreationFeedbackCreateInfo32 VkPipelineCreationFeedbackCreateInfoEXT32;

typedef struct VkSubpassShadingPipelineCreateInfoHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t subpass;
} VkSubpassShadingPipelineCreateInfoHUAWEI32;

typedef struct VkPipelineCompilerControlCreateInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCompilerControlFlagsAMD compilerControlFlags;
} VkPipelineCompilerControlCreateInfoAMD32;

typedef struct VkComputePipelineCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    VkPipelineShaderStageCreateInfo32 DECLSPEC_ALIGN(8) stage;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkComputePipelineCreateInfo32;

typedef struct VkCuFunctionCreateInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCuModuleNVX DECLSPEC_ALIGN(8) module;
    PTR32 pName;
} VkCuFunctionCreateInfoNVX32;

typedef struct VkCuModuleCreateInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 dataSize;
    PTR32 pData;
} VkCuModuleCreateInfoNVX32;

typedef struct VkDebugReportCallbackCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugReportFlagsEXT flags;
    PFN_vkDebugReportCallbackEXT pfnCallback;
    PTR32 pUserData;
} VkDebugReportCallbackCreateInfoEXT32;

typedef struct VkDebugUtilsMessengerCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugUtilsMessengerCreateFlagsEXT flags;
    VkDebugUtilsMessageSeverityFlagsEXT messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT messageType;
    PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback;
    PTR32 pUserData;
} VkDebugUtilsMessengerCreateInfoEXT32;

typedef struct VkMutableDescriptorTypeListEXT32
{
    uint32_t descriptorTypeCount;
    PTR32 pDescriptorTypes;
} VkMutableDescriptorTypeListEXT32;
typedef VkMutableDescriptorTypeListEXT32 VkMutableDescriptorTypeListVALVE32;

typedef struct VkDescriptorPoolInlineUniformBlockCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxInlineUniformBlockBindings;
} VkDescriptorPoolInlineUniformBlockCreateInfo32;
typedef VkDescriptorPoolInlineUniformBlockCreateInfo32 VkDescriptorPoolInlineUniformBlockCreateInfoEXT32;

typedef struct VkMutableDescriptorTypeCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t mutableDescriptorTypeListCount;
    PTR32 pMutableDescriptorTypeLists;
} VkMutableDescriptorTypeCreateInfoEXT32;
typedef VkMutableDescriptorTypeCreateInfoEXT32 VkMutableDescriptorTypeCreateInfoVALVE32;

typedef struct VkDescriptorPoolCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorPoolCreateFlags flags;
    uint32_t maxSets;
    uint32_t poolSizeCount;
    PTR32 pPoolSizes;
} VkDescriptorPoolCreateInfo32;

typedef struct VkDescriptorSetLayoutBinding32
{
    uint32_t binding;
    VkDescriptorType descriptorType;
    uint32_t descriptorCount;
    VkShaderStageFlags stageFlags;
    PTR32 pImmutableSamplers;
} VkDescriptorSetLayoutBinding32;

typedef struct VkDescriptorSetLayoutBindingFlagsCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t bindingCount;
    PTR32 pBindingFlags;
} VkDescriptorSetLayoutBindingFlagsCreateInfo32;
typedef VkDescriptorSetLayoutBindingFlagsCreateInfo32 VkDescriptorSetLayoutBindingFlagsCreateInfoEXT32;

typedef struct VkDescriptorSetLayoutCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSetLayoutCreateFlags flags;
    uint32_t bindingCount;
    PTR32 pBindings;
} VkDescriptorSetLayoutCreateInfo32;

typedef struct VkDescriptorUpdateTemplateEntry32
{
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    VkDescriptorType descriptorType;
    PTR32 offset;
    PTR32 stride;
} VkDescriptorUpdateTemplateEntry32;
typedef VkDescriptorUpdateTemplateEntry32 VkDescriptorUpdateTemplateEntryKHR32;

typedef struct VkDescriptorUpdateTemplateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorUpdateTemplateCreateFlags flags;
    uint32_t descriptorUpdateEntryCount;
    PTR32 pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType templateType;
    VkDescriptorSetLayout DECLSPEC_ALIGN(8) descriptorSetLayout;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipelineLayout DECLSPEC_ALIGN(8) pipelineLayout;
    uint32_t set;
} VkDescriptorUpdateTemplateCreateInfo32;
typedef VkDescriptorUpdateTemplateCreateInfo32 VkDescriptorUpdateTemplateCreateInfoKHR32;

typedef struct VkDeviceQueueGlobalPriorityCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueueGlobalPriorityKHR globalPriority;
} VkDeviceQueueGlobalPriorityCreateInfoKHR32;
typedef VkDeviceQueueGlobalPriorityCreateInfoKHR32 VkDeviceQueueGlobalPriorityCreateInfoEXT32;

typedef struct VkDeviceQueueCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueCount;
    PTR32 pQueuePriorities;
} VkDeviceQueueCreateInfo32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceGeneratedCommands;
} VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceGeneratedCompute;
    VkBool32 deviceGeneratedComputePipelines;
    VkBool32 deviceGeneratedComputeCaptureReplay;
} VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32;

typedef struct VkDevicePrivateDataCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t privateDataSlotRequestCount;
} VkDevicePrivateDataCreateInfo32;
typedef VkDevicePrivateDataCreateInfo32 VkDevicePrivateDataCreateInfoEXT32;

typedef struct VkPhysicalDevicePrivateDataFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 privateData;
} VkPhysicalDevicePrivateDataFeatures32;
typedef VkPhysicalDevicePrivateDataFeatures32 VkPhysicalDevicePrivateDataFeaturesEXT32;

typedef struct VkPhysicalDeviceFeatures232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceFeatures features;
} VkPhysicalDeviceFeatures232;
typedef VkPhysicalDeviceFeatures232 VkPhysicalDeviceFeatures2KHR32;

typedef struct VkPhysicalDeviceVariablePointersFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 variablePointersStorageBuffer;
    VkBool32 variablePointers;
} VkPhysicalDeviceVariablePointersFeatures32;
typedef VkPhysicalDeviceVariablePointersFeatures32 VkPhysicalDeviceVariablePointersFeaturesKHR32;
typedef VkPhysicalDeviceVariablePointersFeatures32 VkPhysicalDeviceVariablePointerFeaturesKHR32;
typedef VkPhysicalDeviceVariablePointersFeatures32 VkPhysicalDeviceVariablePointerFeatures32;

typedef struct VkPhysicalDeviceMultiviewFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiview;
    VkBool32 multiviewGeometryShader;
    VkBool32 multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeatures32;
typedef VkPhysicalDeviceMultiviewFeatures32 VkPhysicalDeviceMultiviewFeaturesKHR32;

typedef struct VkDeviceGroupDeviceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t physicalDeviceCount;
    PTR32 pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfo32;
typedef VkDeviceGroupDeviceCreateInfo32 VkDeviceGroupDeviceCreateInfoKHR32;

typedef struct VkPhysicalDevicePresentIdFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentId;
} VkPhysicalDevicePresentIdFeaturesKHR32;

typedef struct VkPhysicalDevicePresentWaitFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentWait;
} VkPhysicalDevicePresentWaitFeaturesKHR32;

typedef struct VkPhysicalDevice16BitStorageFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 storageBuffer16BitAccess;
    VkBool32 uniformAndStorageBuffer16BitAccess;
    VkBool32 storagePushConstant16;
    VkBool32 storageInputOutput16;
} VkPhysicalDevice16BitStorageFeatures32;
typedef VkPhysicalDevice16BitStorageFeatures32 VkPhysicalDevice16BitStorageFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupExtendedTypes;
} VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32;
typedef VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR32;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeatures32;
typedef VkPhysicalDeviceSamplerYcbcrConversionFeatures32 VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR32;

typedef struct VkPhysicalDeviceProtectedMemoryFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 protectedMemory;
} VkPhysicalDeviceProtectedMemoryFeatures32;

typedef struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 advancedBlendCoherentOperations;
} VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32;

typedef struct VkPhysicalDeviceMultiDrawFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiDraw;
} VkPhysicalDeviceMultiDrawFeaturesEXT32;

typedef struct VkPhysicalDeviceInlineUniformBlockFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 inlineUniformBlock;
    VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
} VkPhysicalDeviceInlineUniformBlockFeatures32;
typedef VkPhysicalDeviceInlineUniformBlockFeatures32 VkPhysicalDeviceInlineUniformBlockFeaturesEXT32;

typedef struct VkPhysicalDeviceMaintenance4Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance4;
} VkPhysicalDeviceMaintenance4Features32;
typedef VkPhysicalDeviceMaintenance4Features32 VkPhysicalDeviceMaintenance4FeaturesKHR32;

typedef struct VkPhysicalDeviceMaintenance5FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance5;
} VkPhysicalDeviceMaintenance5FeaturesKHR32;

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderDrawParameters;
} VkPhysicalDeviceShaderDrawParametersFeatures32;
typedef VkPhysicalDeviceShaderDrawParametersFeatures32 VkPhysicalDeviceShaderDrawParameterFeatures32;

typedef struct VkPhysicalDeviceShaderFloat16Int8Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderFloat16;
    VkBool32 shaderInt8;
} VkPhysicalDeviceShaderFloat16Int8Features32;
typedef VkPhysicalDeviceShaderFloat16Int8Features32 VkPhysicalDeviceShaderFloat16Int8FeaturesKHR32;
typedef VkPhysicalDeviceShaderFloat16Int8Features32 VkPhysicalDeviceFloat16Int8FeaturesKHR32;

typedef struct VkPhysicalDeviceHostQueryResetFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hostQueryReset;
} VkPhysicalDeviceHostQueryResetFeatures32;
typedef VkPhysicalDeviceHostQueryResetFeatures32 VkPhysicalDeviceHostQueryResetFeaturesEXT32;

typedef struct VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 globalPriorityQuery;
} VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32;
typedef VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32 VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT32;

typedef struct VkPhysicalDeviceDescriptorIndexingFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderInputAttachmentArrayDynamicIndexing;
    VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32 shaderUniformBufferArrayNonUniformIndexing;
    VkBool32 shaderSampledImageArrayNonUniformIndexing;
    VkBool32 shaderStorageBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageImageArrayNonUniformIndexing;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32 descriptorBindingSampledImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingUpdateUnusedWhilePending;
    VkBool32 descriptorBindingPartiallyBound;
    VkBool32 descriptorBindingVariableDescriptorCount;
    VkBool32 runtimeDescriptorArray;
} VkPhysicalDeviceDescriptorIndexingFeatures32;
typedef VkPhysicalDeviceDescriptorIndexingFeatures32 VkPhysicalDeviceDescriptorIndexingFeaturesEXT32;

typedef struct VkPhysicalDeviceTimelineSemaphoreFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 timelineSemaphore;
} VkPhysicalDeviceTimelineSemaphoreFeatures32;
typedef VkPhysicalDeviceTimelineSemaphoreFeatures32 VkPhysicalDeviceTimelineSemaphoreFeaturesKHR32;

typedef struct VkPhysicalDevice8BitStorageFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 storageBuffer8BitAccess;
    VkBool32 uniformAndStorageBuffer8BitAccess;
    VkBool32 storagePushConstant8;
} VkPhysicalDevice8BitStorageFeatures32;
typedef VkPhysicalDevice8BitStorageFeatures32 VkPhysicalDevice8BitStorageFeaturesKHR32;

typedef struct VkPhysicalDeviceConditionalRenderingFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 conditionalRendering;
    VkBool32 inheritedConditionalRendering;
} VkPhysicalDeviceConditionalRenderingFeaturesEXT32;

typedef struct VkPhysicalDeviceVulkanMemoryModelFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vulkanMemoryModel;
    VkBool32 vulkanMemoryModelDeviceScope;
    VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
} VkPhysicalDeviceVulkanMemoryModelFeatures32;
typedef VkPhysicalDeviceVulkanMemoryModelFeatures32 VkPhysicalDeviceVulkanMemoryModelFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderAtomicInt64Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBufferInt64Atomics;
    VkBool32 shaderSharedInt64Atomics;
} VkPhysicalDeviceShaderAtomicInt64Features32;
typedef VkPhysicalDeviceShaderAtomicInt64Features32 VkPhysicalDeviceShaderAtomicInt64FeaturesKHR32;

typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBufferFloat32Atomics;
    VkBool32 shaderBufferFloat32AtomicAdd;
    VkBool32 shaderBufferFloat64Atomics;
    VkBool32 shaderBufferFloat64AtomicAdd;
    VkBool32 shaderSharedFloat32Atomics;
    VkBool32 shaderSharedFloat32AtomicAdd;
    VkBool32 shaderSharedFloat64Atomics;
    VkBool32 shaderSharedFloat64AtomicAdd;
    VkBool32 shaderImageFloat32Atomics;
    VkBool32 shaderImageFloat32AtomicAdd;
    VkBool32 sparseImageFloat32Atomics;
    VkBool32 sparseImageFloat32AtomicAdd;
} VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBufferFloat16Atomics;
    VkBool32 shaderBufferFloat16AtomicAdd;
    VkBool32 shaderBufferFloat16AtomicMinMax;
    VkBool32 shaderBufferFloat32AtomicMinMax;
    VkBool32 shaderBufferFloat64AtomicMinMax;
    VkBool32 shaderSharedFloat16Atomics;
    VkBool32 shaderSharedFloat16AtomicAdd;
    VkBool32 shaderSharedFloat16AtomicMinMax;
    VkBool32 shaderSharedFloat32AtomicMinMax;
    VkBool32 shaderSharedFloat64AtomicMinMax;
    VkBool32 shaderImageFloat32AtomicMinMax;
    VkBool32 sparseImageFloat32AtomicMinMax;
} VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32;

typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vertexAttributeInstanceRateDivisor;
    VkBool32 vertexAttributeInstanceRateZeroDivisor;
} VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32;

typedef struct VkPhysicalDeviceASTCDecodeFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 decodeModeSharedExponent;
} VkPhysicalDeviceASTCDecodeFeaturesEXT32;

typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 transformFeedback;
    VkBool32 geometryStreams;
} VkPhysicalDeviceTransformFeedbackFeaturesEXT32;

typedef struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 representativeFragmentTest;
} VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32;

typedef struct VkPhysicalDeviceExclusiveScissorFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 exclusiveScissor;
} VkPhysicalDeviceExclusiveScissorFeaturesNV32;

typedef struct VkPhysicalDeviceCornerSampledImageFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cornerSampledImage;
} VkPhysicalDeviceCornerSampledImageFeaturesNV32;

typedef struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 computeDerivativeGroupQuads;
    VkBool32 computeDerivativeGroupLinear;
} VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32;

typedef struct VkPhysicalDeviceShaderImageFootprintFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageFootprint;
} VkPhysicalDeviceShaderImageFootprintFeaturesNV32;

typedef struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dedicatedAllocationImageAliasing;
} VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32;

typedef struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 indirectCopy;
} VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32;

typedef struct VkPhysicalDeviceMemoryDecompressionFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 memoryDecompression;
} VkPhysicalDeviceMemoryDecompressionFeaturesNV32;

typedef struct VkPhysicalDeviceShadingRateImageFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shadingRateImage;
    VkBool32 shadingRateCoarseSampleOrder;
} VkPhysicalDeviceShadingRateImageFeaturesNV32;

typedef struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 invocationMask;
} VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceMeshShaderFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 taskShader;
    VkBool32 meshShader;
} VkPhysicalDeviceMeshShaderFeaturesNV32;

typedef struct VkPhysicalDeviceMeshShaderFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 taskShader;
    VkBool32 meshShader;
    VkBool32 multiviewMeshShader;
    VkBool32 primitiveFragmentShadingRateMeshShader;
    VkBool32 meshShaderQueries;
} VkPhysicalDeviceMeshShaderFeaturesEXT32;

typedef struct VkPhysicalDeviceAccelerationStructureFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 accelerationStructure;
    VkBool32 accelerationStructureCaptureReplay;
    VkBool32 accelerationStructureIndirectBuild;
    VkBool32 accelerationStructureHostCommands;
    VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind;
} VkPhysicalDeviceAccelerationStructureFeaturesKHR32;

typedef struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingPipeline;
    VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay;
    VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
    VkBool32 rayTracingPipelineTraceRaysIndirect;
    VkBool32 rayTraversalPrimitiveCulling;
} VkPhysicalDeviceRayTracingPipelineFeaturesKHR32;

typedef struct VkPhysicalDeviceRayQueryFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayQuery;
} VkPhysicalDeviceRayQueryFeaturesKHR32;

typedef struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingMaintenance1;
    VkBool32 rayTracingPipelineTraceRaysIndirect2;
} VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32;

typedef struct VkDeviceMemoryOverallocationCreateInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryOverallocationBehaviorAMD overallocationBehavior;
} VkDeviceMemoryOverallocationCreateInfoAMD32;

typedef struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMap;
    VkBool32 fragmentDensityMapDynamic;
    VkBool32 fragmentDensityMapNonSubsampledImages;
} VkPhysicalDeviceFragmentDensityMapFeaturesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMapDeferred;
} VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMapOffset;
} VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32;

typedef struct VkPhysicalDeviceScalarBlockLayoutFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 scalarBlockLayout;
} VkPhysicalDeviceScalarBlockLayoutFeatures32;
typedef VkPhysicalDeviceScalarBlockLayoutFeatures32 VkPhysicalDeviceScalarBlockLayoutFeaturesEXT32;

typedef struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 uniformBufferStandardLayout;
} VkPhysicalDeviceUniformBufferStandardLayoutFeatures32;
typedef VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR32;

typedef struct VkPhysicalDeviceDepthClipEnableFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClipEnable;
} VkPhysicalDeviceDepthClipEnableFeaturesEXT32;

typedef struct VkPhysicalDeviceMemoryPriorityFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 memoryPriority;
} VkPhysicalDeviceMemoryPriorityFeaturesEXT32;

typedef struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pageableDeviceLocalMemory;
} VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 bufferDeviceAddress;
    VkBool32 bufferDeviceAddressCaptureReplay;
    VkBool32 bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeatures32;
typedef VkPhysicalDeviceBufferDeviceAddressFeatures32 VkPhysicalDeviceBufferDeviceAddressFeaturesKHR32;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 bufferDeviceAddress;
    VkBool32 bufferDeviceAddressCaptureReplay;
    VkBool32 bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32;
typedef VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 VkPhysicalDeviceBufferAddressFeaturesEXT32;

typedef struct VkPhysicalDeviceImagelessFramebufferFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imagelessFramebuffer;
} VkPhysicalDeviceImagelessFramebufferFeatures32;
typedef VkPhysicalDeviceImagelessFramebufferFeatures32 VkPhysicalDeviceImagelessFramebufferFeaturesKHR32;

typedef struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 textureCompressionASTC_HDR;
} VkPhysicalDeviceTextureCompressionASTCHDRFeatures32;
typedef VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT32;

typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cooperativeMatrix;
    VkBool32 cooperativeMatrixRobustBufferAccess;
} VkPhysicalDeviceCooperativeMatrixFeaturesNV32;

typedef struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 ycbcrImageArrays;
} VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32;

typedef struct VkPhysicalDevicePresentBarrierFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentBarrier;
} VkPhysicalDevicePresentBarrierFeaturesNV32;

typedef struct VkPhysicalDevicePerformanceQueryFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 performanceCounterQueryPools;
    VkBool32 performanceCounterMultipleQueryPools;
} VkPhysicalDevicePerformanceQueryFeaturesKHR32;

typedef struct VkPerformanceQueryReservationInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPerformanceQueriesPerPool;
} VkPerformanceQueryReservationInfoKHR32;

typedef struct VkPhysicalDeviceCoverageReductionModeFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 coverageReductionMode;
} VkPhysicalDeviceCoverageReductionModeFeaturesNV32;

typedef struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderIntegerFunctions2;
} VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32;

typedef struct VkPhysicalDeviceShaderClockFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupClock;
    VkBool32 shaderDeviceClock;
} VkPhysicalDeviceShaderClockFeaturesKHR32;

typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 indexTypeUint8;
} VkPhysicalDeviceIndexTypeUint8FeaturesEXT32;

typedef struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSMBuiltins;
} VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32;

typedef struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentShaderSampleInterlock;
    VkBool32 fragmentShaderPixelInterlock;
    VkBool32 fragmentShaderShadingRateInterlock;
} VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32;

typedef struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 separateDepthStencilLayouts;
} VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32;
typedef VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR32;

typedef struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 primitiveTopologyListRestart;
    VkBool32 primitiveTopologyPatchListRestart;
} VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineExecutableInfo;
} VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderDemoteToHelperInvocation;
} VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32;
typedef VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT32;

typedef struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 texelBufferAlignment;
} VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32;

typedef struct VkPhysicalDeviceSubgroupSizeControlFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subgroupSizeControl;
    VkBool32 computeFullSubgroups;
} VkPhysicalDeviceSubgroupSizeControlFeatures32;
typedef VkPhysicalDeviceSubgroupSizeControlFeatures32 VkPhysicalDeviceSubgroupSizeControlFeaturesEXT32;

typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rectangularLines;
    VkBool32 bresenhamLines;
    VkBool32 smoothLines;
    VkBool32 stippledRectangularLines;
    VkBool32 stippledBresenhamLines;
    VkBool32 stippledSmoothLines;
} VkPhysicalDeviceLineRasterizationFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineCreationCacheControlFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineCreationCacheControl;
} VkPhysicalDevicePipelineCreationCacheControlFeatures32;
typedef VkPhysicalDevicePipelineCreationCacheControlFeatures32 VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT32;

typedef struct VkPhysicalDeviceVulkan11Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 storageBuffer16BitAccess;
    VkBool32 uniformAndStorageBuffer16BitAccess;
    VkBool32 storagePushConstant16;
    VkBool32 storageInputOutput16;
    VkBool32 multiview;
    VkBool32 multiviewGeometryShader;
    VkBool32 multiviewTessellationShader;
    VkBool32 variablePointersStorageBuffer;
    VkBool32 variablePointers;
    VkBool32 protectedMemory;
    VkBool32 samplerYcbcrConversion;
    VkBool32 shaderDrawParameters;
} VkPhysicalDeviceVulkan11Features32;

typedef struct VkPhysicalDeviceVulkan12Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 samplerMirrorClampToEdge;
    VkBool32 drawIndirectCount;
    VkBool32 storageBuffer8BitAccess;
    VkBool32 uniformAndStorageBuffer8BitAccess;
    VkBool32 storagePushConstant8;
    VkBool32 shaderBufferInt64Atomics;
    VkBool32 shaderSharedInt64Atomics;
    VkBool32 shaderFloat16;
    VkBool32 shaderInt8;
    VkBool32 descriptorIndexing;
    VkBool32 shaderInputAttachmentArrayDynamicIndexing;
    VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32 shaderUniformBufferArrayNonUniformIndexing;
    VkBool32 shaderSampledImageArrayNonUniformIndexing;
    VkBool32 shaderStorageBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageImageArrayNonUniformIndexing;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32 descriptorBindingSampledImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingUpdateUnusedWhilePending;
    VkBool32 descriptorBindingPartiallyBound;
    VkBool32 descriptorBindingVariableDescriptorCount;
    VkBool32 runtimeDescriptorArray;
    VkBool32 samplerFilterMinmax;
    VkBool32 scalarBlockLayout;
    VkBool32 imagelessFramebuffer;
    VkBool32 uniformBufferStandardLayout;
    VkBool32 shaderSubgroupExtendedTypes;
    VkBool32 separateDepthStencilLayouts;
    VkBool32 hostQueryReset;
    VkBool32 timelineSemaphore;
    VkBool32 bufferDeviceAddress;
    VkBool32 bufferDeviceAddressCaptureReplay;
    VkBool32 bufferDeviceAddressMultiDevice;
    VkBool32 vulkanMemoryModel;
    VkBool32 vulkanMemoryModelDeviceScope;
    VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
    VkBool32 shaderOutputViewportIndex;
    VkBool32 shaderOutputLayer;
    VkBool32 subgroupBroadcastDynamicId;
} VkPhysicalDeviceVulkan12Features32;

typedef struct VkPhysicalDeviceVulkan13Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 robustImageAccess;
    VkBool32 inlineUniformBlock;
    VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
    VkBool32 pipelineCreationCacheControl;
    VkBool32 privateData;
    VkBool32 shaderDemoteToHelperInvocation;
    VkBool32 shaderTerminateInvocation;
    VkBool32 subgroupSizeControl;
    VkBool32 computeFullSubgroups;
    VkBool32 synchronization2;
    VkBool32 textureCompressionASTC_HDR;
    VkBool32 shaderZeroInitializeWorkgroupMemory;
    VkBool32 dynamicRendering;
    VkBool32 shaderIntegerDotProduct;
    VkBool32 maintenance4;
} VkPhysicalDeviceVulkan13Features32;

typedef struct VkPhysicalDeviceCoherentMemoryFeaturesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceCoherentMemory;
} VkPhysicalDeviceCoherentMemoryFeaturesAMD32;

typedef struct VkPhysicalDeviceCustomBorderColorFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 customBorderColors;
    VkBool32 customBorderColorWithoutFormat;
} VkPhysicalDeviceCustomBorderColorFeaturesEXT32;

typedef struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 borderColorSwizzle;
    VkBool32 borderColorSwizzleFromImage;
} VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedDynamicState;
} VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedDynamicState2;
    VkBool32 extendedDynamicState2LogicOp;
    VkBool32 extendedDynamicState2PatchControlPoints;
} VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedDynamicState3TessellationDomainOrigin;
    VkBool32 extendedDynamicState3DepthClampEnable;
    VkBool32 extendedDynamicState3PolygonMode;
    VkBool32 extendedDynamicState3RasterizationSamples;
    VkBool32 extendedDynamicState3SampleMask;
    VkBool32 extendedDynamicState3AlphaToCoverageEnable;
    VkBool32 extendedDynamicState3AlphaToOneEnable;
    VkBool32 extendedDynamicState3LogicOpEnable;
    VkBool32 extendedDynamicState3ColorBlendEnable;
    VkBool32 extendedDynamicState3ColorBlendEquation;
    VkBool32 extendedDynamicState3ColorWriteMask;
    VkBool32 extendedDynamicState3RasterizationStream;
    VkBool32 extendedDynamicState3ConservativeRasterizationMode;
    VkBool32 extendedDynamicState3ExtraPrimitiveOverestimationSize;
    VkBool32 extendedDynamicState3DepthClipEnable;
    VkBool32 extendedDynamicState3SampleLocationsEnable;
    VkBool32 extendedDynamicState3ColorBlendAdvanced;
    VkBool32 extendedDynamicState3ProvokingVertexMode;
    VkBool32 extendedDynamicState3LineRasterizationMode;
    VkBool32 extendedDynamicState3LineStippleEnable;
    VkBool32 extendedDynamicState3DepthClipNegativeOneToOne;
    VkBool32 extendedDynamicState3ViewportWScalingEnable;
    VkBool32 extendedDynamicState3ViewportSwizzle;
    VkBool32 extendedDynamicState3CoverageToColorEnable;
    VkBool32 extendedDynamicState3CoverageToColorLocation;
    VkBool32 extendedDynamicState3CoverageModulationMode;
    VkBool32 extendedDynamicState3CoverageModulationTableEnable;
    VkBool32 extendedDynamicState3CoverageModulationTable;
    VkBool32 extendedDynamicState3CoverageReductionMode;
    VkBool32 extendedDynamicState3RepresentativeFragmentTestEnable;
    VkBool32 extendedDynamicState3ShadingRateImageEnable;
} VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32;

typedef struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 diagnosticsConfig;
} VkPhysicalDeviceDiagnosticsConfigFeaturesNV32;

typedef struct VkDeviceDiagnosticsConfigCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceDiagnosticsConfigFlagsNV flags;
} VkDeviceDiagnosticsConfigCreateInfoNV32;

typedef struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderZeroInitializeWorkgroupMemory;
} VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32;
typedef VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupUniformControlFlow;
} VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32;

typedef struct VkPhysicalDeviceRobustness2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 robustBufferAccess2;
    VkBool32 robustImageAccess2;
    VkBool32 nullDescriptor;
} VkPhysicalDeviceRobustness2FeaturesEXT32;

typedef struct VkPhysicalDeviceImageRobustnessFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 robustImageAccess;
} VkPhysicalDeviceImageRobustnessFeatures32;
typedef VkPhysicalDeviceImageRobustnessFeatures32 VkPhysicalDeviceImageRobustnessFeaturesEXT32;

typedef struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 workgroupMemoryExplicitLayout;
    VkBool32 workgroupMemoryExplicitLayoutScalarBlockLayout;
    VkBool32 workgroupMemoryExplicitLayout8BitAccess;
    VkBool32 workgroupMemoryExplicitLayout16BitAccess;
} VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32;

typedef struct VkPhysicalDevice4444FormatsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 formatA4R4G4B4;
    VkBool32 formatA4B4G4R4;
} VkPhysicalDevice4444FormatsFeaturesEXT32;

typedef struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subpassShading;
} VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 clustercullingShader;
    VkBool32 multiviewClusterCullingShader;
} VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderImageInt64Atomics;
    VkBool32 sparseImageInt64Atomics;
} VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32;

typedef struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineFragmentShadingRate;
    VkBool32 primitiveFragmentShadingRate;
    VkBool32 attachmentFragmentShadingRate;
} VkPhysicalDeviceFragmentShadingRateFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderTerminateInvocationFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderTerminateInvocation;
} VkPhysicalDeviceShaderTerminateInvocationFeatures32;
typedef VkPhysicalDeviceShaderTerminateInvocationFeatures32 VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR32;

typedef struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentShadingRateEnums;
    VkBool32 supersampleFragmentShadingRates;
    VkBool32 noInvocationFragmentShadingRates;
} VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32;

typedef struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 image2DViewOf3D;
    VkBool32 sampler2DViewOf3D;
} VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32;

typedef struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageSlicedViewOf3D;
} VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32;

typedef struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 attachmentFeedbackLoopDynamicState;
} VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32;

typedef struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 mutableDescriptorType;
} VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32;
typedef VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE32;

typedef struct VkPhysicalDeviceDepthClipControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClipControl;
} VkPhysicalDeviceDepthClipControlFeaturesEXT32;

typedef struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vertexInputDynamicState;
} VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32;

typedef struct VkPhysicalDeviceColorWriteEnableFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 colorWriteEnable;
} VkPhysicalDeviceColorWriteEnableFeaturesEXT32;

typedef struct VkPhysicalDeviceSynchronization2Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 synchronization2;
} VkPhysicalDeviceSynchronization2Features32;
typedef VkPhysicalDeviceSynchronization2Features32 VkPhysicalDeviceSynchronization2FeaturesKHR32;

typedef struct VkPhysicalDeviceHostImageCopyFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hostImageCopy;
} VkPhysicalDeviceHostImageCopyFeaturesEXT32;

typedef struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 primitivesGeneratedQuery;
    VkBool32 primitivesGeneratedQueryWithRasterizerDiscard;
    VkBool32 primitivesGeneratedQueryWithNonZeroStreams;
} VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32;

typedef struct VkPhysicalDeviceLegacyDitheringFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 legacyDithering;
} VkPhysicalDeviceLegacyDitheringFeaturesEXT32;

typedef struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multisampledRenderToSingleSampled;
} VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineProtectedAccess;
} VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32;

typedef struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 inheritedViewportScissor2D;
} VkPhysicalDeviceInheritedViewportScissorFeaturesNV32;

typedef struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 ycbcr2plane444Formats;
} VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32;

typedef struct VkPhysicalDeviceProvokingVertexFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 provokingVertexLast;
    VkBool32 transformFeedbackPreservesProvokingVertex;
} VkPhysicalDeviceProvokingVertexFeaturesEXT32;

typedef struct VkPhysicalDeviceDescriptorBufferFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorBuffer;
    VkBool32 descriptorBufferCaptureReplay;
    VkBool32 descriptorBufferImageLayoutIgnored;
    VkBool32 descriptorBufferPushDescriptors;
} VkPhysicalDeviceDescriptorBufferFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderIntegerDotProductFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderIntegerDotProduct;
} VkPhysicalDeviceShaderIntegerDotProductFeatures32;
typedef VkPhysicalDeviceShaderIntegerDotProductFeatures32 VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR32;

typedef struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentShaderBarycentric;
} VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32;
typedef VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV32;

typedef struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingMotionBlur;
    VkBool32 rayTracingMotionBlurPipelineTraceRaysIndirect;
} VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32;

typedef struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 formatRgba10x6WithoutYCbCrSampler;
} VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32;

typedef struct VkPhysicalDeviceDynamicRenderingFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicRendering;
} VkPhysicalDeviceDynamicRenderingFeatures32;
typedef VkPhysicalDeviceDynamicRenderingFeatures32 VkPhysicalDeviceDynamicRenderingFeaturesKHR32;

typedef struct VkPhysicalDeviceImageViewMinLodFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 minLod;
} VkPhysicalDeviceImageViewMinLodFeaturesEXT32;

typedef struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rasterizationOrderColorAttachmentAccess;
    VkBool32 rasterizationOrderDepthAttachmentAccess;
    VkBool32 rasterizationOrderStencilAttachmentAccess;
} VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32;
typedef VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM32;

typedef struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 linearColorAttachment;
} VkPhysicalDeviceLinearColorAttachmentFeaturesNV32;

typedef struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 graphicsPipelineLibrary;
} VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32;

typedef struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorSetHostMapping;
} VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32;

typedef struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 nestedCommandBuffer;
    VkBool32 nestedCommandBufferRendering;
    VkBool32 nestedCommandBufferSimultaneousUse;
} VkPhysicalDeviceNestedCommandBufferFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderModuleIdentifier;
} VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32;

typedef struct VkPhysicalDeviceImageCompressionControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageCompressionControl;
} VkPhysicalDeviceImageCompressionControlFeaturesEXT32;

typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageCompressionControlSwapchain;
} VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32;

typedef struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subpassMergeFeedback;
} VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32;

typedef struct VkPhysicalDeviceOpacityMicromapFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 micromap;
    VkBool32 micromapCaptureReplay;
    VkBool32 micromapHostCommands;
} VkPhysicalDeviceOpacityMicromapFeaturesEXT32;

typedef struct VkPhysicalDevicePipelinePropertiesFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelinePropertiesIdentifier;
} VkPhysicalDevicePipelinePropertiesFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderEarlyAndLateFragmentTests;
} VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32;

typedef struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 nonSeamlessCubeMap;
} VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineRobustnessFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineRobustness;
} VkPhysicalDevicePipelineRobustnessFeaturesEXT32;

typedef struct VkPhysicalDeviceImageProcessingFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 textureSampleWeighted;
    VkBool32 textureBoxFilter;
    VkBool32 textureBlockMatch;
} VkPhysicalDeviceImageProcessingFeaturesQCOM32;

typedef struct VkPhysicalDeviceTilePropertiesFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 tileProperties;
} VkPhysicalDeviceTilePropertiesFeaturesQCOM32;

typedef struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 attachmentFeedbackLoopLayout;
} VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32;

typedef struct VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClampZeroOne;
} VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32;

typedef struct VkPhysicalDeviceAddressBindingReportFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 reportAddressBinding;
} VkPhysicalDeviceAddressBindingReportFeaturesEXT32;

typedef struct VkPhysicalDeviceOpticalFlowFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 opticalFlow;
} VkPhysicalDeviceOpticalFlowFeaturesNV32;

typedef struct VkPhysicalDeviceFaultFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceFault;
    VkBool32 deviceFaultVendorBinary;
} VkPhysicalDeviceFaultFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineLibraryGroupHandles;
} VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderCoreBuiltins;
} VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32;

typedef struct VkPhysicalDeviceFrameBoundaryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 frameBoundary;
} VkPhysicalDeviceFrameBoundaryFeaturesEXT32;

typedef struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicRenderingUnusedAttachments;
} VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32;

typedef struct VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 swapchainMaintenance1;
} VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32;

typedef struct VkPhysicalDeviceDepthBiasControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthBiasControl;
    VkBool32 leastRepresentableValueForceUnormRepresentation;
    VkBool32 floatRepresentation;
    VkBool32 depthBiasExact;
} VkPhysicalDeviceDepthBiasControlFeaturesEXT32;

typedef struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingInvocationReorder;
} VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32;

typedef struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedSparseAddressSpace;
} VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32;

typedef struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiviewPerViewViewports;
} VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32;

typedef struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingPositionFetch;
} VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32;

typedef struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiviewPerViewRenderAreas;
} VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32;

typedef struct VkPhysicalDeviceShaderObjectFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderObject;
} VkPhysicalDeviceShaderObjectFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderTileImageFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderTileImageColorReadAccess;
    VkBool32 shaderTileImageDepthReadAccess;
    VkBool32 shaderTileImageStencilReadAccess;
} VkPhysicalDeviceShaderTileImageFeaturesEXT32;

typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cooperativeMatrix;
    VkBool32 cooperativeMatrixRobustBufferAccess;
} VkPhysicalDeviceCooperativeMatrixFeaturesKHR32;

typedef struct VkPhysicalDeviceCubicClampFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cubicRangeClamp;
} VkPhysicalDeviceCubicClampFeaturesQCOM32;

typedef struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 ycbcrDegamma;
} VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32;

typedef struct VkPhysicalDeviceCubicWeightsFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 selectableCubicWeights;
} VkPhysicalDeviceCubicWeightsFeaturesQCOM32;

typedef struct VkPhysicalDeviceImageProcessing2FeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 textureBlockMatch2;
} VkPhysicalDeviceImageProcessing2FeaturesQCOM32;

typedef struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorPoolOverallocation;
} VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32;

typedef struct VkDeviceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceCreateFlags flags;
    uint32_t queueCreateInfoCount;
    PTR32 pQueueCreateInfos;
    uint32_t enabledLayerCount;
    PTR32 ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    PTR32 ppEnabledExtensionNames;
    PTR32 pEnabledFeatures;
} VkDeviceCreateInfo32;

typedef struct VkEventCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkEventCreateFlags flags;
} VkEventCreateInfo32;

typedef struct VkExportFenceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalFenceHandleTypeFlags handleTypes;
} VkExportFenceCreateInfo32;
typedef VkExportFenceCreateInfo32 VkExportFenceCreateInfoKHR32;

typedef struct VkFenceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFenceCreateFlags flags;
} VkFenceCreateInfo32;

typedef struct VkFramebufferAttachmentImageInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCreateFlags flags;
    VkImageUsageFlags usage;
    uint32_t width;
    uint32_t height;
    uint32_t layerCount;
    uint32_t viewFormatCount;
    PTR32 pViewFormats;
} VkFramebufferAttachmentImageInfo32;
typedef VkFramebufferAttachmentImageInfo32 VkFramebufferAttachmentImageInfoKHR32;

typedef struct VkFramebufferAttachmentsCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentImageInfoCount;
    PTR32 pAttachmentImageInfos;
} VkFramebufferAttachmentsCreateInfo32;
typedef VkFramebufferAttachmentsCreateInfo32 VkFramebufferAttachmentsCreateInfoKHR32;

typedef struct VkFramebufferCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFramebufferCreateFlags flags;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    uint32_t width;
    uint32_t height;
    uint32_t layers;
} VkFramebufferCreateInfo32;

typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t vertexBindingDivisorCount;
    PTR32 pVertexBindingDivisors;
} VkPipelineVertexInputDivisorStateCreateInfoEXT32;

typedef struct VkPipelineVertexInputStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineVertexInputStateCreateFlags flags;
    uint32_t vertexBindingDescriptionCount;
    PTR32 pVertexBindingDescriptions;
    uint32_t vertexAttributeDescriptionCount;
    PTR32 pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo32;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTessellationDomainOrigin domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfo32;
typedef VkPipelineTessellationDomainOriginStateCreateInfo32 VkPipelineTessellationDomainOriginStateCreateInfoKHR32;

typedef struct VkPipelineTessellationStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineTessellationStateCreateFlags flags;
    uint32_t patchControlPoints;
} VkPipelineTessellationStateCreateInfo32;

typedef struct VkGraphicsShaderGroupCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t stageCount;
    PTR32 pStages;
    PTR32 pVertexInputState;
    PTR32 pTessellationState;
} VkGraphicsShaderGroupCreateInfoNV32;

typedef struct VkPipelineInputAssemblyStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineInputAssemblyStateCreateFlags flags;
    VkPrimitiveTopology topology;
    VkBool32 primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo32;

typedef struct VkPipelineViewportWScalingStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 viewportWScalingEnable;
    uint32_t viewportCount;
    PTR32 pViewportWScalings;
} VkPipelineViewportWScalingStateCreateInfoNV32;

typedef struct VkPipelineViewportSwizzleStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineViewportSwizzleStateCreateFlagsNV flags;
    uint32_t viewportCount;
    PTR32 pViewportSwizzles;
} VkPipelineViewportSwizzleStateCreateInfoNV32;

typedef struct VkPipelineViewportExclusiveScissorStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t exclusiveScissorCount;
    PTR32 pExclusiveScissors;
} VkPipelineViewportExclusiveScissorStateCreateInfoNV32;

typedef struct VkPipelineViewportShadingRateImageStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shadingRateImageEnable;
    uint32_t viewportCount;
    PTR32 pShadingRatePalettes;
} VkPipelineViewportShadingRateImageStateCreateInfoNV32;

typedef struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCoarseSampleOrderTypeNV sampleOrderType;
    uint32_t customSampleOrderCount;
    PTR32 pCustomSampleOrders;
} VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32;

typedef struct VkPipelineViewportDepthClipControlCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 negativeOneToOne;
} VkPipelineViewportDepthClipControlCreateInfoEXT32;

typedef struct VkPipelineViewportStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineViewportStateCreateFlags flags;
    uint32_t viewportCount;
    PTR32 pViewports;
    uint32_t scissorCount;
    PTR32 pScissors;
} VkPipelineViewportStateCreateInfo32;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRasterizationOrderAMD rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD32;

typedef struct VkPipelineRasterizationConservativeStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationConservativeStateCreateFlagsEXT flags;
    VkConservativeRasterizationModeEXT conservativeRasterizationMode;
    float extraPrimitiveOverestimationSize;
} VkPipelineRasterizationConservativeStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationStateStreamCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
    uint32_t rasterizationStream;
} VkPipelineRasterizationStateStreamCreateInfoEXT32;

typedef struct VkPipelineRasterizationDepthClipStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags;
    VkBool32 depthClipEnable;
} VkPipelineRasterizationDepthClipStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationLineStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkLineRasterizationModeEXT lineRasterizationMode;
    VkBool32 stippledLineEnable;
    uint32_t lineStippleFactor;
    uint16_t lineStipplePattern;
} VkPipelineRasterizationLineStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkProvokingVertexModeEXT provokingVertexMode;
} VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationStateCreateFlags flags;
    VkBool32 depthClampEnable;
    VkBool32 rasterizerDiscardEnable;
    VkPolygonMode polygonMode;
    VkCullModeFlags cullMode;
    VkFrontFace frontFace;
    VkBool32 depthBiasEnable;
    float depthBiasConstantFactor;
    float depthBiasClamp;
    float depthBiasSlopeFactor;
    float lineWidth;
} VkPipelineRasterizationStateCreateInfo32;

typedef struct VkPipelineCoverageToColorStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCoverageToColorStateCreateFlagsNV flags;
    VkBool32 coverageToColorEnable;
    uint32_t coverageToColorLocation;
} VkPipelineCoverageToColorStateCreateInfoNV32;

typedef struct VkPipelineSampleLocationsStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 sampleLocationsEnable;
    VkSampleLocationsInfoEXT32 sampleLocationsInfo;
} VkPipelineSampleLocationsStateCreateInfoEXT32;

typedef struct VkPipelineCoverageModulationStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCoverageModulationStateCreateFlagsNV flags;
    VkCoverageModulationModeNV coverageModulationMode;
    VkBool32 coverageModulationTableEnable;
    uint32_t coverageModulationTableCount;
    PTR32 pCoverageModulationTable;
} VkPipelineCoverageModulationStateCreateInfoNV32;

typedef struct VkPipelineCoverageReductionStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCoverageReductionStateCreateFlagsNV flags;
    VkCoverageReductionModeNV coverageReductionMode;
} VkPipelineCoverageReductionStateCreateInfoNV32;

typedef struct VkPipelineMultisampleStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineMultisampleStateCreateFlags flags;
    VkSampleCountFlagBits rasterizationSamples;
    VkBool32 sampleShadingEnable;
    float minSampleShading;
    PTR32 pSampleMask;
    VkBool32 alphaToCoverageEnable;
    VkBool32 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo32;

typedef struct VkPipelineDepthStencilStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineDepthStencilStateCreateFlags flags;
    VkBool32 depthTestEnable;
    VkBool32 depthWriteEnable;
    VkCompareOp depthCompareOp;
    VkBool32 depthBoundsTestEnable;
    VkBool32 stencilTestEnable;
    VkStencilOpState front;
    VkStencilOpState back;
    float minDepthBounds;
    float maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo32;

typedef struct VkPipelineColorBlendAdvancedStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 srcPremultiplied;
    VkBool32 dstPremultiplied;
    VkBlendOverlapEXT blendOverlap;
} VkPipelineColorBlendAdvancedStateCreateInfoEXT32;

typedef struct VkPipelineColorWriteCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentCount;
    PTR32 pColorWriteEnables;
} VkPipelineColorWriteCreateInfoEXT32;

typedef struct VkPipelineColorBlendStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineColorBlendStateCreateFlags flags;
    VkBool32 logicOpEnable;
    VkLogicOp logicOp;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    float blendConstants[4];
} VkPipelineColorBlendStateCreateInfo32;

typedef struct VkPipelineDynamicStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineDynamicStateCreateFlags flags;
    uint32_t dynamicStateCount;
    PTR32 pDynamicStates;
} VkPipelineDynamicStateCreateInfo32;

typedef struct VkGraphicsPipelineShaderGroupsCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t groupCount;
    PTR32 pGroups;
    uint32_t pipelineCount;
    PTR32 pPipelines;
} VkGraphicsPipelineShaderGroupsCreateInfoNV32;

typedef struct VkPipelineDiscardRectangleStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
    VkDiscardRectangleModeEXT discardRectangleMode;
    uint32_t discardRectangleCount;
    PTR32 pDiscardRectangles;
} VkPipelineDiscardRectangleStateCreateInfoEXT32;

typedef struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 representativeFragmentTestEnable;
} VkPipelineRepresentativeFragmentTestStateCreateInfoNV32;

typedef struct VkPipelineLibraryCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t libraryCount;
    PTR32 pLibraries;
} VkPipelineLibraryCreateInfoKHR32;

typedef struct VkPipelineFragmentShadingRateStateCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D fragmentSize;
    VkFragmentShadingRateCombinerOpKHR combinerOps[2];
} VkPipelineFragmentShadingRateStateCreateInfoKHR32;

typedef struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFragmentShadingRateTypeNV shadingRateType;
    VkFragmentShadingRateNV shadingRate;
    VkFragmentShadingRateCombinerOpKHR combinerOps[2];
} VkPipelineFragmentShadingRateEnumStateCreateInfoNV32;

typedef struct VkPipelineRenderingCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentFormats;
    VkFormat depthAttachmentFormat;
    VkFormat stencilAttachmentFormat;
} VkPipelineRenderingCreateInfo32;
typedef VkPipelineRenderingCreateInfo32 VkPipelineRenderingCreateInfoKHR32;

typedef struct VkGraphicsPipelineLibraryCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkGraphicsPipelineLibraryFlagsEXT flags;
} VkGraphicsPipelineLibraryCreateInfoEXT32;

typedef struct VkGraphicsPipelineCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    uint32_t stageCount;
    PTR32 pStages;
    PTR32 pVertexInputState;
    PTR32 pInputAssemblyState;
    PTR32 pTessellationState;
    PTR32 pViewportState;
    PTR32 pRasterizationState;
    PTR32 pMultisampleState;
    PTR32 pDepthStencilState;
    PTR32 pColorBlendState;
    PTR32 pDynamicState;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t subpass;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkGraphicsPipelineCreateInfo32;

typedef struct VkDedicatedAllocationImageCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV32;

typedef struct VkExternalMemoryImageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExternalMemoryImageCreateInfo32;
typedef VkExternalMemoryImageCreateInfo32 VkExternalMemoryImageCreateInfoKHR32;

typedef struct VkImageSwapchainCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
} VkImageSwapchainCreateInfoKHR32;

typedef struct VkImageFormatListCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t viewFormatCount;
    PTR32 pViewFormats;
} VkImageFormatListCreateInfo32;
typedef VkImageFormatListCreateInfo32 VkImageFormatListCreateInfoKHR32;

typedef struct VkImageStencilUsageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageUsageFlags stencilUsage;
} VkImageStencilUsageCreateInfo32;
typedef VkImageStencilUsageCreateInfo32 VkImageStencilUsageCreateInfoEXT32;

typedef struct VkImageCompressionControlEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCompressionFlagsEXT flags;
    uint32_t compressionControlPlaneCount;
    PTR32 pFixedRateFlags;
} VkImageCompressionControlEXT32;

typedef struct VkOpticalFlowImageFormatInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOpticalFlowUsageFlagsNV usage;
} VkOpticalFlowImageFormatInfoNV32;

typedef struct VkImageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCreateFlags flags;
    VkImageType imageType;
    VkFormat format;
    VkExtent3D extent;
    uint32_t mipLevels;
    uint32_t arrayLayers;
    VkSampleCountFlagBits samples;
    VkImageTiling tiling;
    VkImageUsageFlags usage;
    VkSharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
    VkImageLayout initialLayout;
} VkImageCreateInfo32;

typedef struct VkImageViewUsageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageUsageFlags usage;
} VkImageViewUsageCreateInfo32;
typedef VkImageViewUsageCreateInfo32 VkImageViewUsageCreateInfoKHR32;

typedef struct VkImageViewSlicedCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t sliceOffset;
    uint32_t sliceCount;
} VkImageViewSlicedCreateInfoEXT32;

typedef struct VkSamplerYcbcrConversionInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSamplerYcbcrConversion DECLSPEC_ALIGN(8) conversion;
} VkSamplerYcbcrConversionInfo32;
typedef VkSamplerYcbcrConversionInfo32 VkSamplerYcbcrConversionInfoKHR32;

typedef struct VkImageViewASTCDecodeModeEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat decodeMode;
} VkImageViewASTCDecodeModeEXT32;

typedef struct VkImageViewMinLodCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float minLod;
} VkImageViewMinLodCreateInfoEXT32;

typedef struct VkImageViewSampleWeightCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOffset2D filterCenter;
    VkExtent2D filterSize;
    uint32_t numPhases;
} VkImageViewSampleWeightCreateInfoQCOM32;

typedef struct VkImageViewCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageViewCreateFlags flags;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageViewType viewType;
    VkFormat format;
    VkComponentMapping components;
    VkImageSubresourceRange subresourceRange;
} VkImageViewCreateInfo32;

typedef struct VkIndirectCommandsLayoutTokenNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectCommandsTokenTypeNV tokenType;
    uint32_t stream;
    uint32_t offset;
    uint32_t vertexBindingUnit;
    VkBool32 vertexDynamicStride;
    VkPipelineLayout DECLSPEC_ALIGN(8) pushconstantPipelineLayout;
    VkShaderStageFlags pushconstantShaderStageFlags;
    uint32_t pushconstantOffset;
    uint32_t pushconstantSize;
    VkIndirectStateFlagsNV indirectStateFlags;
    uint32_t indexTypeCount;
    PTR32 pIndexTypes;
    PTR32 pIndexTypeValues;
} VkIndirectCommandsLayoutTokenNV32;

typedef struct VkIndirectCommandsLayoutCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectCommandsLayoutUsageFlagsNV flags;
    VkPipelineBindPoint pipelineBindPoint;
    uint32_t tokenCount;
    PTR32 pTokens;
    uint32_t streamCount;
    PTR32 pStreamStrides;
} VkIndirectCommandsLayoutCreateInfoNV32;

typedef struct VkApplicationInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pApplicationName;
    uint32_t applicationVersion;
    PTR32 pEngineName;
    uint32_t engineVersion;
    uint32_t apiVersion;
} VkApplicationInfo32;

typedef struct VkValidationFlagsEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t disabledValidationCheckCount;
    PTR32 pDisabledValidationChecks;
} VkValidationFlagsEXT32;

typedef struct VkValidationFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t enabledValidationFeatureCount;
    PTR32 pEnabledValidationFeatures;
    uint32_t disabledValidationFeatureCount;
    PTR32 pDisabledValidationFeatures;
} VkValidationFeaturesEXT32;

typedef struct VkInstanceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkInstanceCreateFlags flags;
    PTR32 pApplicationInfo;
    uint32_t enabledLayerCount;
    PTR32 ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    PTR32 ppEnabledExtensionNames;
} VkInstanceCreateInfo32;

typedef struct VkMicromapCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapCreateFlagsEXT createFlags;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkMicromapTypeEXT type;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
} VkMicromapCreateInfoEXT32;

typedef struct VkOpticalFlowSessionCreatePrivateDataInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t id;
    uint32_t size;
    PTR32 pPrivateData;
} VkOpticalFlowSessionCreatePrivateDataInfoNV32;

typedef struct VkOpticalFlowSessionCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t width;
    uint32_t height;
    VkFormat imageFormat;
    VkFormat flowVectorFormat;
    VkFormat costFormat;
    VkOpticalFlowGridSizeFlagsNV outputGridSize;
    VkOpticalFlowGridSizeFlagsNV hintGridSize;
    VkOpticalFlowPerformanceLevelNV performanceLevel;
    VkOpticalFlowSessionCreateFlagsNV flags;
} VkOpticalFlowSessionCreateInfoNV32;

typedef struct VkPipelineCacheCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCacheCreateFlags flags;
    PTR32 initialDataSize;
    PTR32 pInitialData;
} VkPipelineCacheCreateInfo32;

typedef struct VkPipelineLayoutCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineLayoutCreateFlags flags;
    uint32_t setLayoutCount;
    PTR32 pSetLayouts;
    uint32_t pushConstantRangeCount;
    PTR32 pPushConstantRanges;
} VkPipelineLayoutCreateInfo32;

typedef struct VkPrivateDataSlotCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPrivateDataSlotCreateFlags flags;
} VkPrivateDataSlotCreateInfo32;
typedef VkPrivateDataSlotCreateInfo32 VkPrivateDataSlotCreateInfoEXT32;

typedef struct VkQueryPoolPerformanceCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t queueFamilyIndex;
    uint32_t counterIndexCount;
    PTR32 pCounterIndices;
} VkQueryPoolPerformanceCreateInfoKHR32;

typedef struct VkQueryPoolPerformanceQueryCreateInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueryPoolSamplingModeINTEL performanceCountersSampling;
} VkQueryPoolPerformanceQueryCreateInfoINTEL32;
typedef VkQueryPoolPerformanceQueryCreateInfoINTEL32 VkQueryPoolCreateInfoINTEL32;

typedef struct VkQueryPoolCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueryPoolCreateFlags flags;
    VkQueryType queryType;
    uint32_t queryCount;
    VkQueryPipelineStatisticFlags pipelineStatistics;
} VkQueryPoolCreateInfo32;

typedef struct VkRayTracingShaderGroupCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRayTracingShaderGroupTypeKHR type;
    uint32_t generalShader;
    uint32_t closestHitShader;
    uint32_t anyHitShader;
    uint32_t intersectionShader;
    PTR32 pShaderGroupCaptureReplayHandle;
} VkRayTracingShaderGroupCreateInfoKHR32;

typedef struct VkRayTracingPipelineInterfaceCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPipelineRayPayloadSize;
    uint32_t maxPipelineRayHitAttributeSize;
} VkRayTracingPipelineInterfaceCreateInfoKHR32;

typedef struct VkRayTracingPipelineCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    uint32_t stageCount;
    PTR32 pStages;
    uint32_t groupCount;
    PTR32 pGroups;
    uint32_t maxPipelineRayRecursionDepth;
    PTR32 pLibraryInfo;
    PTR32 pLibraryInterface;
    PTR32 pDynamicState;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkRayTracingPipelineCreateInfoKHR32;

typedef struct VkRayTracingShaderGroupCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRayTracingShaderGroupTypeKHR type;
    uint32_t generalShader;
    uint32_t closestHitShader;
    uint32_t anyHitShader;
    uint32_t intersectionShader;
} VkRayTracingShaderGroupCreateInfoNV32;

typedef struct VkRayTracingPipelineCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    uint32_t stageCount;
    PTR32 pStages;
    uint32_t groupCount;
    PTR32 pGroups;
    uint32_t maxRecursionDepth;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkRayTracingPipelineCreateInfoNV32;

typedef struct VkSubpassDescription32
{
    VkSubpassDescriptionFlags flags;
    VkPipelineBindPoint pipelineBindPoint;
    uint32_t inputAttachmentCount;
    PTR32 pInputAttachments;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachments;
    PTR32 pResolveAttachments;
    PTR32 pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    PTR32 pPreserveAttachments;
} VkSubpassDescription32;

typedef struct VkRenderPassMultiviewCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t subpassCount;
    PTR32 pViewMasks;
    uint32_t dependencyCount;
    PTR32 pViewOffsets;
    uint32_t correlationMaskCount;
    PTR32 pCorrelationMasks;
} VkRenderPassMultiviewCreateInfo32;
typedef VkRenderPassMultiviewCreateInfo32 VkRenderPassMultiviewCreateInfoKHR32;

typedef struct VkRenderPassInputAttachmentAspectCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t aspectReferenceCount;
    PTR32 pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfo32;
typedef VkRenderPassInputAttachmentAspectCreateInfo32 VkRenderPassInputAttachmentAspectCreateInfoKHR32;

typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAttachmentReference fragmentDensityMapAttachment;
} VkRenderPassFragmentDensityMapCreateInfoEXT32;

typedef struct VkRenderPassCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPassCreateFlags flags;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    uint32_t subpassCount;
    PTR32 pSubpasses;
    uint32_t dependencyCount;
    PTR32 pDependencies;
} VkRenderPassCreateInfo32;

typedef struct VkAttachmentDescriptionStencilLayout32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageLayout stencilInitialLayout;
    VkImageLayout stencilFinalLayout;
} VkAttachmentDescriptionStencilLayout32;
typedef VkAttachmentDescriptionStencilLayout32 VkAttachmentDescriptionStencilLayoutKHR32;

typedef struct VkAttachmentDescription232
{
    VkStructureType sType;
    PTR32 pNext;
    VkAttachmentDescriptionFlags flags;
    VkFormat format;
    VkSampleCountFlagBits samples;
    VkAttachmentLoadOp loadOp;
    VkAttachmentStoreOp storeOp;
    VkAttachmentLoadOp stencilLoadOp;
    VkAttachmentStoreOp stencilStoreOp;
    VkImageLayout initialLayout;
    VkImageLayout finalLayout;
} VkAttachmentDescription232;
typedef VkAttachmentDescription232 VkAttachmentDescription2KHR32;

typedef struct VkAttachmentReferenceStencilLayout32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageLayout stencilLayout;
} VkAttachmentReferenceStencilLayout32;
typedef VkAttachmentReferenceStencilLayout32 VkAttachmentReferenceStencilLayoutKHR32;

typedef struct VkAttachmentReference232
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachment;
    VkImageLayout layout;
    VkImageAspectFlags aspectMask;
} VkAttachmentReference232;
typedef VkAttachmentReference232 VkAttachmentReference2KHR32;

typedef struct VkSubpassDescriptionDepthStencilResolve32
{
    VkStructureType sType;
    PTR32 pNext;
    VkResolveModeFlagBits depthResolveMode;
    VkResolveModeFlagBits stencilResolveMode;
    PTR32 pDepthStencilResolveAttachment;
} VkSubpassDescriptionDepthStencilResolve32;
typedef VkSubpassDescriptionDepthStencilResolve32 VkSubpassDescriptionDepthStencilResolveKHR32;

typedef struct VkFragmentShadingRateAttachmentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pFragmentShadingRateAttachment;
    VkExtent2D shadingRateAttachmentTexelSize;
} VkFragmentShadingRateAttachmentInfoKHR32;

typedef struct VkRenderPassCreationControlEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 disallowMerging;
} VkRenderPassCreationControlEXT32;

typedef struct VkRenderPassSubpassFeedbackCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pSubpassFeedback;
} VkRenderPassSubpassFeedbackCreateInfoEXT32;

typedef struct VkSubpassDescription232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubpassDescriptionFlags flags;
    VkPipelineBindPoint pipelineBindPoint;
    uint32_t viewMask;
    uint32_t inputAttachmentCount;
    PTR32 pInputAttachments;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachments;
    PTR32 pResolveAttachments;
    PTR32 pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    PTR32 pPreserveAttachments;
} VkSubpassDescription232;
typedef VkSubpassDescription232 VkSubpassDescription2KHR32;

typedef struct VkSubpassDependency232
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t srcSubpass;
    uint32_t dstSubpass;
    VkPipelineStageFlags srcStageMask;
    VkPipelineStageFlags dstStageMask;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
    VkDependencyFlags dependencyFlags;
    int32_t viewOffset;
} VkSubpassDependency232;
typedef VkSubpassDependency232 VkSubpassDependency2KHR32;

typedef struct VkRenderPassCreationFeedbackCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pRenderPassFeedback;
} VkRenderPassCreationFeedbackCreateInfoEXT32;

typedef struct VkRenderPassCreateInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPassCreateFlags flags;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    uint32_t subpassCount;
    PTR32 pSubpasses;
    uint32_t dependencyCount;
    PTR32 pDependencies;
    uint32_t correlatedViewMaskCount;
    PTR32 pCorrelatedViewMasks;
} VkRenderPassCreateInfo232;
typedef VkRenderPassCreateInfo232 VkRenderPassCreateInfo2KHR32;

typedef struct VkSamplerReductionModeCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSamplerReductionMode reductionMode;
} VkSamplerReductionModeCreateInfo32;
typedef VkSamplerReductionModeCreateInfo32 VkSamplerReductionModeCreateInfoEXT32;

typedef struct VkSamplerCustomBorderColorCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkClearColorValue customBorderColor;
    VkFormat format;
} VkSamplerCustomBorderColorCreateInfoEXT32;

typedef struct VkSamplerBorderColorComponentMappingCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkComponentMapping components;
    VkBool32 srgb;
} VkSamplerBorderColorComponentMappingCreateInfoEXT32;

typedef struct VkSamplerCubicWeightsCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCubicFilterWeightsQCOM cubicWeights;
} VkSamplerCubicWeightsCreateInfoQCOM32;

typedef struct VkSamplerBlockMatchWindowCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D windowExtent;
    VkBlockMatchWindowCompareModeQCOM windowCompareMode;
} VkSamplerBlockMatchWindowCreateInfoQCOM32;

typedef struct VkSamplerCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSamplerCreateFlags flags;
    VkFilter magFilter;
    VkFilter minFilter;
    VkSamplerMipmapMode mipmapMode;
    VkSamplerAddressMode addressModeU;
    VkSamplerAddressMode addressModeV;
    VkSamplerAddressMode addressModeW;
    float mipLodBias;
    VkBool32 anisotropyEnable;
    float maxAnisotropy;
    VkBool32 compareEnable;
    VkCompareOp compareOp;
    float minLod;
    float maxLod;
    VkBorderColor borderColor;
    VkBool32 unnormalizedCoordinates;
} VkSamplerCreateInfo32;

typedef struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 enableYDegamma;
    VkBool32 enableCbCrDegamma;
} VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32;

typedef struct VkSamplerYcbcrConversionCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkSamplerYcbcrModelConversion ycbcrModel;
    VkSamplerYcbcrRange ycbcrRange;
    VkComponentMapping components;
    VkChromaLocation xChromaOffset;
    VkChromaLocation yChromaOffset;
    VkFilter chromaFilter;
    VkBool32 forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfo32;
typedef VkSamplerYcbcrConversionCreateInfo32 VkSamplerYcbcrConversionCreateInfoKHR32;

typedef struct VkExportSemaphoreCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlags handleTypes;
} VkExportSemaphoreCreateInfo32;
typedef VkExportSemaphoreCreateInfo32 VkExportSemaphoreCreateInfoKHR32;

typedef struct VkExportSemaphoreWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pAttributes;
    DWORD dwAccess;
    LPCWSTR name;
} VkExportSemaphoreWin32HandleInfoKHR32;

typedef struct VkSemaphoreTypeCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphoreType semaphoreType;
    uint64_t DECLSPEC_ALIGN(8) initialValue;
} VkSemaphoreTypeCreateInfo32;
typedef VkSemaphoreTypeCreateInfo32 VkSemaphoreTypeCreateInfoKHR32;

typedef struct VkQueryLowLatencySupportNV32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pQueriedLowLatencyData;
} VkQueryLowLatencySupportNV32;

typedef struct VkSemaphoreCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphoreCreateFlags flags;
} VkSemaphoreCreateInfo32;

typedef struct VkShaderCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderCreateFlagsEXT flags;
    VkShaderStageFlagBits stage;
    VkShaderStageFlags nextStage;
    VkShaderCodeTypeEXT codeType;
    PTR32 codeSize;
    PTR32 pCode;
    PTR32 pName;
    uint32_t setLayoutCount;
    PTR32 pSetLayouts;
    uint32_t pushConstantRangeCount;
    PTR32 pPushConstantRanges;
    PTR32 pSpecializationInfo;
} VkShaderCreateInfoEXT32;

typedef struct VkDeviceGroupSwapchainCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceGroupPresentModeFlagsKHR modes;
} VkDeviceGroupSwapchainCreateInfoKHR32;

typedef struct VkSwapchainPresentBarrierCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentBarrierEnable;
} VkSwapchainPresentBarrierCreateInfoNV32;

typedef struct VkSwapchainPresentModesCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentModeCount;
    PTR32 pPresentModes;
} VkSwapchainPresentModesCreateInfoEXT32;

typedef struct VkSwapchainPresentScalingCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPresentScalingFlagsEXT scalingBehavior;
    VkPresentGravityFlagsEXT presentGravityX;
    VkPresentGravityFlagsEXT presentGravityY;
} VkSwapchainPresentScalingCreateInfoEXT32;

typedef struct VkSwapchainLatencyCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 latencyModeEnable;
} VkSwapchainLatencyCreateInfoNV32;

typedef struct VkSwapchainCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainCreateFlagsKHR flags;
    VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
    uint32_t minImageCount;
    VkFormat imageFormat;
    VkColorSpaceKHR imageColorSpace;
    VkExtent2D imageExtent;
    uint32_t imageArrayLayers;
    VkImageUsageFlags imageUsage;
    VkSharingMode imageSharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR preTransform;
    VkCompositeAlphaFlagBitsKHR compositeAlpha;
    VkPresentModeKHR presentMode;
    VkBool32 clipped;
    VkSwapchainKHR DECLSPEC_ALIGN(8) oldSwapchain;
} VkSwapchainCreateInfoKHR32;

typedef struct VkValidationCacheCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkValidationCacheCreateFlagsEXT flags;
    PTR32 initialDataSize;
    PTR32 pInitialData;
} VkValidationCacheCreateInfoEXT32;

typedef struct VkWin32SurfaceCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkWin32SurfaceCreateFlagsKHR flags;
    PTR32 hinstance;
    PTR32 hwnd;
} VkWin32SurfaceCreateInfoKHR32;

typedef struct VkDebugMarkerObjectNameInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugReportObjectTypeEXT objectType;
    uint64_t DECLSPEC_ALIGN(8) object;
    PTR32 pObjectName;
} VkDebugMarkerObjectNameInfoEXT32;

typedef struct VkDebugMarkerObjectTagInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugReportObjectTypeEXT objectType;
    uint64_t DECLSPEC_ALIGN(8) object;
    uint64_t DECLSPEC_ALIGN(8) tagName;
    PTR32 tagSize;
    PTR32 pTag;
} VkDebugMarkerObjectTagInfoEXT32;

typedef struct VkPhysicalDeviceGroupProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t physicalDeviceCount;
    PTR32 physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
    VkBool32 subsetAllocation;
} VkPhysicalDeviceGroupProperties32;
typedef VkPhysicalDeviceGroupProperties32 VkPhysicalDeviceGroupPropertiesKHR32;

typedef struct VkPerformanceCounterKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceCounterUnitKHR unit;
    VkPerformanceCounterScopeKHR scope;
    VkPerformanceCounterStorageKHR storage;
    uint8_t uuid[VK_UUID_SIZE];
} VkPerformanceCounterKHR32;

typedef struct VkPerformanceCounterDescriptionKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceCounterDescriptionFlagsKHR flags;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char category[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
} VkPerformanceCounterDescriptionKHR32;

typedef struct VkMappedMemoryRange32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkMappedMemoryRange32;

typedef struct VkAccelerationStructureBuildSizesInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) accelerationStructureSize;
    VkDeviceSize DECLSPEC_ALIGN(8) updateScratchSize;
    VkDeviceSize DECLSPEC_ALIGN(8) buildScratchSize;
} VkAccelerationStructureBuildSizesInfoKHR32;

typedef struct VkAccelerationStructureDeviceAddressInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) accelerationStructure;
} VkAccelerationStructureDeviceAddressInfoKHR32;

typedef struct VkAccelerationStructureMemoryRequirementsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureMemoryRequirementsTypeNV type;
    VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
} VkAccelerationStructureMemoryRequirementsInfoNV32;

typedef struct VkMemoryRequirements32
{
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceSize DECLSPEC_ALIGN(8) alignment;
    uint32_t memoryTypeBits;
} VkMemoryRequirements32;


typedef struct VkAccelerationStructureCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) accelerationStructure;
    VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructureNV;
} VkAccelerationStructureCaptureDescriptorDataInfoEXT32;

typedef struct VkBufferDeviceAddressInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkBufferDeviceAddressInfo32;
typedef VkBufferDeviceAddressInfo32 VkBufferDeviceAddressInfoKHR32;
typedef VkBufferDeviceAddressInfo32 VkBufferDeviceAddressInfoEXT32;

typedef struct VkBufferMemoryRequirementsInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkBufferMemoryRequirementsInfo232;
typedef VkBufferMemoryRequirementsInfo232 VkBufferMemoryRequirementsInfo2KHR32;

typedef struct VkMemoryDedicatedRequirements32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 prefersDedicatedAllocation;
    VkBool32 requiresDedicatedAllocation;
} VkMemoryDedicatedRequirements32;
typedef VkMemoryDedicatedRequirements32 VkMemoryDedicatedRequirementsKHR32;

typedef struct VkMemoryRequirements232
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryRequirements32 DECLSPEC_ALIGN(8) memoryRequirements;
} VkMemoryRequirements232;
typedef VkMemoryRequirements232 VkMemoryRequirements2KHR32;

typedef struct VkBufferCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkBufferCaptureDescriptorDataInfoEXT32;

typedef struct VkCalibratedTimestampInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTimeDomainEXT timeDomain;
} VkCalibratedTimestampInfoEXT32;

typedef struct VkDescriptorAddressInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) address;
    VkDeviceSize DECLSPEC_ALIGN(8) range;
    VkFormat format;
} VkDescriptorAddressInfoEXT32;

typedef union VkDescriptorDataEXT32
{
    PTR32 pSampler;
    PTR32 pCombinedImageSampler;
    PTR32 pInputAttachmentImage;
    PTR32 pSampledImage;
    PTR32 pStorageImage;
    PTR32 pUniformTexelBuffer;
    PTR32 pStorageTexelBuffer;
    PTR32 pUniformBuffer;
    PTR32 pStorageBuffer;
    VkDeviceAddress DECLSPEC_ALIGN(8) accelerationStructure;
} VkDescriptorDataEXT32;

typedef struct VkDescriptorGetInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorType type;
    VkDescriptorDataEXT32 DECLSPEC_ALIGN(8) data;
} VkDescriptorGetInfoEXT32;

typedef struct VkDescriptorSetBindingReferenceVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSetLayout DECLSPEC_ALIGN(8) descriptorSetLayout;
    uint32_t binding;
} VkDescriptorSetBindingReferenceVALVE32;

typedef struct VkDescriptorSetLayoutHostMappingInfoVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 descriptorOffset;
    uint32_t descriptorSize;
} VkDescriptorSetLayoutHostMappingInfoVALVE32;

typedef struct VkDescriptorSetVariableDescriptorCountLayoutSupport32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxVariableDescriptorCount;
} VkDescriptorSetVariableDescriptorCountLayoutSupport32;
typedef VkDescriptorSetVariableDescriptorCountLayoutSupport32 VkDescriptorSetVariableDescriptorCountLayoutSupportEXT32;

typedef struct VkDescriptorSetLayoutSupport32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 supported;
} VkDescriptorSetLayoutSupport32;
typedef VkDescriptorSetLayoutSupport32 VkDescriptorSetLayoutSupportKHR32;

typedef struct VkAccelerationStructureVersionInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pVersionData;
} VkAccelerationStructureVersionInfoKHR32;

typedef struct VkDeviceBufferMemoryRequirements32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
} VkDeviceBufferMemoryRequirements32;
typedef VkDeviceBufferMemoryRequirements32 VkDeviceBufferMemoryRequirementsKHR32;

typedef struct VkDeviceFaultCountsEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t addressInfoCount;
    uint32_t vendorInfoCount;
    VkDeviceSize DECLSPEC_ALIGN(8) vendorBinarySize;
} VkDeviceFaultCountsEXT32;

typedef struct VkDeviceFaultAddressInfoEXT32
{
    VkDeviceFaultAddressTypeEXT addressType;
    VkDeviceAddress DECLSPEC_ALIGN(8) reportedAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) addressPrecision;
} VkDeviceFaultAddressInfoEXT32;

typedef struct VkDeviceFaultVendorInfoEXT32
{
    char description[VK_MAX_DESCRIPTION_SIZE];
    uint64_t DECLSPEC_ALIGN(8) vendorFaultCode;
    uint64_t DECLSPEC_ALIGN(8) vendorFaultData;
} VkDeviceFaultVendorInfoEXT32;

typedef struct VkDeviceFaultInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    char description[VK_MAX_DESCRIPTION_SIZE];
    PTR32 pAddressInfos;
    PTR32 pVendorInfos;
    PTR32 pVendorBinaryData;
} VkDeviceFaultInfoEXT32;

typedef struct VkDeviceGroupPresentCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentMask[VK_MAX_DEVICE_GROUP_SIZE];
    VkDeviceGroupPresentModeFlagsKHR modes;
} VkDeviceGroupPresentCapabilitiesKHR32;

typedef struct VkDeviceImageMemoryRequirements32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
    VkImageAspectFlagBits planeAspect;
} VkDeviceImageMemoryRequirements32;
typedef VkDeviceImageMemoryRequirements32 VkDeviceImageMemoryRequirementsKHR32;

typedef struct VkSparseImageMemoryRequirements32
{
    VkSparseImageFormatProperties formatProperties;
    uint32_t imageMipTailFirstLod;
    VkDeviceSize DECLSPEC_ALIGN(8) imageMipTailSize;
    VkDeviceSize DECLSPEC_ALIGN(8) imageMipTailOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) imageMipTailStride;
} VkSparseImageMemoryRequirements32;

typedef struct VkSparseImageMemoryRequirements232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSparseImageMemoryRequirements32 DECLSPEC_ALIGN(8) memoryRequirements;
} VkSparseImageMemoryRequirements232;
typedef VkSparseImageMemoryRequirements232 VkSparseImageMemoryRequirements2KHR32;

typedef struct VkImageSubresource2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresource imageSubresource;
} VkImageSubresource2KHR32;
typedef VkImageSubresource2KHR32 VkImageSubresource2EXT32;

typedef struct VkDeviceImageSubresourceInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
    PTR32 pSubresource;
} VkDeviceImageSubresourceInfoKHR32;

typedef struct VkSubresourceLayout32
{
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceSize DECLSPEC_ALIGN(8) rowPitch;
    VkDeviceSize DECLSPEC_ALIGN(8) arrayPitch;
    VkDeviceSize DECLSPEC_ALIGN(8) depthPitch;
} VkSubresourceLayout32;

typedef struct VkSubresourceHostMemcpySizeEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkSubresourceHostMemcpySizeEXT32;

typedef struct VkImageCompressionPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCompressionFlagsEXT imageCompressionFlags;
    VkImageCompressionFixedRateFlagsEXT imageCompressionFixedRateFlags;
} VkImageCompressionPropertiesEXT32;

typedef struct VkSubresourceLayout2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubresourceLayout32 DECLSPEC_ALIGN(8) subresourceLayout;
} VkSubresourceLayout2KHR32;
typedef VkSubresourceLayout2KHR32 VkSubresourceLayout2EXT32;

typedef struct VkDeviceMemoryOpaqueCaptureAddressInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
} VkDeviceMemoryOpaqueCaptureAddressInfo32;
typedef VkDeviceMemoryOpaqueCaptureAddressInfo32 VkDeviceMemoryOpaqueCaptureAddressInfoKHR32;

typedef struct VkMicromapVersionInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pVersionData;
} VkMicromapVersionInfoEXT32;

typedef struct VkDeviceQueueInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueIndex;
} VkDeviceQueueInfo232;

typedef struct VkTilePropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent3D tileSize;
    VkExtent2D apronSize;
    VkOffset2D origin;
} VkTilePropertiesQCOM32;

typedef struct VkGeneratedCommandsMemoryRequirementsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    VkIndirectCommandsLayoutNV DECLSPEC_ALIGN(8) indirectCommandsLayout;
    uint32_t maxSequencesCount;
} VkGeneratedCommandsMemoryRequirementsInfoNV32;

typedef struct VkImagePlaneMemoryRequirementsInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageAspectFlagBits planeAspect;
} VkImagePlaneMemoryRequirementsInfo32;
typedef VkImagePlaneMemoryRequirementsInfo32 VkImagePlaneMemoryRequirementsInfoKHR32;

typedef struct VkImageMemoryRequirementsInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
} VkImageMemoryRequirementsInfo232;
typedef VkImageMemoryRequirementsInfo232 VkImageMemoryRequirementsInfo2KHR32;

typedef struct VkImageCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
} VkImageCaptureDescriptorDataInfoEXT32;

typedef struct VkImageSparseMemoryRequirementsInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
} VkImageSparseMemoryRequirementsInfo232;
typedef VkImageSparseMemoryRequirementsInfo232 VkImageSparseMemoryRequirementsInfo2KHR32;

typedef struct VkImageViewAddressPropertiesNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkImageViewAddressPropertiesNVX32;

typedef struct VkImageViewHandleInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkDescriptorType descriptorType;
    VkSampler DECLSPEC_ALIGN(8) sampler;
} VkImageViewHandleInfoNVX32;

typedef struct VkImageViewCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
} VkImageViewCaptureDescriptorDataInfoEXT32;

typedef struct VkLatencyTimingsFrameReportNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentID;
    uint64_t DECLSPEC_ALIGN(8) inputSampleTimeUs;
    uint64_t DECLSPEC_ALIGN(8) simStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) simEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) renderSubmitStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) renderSubmitEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) presentStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) presentEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) driverStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) driverEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) osRenderQueueStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) osRenderQueueEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) gpuRenderStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) gpuRenderEndTimeUs;
} VkLatencyTimingsFrameReportNV32;

typedef struct VkGetLatencyMarkerInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pTimings;
} VkGetLatencyMarkerInfoNV32;

typedef struct VkMemoryGetFdInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkMemoryGetFdInfoKHR32;

typedef struct VkMemoryFdPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryTypeBits;
} VkMemoryFdPropertiesKHR32;

typedef struct VkMemoryHostPointerPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryTypeBits;
} VkMemoryHostPointerPropertiesEXT32;

typedef struct VkMemoryGetWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkMemoryGetWin32HandleInfoKHR32;

typedef struct VkMemoryWin32HandlePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryTypeBits;
} VkMemoryWin32HandlePropertiesKHR32;

typedef struct VkMicromapBuildSizesInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) micromapSize;
    VkDeviceSize DECLSPEC_ALIGN(8) buildScratchSize;
    VkBool32 discardable;
} VkMicromapBuildSizesInfoEXT32;

typedef union VkPerformanceValueDataINTEL32
{
    uint32_t value32;
    uint64_t DECLSPEC_ALIGN(8) value64;
    float valueFloat;
    VkBool32 valueBool;
    PTR32 valueString;
} VkPerformanceValueDataINTEL32;

typedef struct VkPerformanceValueINTEL32
{
    VkPerformanceValueTypeINTEL type;
    VkPerformanceValueDataINTEL32 DECLSPEC_ALIGN(8) data;
} VkPerformanceValueINTEL32;

typedef struct VkCooperativeMatrixPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t MSize;
    uint32_t NSize;
    uint32_t KSize;
    VkComponentTypeKHR AType;
    VkComponentTypeKHR BType;
    VkComponentTypeKHR CType;
    VkComponentTypeKHR ResultType;
    VkBool32 saturatingAccumulation;
    VkScopeKHR scope;
} VkCooperativeMatrixPropertiesKHR32;

typedef struct VkCooperativeMatrixPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t MSize;
    uint32_t NSize;
    uint32_t KSize;
    VkComponentTypeNV AType;
    VkComponentTypeNV BType;
    VkComponentTypeNV CType;
    VkComponentTypeNV DType;
    VkScopeNV scope;
} VkCooperativeMatrixPropertiesNV32;

typedef struct VkPhysicalDeviceExternalBufferInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferCreateFlags flags;
    VkBufferUsageFlags usage;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalBufferInfo32;
typedef VkPhysicalDeviceExternalBufferInfo32 VkPhysicalDeviceExternalBufferInfoKHR32;

typedef struct VkExternalBufferProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryProperties externalMemoryProperties;
} VkExternalBufferProperties32;
typedef VkExternalBufferProperties32 VkExternalBufferPropertiesKHR32;

typedef struct VkPhysicalDeviceExternalFenceInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalFenceHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalFenceInfo32;
typedef VkPhysicalDeviceExternalFenceInfo32 VkPhysicalDeviceExternalFenceInfoKHR32;

typedef struct VkExternalFenceProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlags compatibleHandleTypes;
    VkExternalFenceFeatureFlags externalFenceFeatures;
} VkExternalFenceProperties32;
typedef VkExternalFenceProperties32 VkExternalFencePropertiesKHR32;

typedef struct VkPhysicalDeviceExternalSemaphoreInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalSemaphoreInfo32;
typedef VkPhysicalDeviceExternalSemaphoreInfo32 VkPhysicalDeviceExternalSemaphoreInfoKHR32;

typedef struct VkExternalSemaphoreProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures;
} VkExternalSemaphoreProperties32;
typedef VkExternalSemaphoreProperties32 VkExternalSemaphorePropertiesKHR32;

typedef struct VkSubpassResolvePerformanceQueryEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 optimal;
} VkSubpassResolvePerformanceQueryEXT32;

typedef struct VkFormatProperties332
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) linearTilingFeatures;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) optimalTilingFeatures;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) bufferFeatures;
} VkFormatProperties332;
typedef VkFormatProperties332 VkFormatProperties3KHR32;

typedef struct VkFormatProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormatProperties formatProperties;
} VkFormatProperties232;
typedef VkFormatProperties232 VkFormatProperties2KHR32;

typedef struct VkPhysicalDeviceFragmentShadingRateKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlags sampleCounts;
    VkExtent2D fragmentSize;
} VkPhysicalDeviceFragmentShadingRateKHR32;

typedef struct VkImageFormatProperties32
{
    VkExtent3D maxExtent;
    uint32_t maxMipLevels;
    uint32_t maxArrayLayers;
    VkSampleCountFlags sampleCounts;
    VkDeviceSize DECLSPEC_ALIGN(8) maxResourceSize;
} VkImageFormatProperties32;

typedef struct VkPhysicalDeviceExternalImageFormatInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalImageFormatInfo32;
typedef VkPhysicalDeviceExternalImageFormatInfo32 VkPhysicalDeviceExternalImageFormatInfoKHR32;

typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageViewType imageViewType;
} VkPhysicalDeviceImageViewImageFormatInfoEXT32;

typedef struct VkPhysicalDeviceImageFormatInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkImageType type;
    VkImageTiling tiling;
    VkImageUsageFlags usage;
    VkImageCreateFlags flags;
} VkPhysicalDeviceImageFormatInfo232;
typedef VkPhysicalDeviceImageFormatInfo232 VkPhysicalDeviceImageFormatInfo2KHR32;

typedef struct VkExternalImageFormatProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryProperties externalMemoryProperties;
} VkExternalImageFormatProperties32;
typedef VkExternalImageFormatProperties32 VkExternalImageFormatPropertiesKHR32;

typedef struct VkSamplerYcbcrConversionImageFormatProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatProperties32;
typedef VkSamplerYcbcrConversionImageFormatProperties32 VkSamplerYcbcrConversionImageFormatPropertiesKHR32;

typedef struct VkTextureLODGatherFormatPropertiesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 supportsTextureGatherLODBiasAMD;
} VkTextureLODGatherFormatPropertiesAMD32;

typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 filterCubic;
    VkBool32 filterCubicMinmax;
} VkFilterCubicImageViewImageFormatPropertiesEXT32;

typedef struct VkHostImageCopyDevicePerformanceQueryEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 optimalDeviceAccess;
    VkBool32 identicalMemoryLayout;
} VkHostImageCopyDevicePerformanceQueryEXT32;

typedef struct VkImageFormatProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageFormatProperties32 DECLSPEC_ALIGN(8) imageFormatProperties;
} VkImageFormatProperties232;
typedef VkImageFormatProperties232 VkImageFormatProperties2KHR32;

typedef struct VkMemoryHeap32
{
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkMemoryHeapFlags flags;
} VkMemoryHeap32;

typedef struct VkPhysicalDeviceMemoryProperties32
{
    uint32_t memoryTypeCount;
    VkMemoryType memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t memoryHeapCount;
    VkMemoryHeap32 DECLSPEC_ALIGN(8) memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties32;

typedef struct VkPhysicalDeviceMemoryBudgetPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) heapBudget[VK_MAX_MEMORY_HEAPS];
    VkDeviceSize DECLSPEC_ALIGN(8) heapUsage[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryBudgetPropertiesEXT32;

typedef struct VkPhysicalDeviceMemoryProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceMemoryProperties32 DECLSPEC_ALIGN(8) memoryProperties;
} VkPhysicalDeviceMemoryProperties232;
typedef VkPhysicalDeviceMemoryProperties232 VkPhysicalDeviceMemoryProperties2KHR32;

typedef struct VkMultisamplePropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D maxSampleLocationGridSize;
} VkMultisamplePropertiesEXT32;

typedef struct VkOpticalFlowImageFormatPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
} VkOpticalFlowImageFormatPropertiesNV32;

typedef struct VkPhysicalDeviceLimits32
{
    uint32_t maxImageDimension1D;
    uint32_t maxImageDimension2D;
    uint32_t maxImageDimension3D;
    uint32_t maxImageDimensionCube;
    uint32_t maxImageArrayLayers;
    uint32_t maxTexelBufferElements;
    uint32_t maxUniformBufferRange;
    uint32_t maxStorageBufferRange;
    uint32_t maxPushConstantsSize;
    uint32_t maxMemoryAllocationCount;
    uint32_t maxSamplerAllocationCount;
    VkDeviceSize DECLSPEC_ALIGN(8) bufferImageGranularity;
    VkDeviceSize DECLSPEC_ALIGN(8) sparseAddressSpaceSize;
    uint32_t maxBoundDescriptorSets;
    uint32_t maxPerStageDescriptorSamplers;
    uint32_t maxPerStageDescriptorUniformBuffers;
    uint32_t maxPerStageDescriptorStorageBuffers;
    uint32_t maxPerStageDescriptorSampledImages;
    uint32_t maxPerStageDescriptorStorageImages;
    uint32_t maxPerStageDescriptorInputAttachments;
    uint32_t maxPerStageResources;
    uint32_t maxDescriptorSetSamplers;
    uint32_t maxDescriptorSetUniformBuffers;
    uint32_t maxDescriptorSetUniformBuffersDynamic;
    uint32_t maxDescriptorSetStorageBuffers;
    uint32_t maxDescriptorSetStorageBuffersDynamic;
    uint32_t maxDescriptorSetSampledImages;
    uint32_t maxDescriptorSetStorageImages;
    uint32_t maxDescriptorSetInputAttachments;
    uint32_t maxVertexInputAttributes;
    uint32_t maxVertexInputBindings;
    uint32_t maxVertexInputAttributeOffset;
    uint32_t maxVertexInputBindingStride;
    uint32_t maxVertexOutputComponents;
    uint32_t maxTessellationGenerationLevel;
    uint32_t maxTessellationPatchSize;
    uint32_t maxTessellationControlPerVertexInputComponents;
    uint32_t maxTessellationControlPerVertexOutputComponents;
    uint32_t maxTessellationControlPerPatchOutputComponents;
    uint32_t maxTessellationControlTotalOutputComponents;
    uint32_t maxTessellationEvaluationInputComponents;
    uint32_t maxTessellationEvaluationOutputComponents;
    uint32_t maxGeometryShaderInvocations;
    uint32_t maxGeometryInputComponents;
    uint32_t maxGeometryOutputComponents;
    uint32_t maxGeometryOutputVertices;
    uint32_t maxGeometryTotalOutputComponents;
    uint32_t maxFragmentInputComponents;
    uint32_t maxFragmentOutputAttachments;
    uint32_t maxFragmentDualSrcAttachments;
    uint32_t maxFragmentCombinedOutputResources;
    uint32_t maxComputeSharedMemorySize;
    uint32_t maxComputeWorkGroupCount[3];
    uint32_t maxComputeWorkGroupInvocations;
    uint32_t maxComputeWorkGroupSize[3];
    uint32_t subPixelPrecisionBits;
    uint32_t subTexelPrecisionBits;
    uint32_t mipmapPrecisionBits;
    uint32_t maxDrawIndexedIndexValue;
    uint32_t maxDrawIndirectCount;
    float maxSamplerLodBias;
    float maxSamplerAnisotropy;
    uint32_t maxViewports;
    uint32_t maxViewportDimensions[2];
    float viewportBoundsRange[2];
    uint32_t viewportSubPixelBits;
    PTR32 minMemoryMapAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minTexelBufferOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minUniformBufferOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minStorageBufferOffsetAlignment;
    int32_t minTexelOffset;
    uint32_t maxTexelOffset;
    int32_t minTexelGatherOffset;
    uint32_t maxTexelGatherOffset;
    float minInterpolationOffset;
    float maxInterpolationOffset;
    uint32_t subPixelInterpolationOffsetBits;
    uint32_t maxFramebufferWidth;
    uint32_t maxFramebufferHeight;
    uint32_t maxFramebufferLayers;
    VkSampleCountFlags framebufferColorSampleCounts;
    VkSampleCountFlags framebufferDepthSampleCounts;
    VkSampleCountFlags framebufferStencilSampleCounts;
    VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
    uint32_t maxColorAttachments;
    VkSampleCountFlags sampledImageColorSampleCounts;
    VkSampleCountFlags sampledImageIntegerSampleCounts;
    VkSampleCountFlags sampledImageDepthSampleCounts;
    VkSampleCountFlags sampledImageStencilSampleCounts;
    VkSampleCountFlags storageImageSampleCounts;
    uint32_t maxSampleMaskWords;
    VkBool32 timestampComputeAndGraphics;
    float timestampPeriod;
    uint32_t maxClipDistances;
    uint32_t maxCullDistances;
    uint32_t maxCombinedClipAndCullDistances;
    uint32_t discreteQueuePriorities;
    float pointSizeRange[2];
    float lineWidthRange[2];
    float pointSizeGranularity;
    float lineWidthGranularity;
    VkBool32 strictLines;
    VkBool32 standardSampleLocations;
    VkDeviceSize DECLSPEC_ALIGN(8) optimalBufferCopyOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) optimalBufferCopyRowPitchAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) nonCoherentAtomSize;
} VkPhysicalDeviceLimits32;

typedef struct VkPhysicalDeviceProperties32
{
    uint32_t apiVersion;
    uint32_t driverVersion;
    uint32_t vendorID;
    uint32_t deviceID;
    VkPhysicalDeviceType deviceType;
    char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits32 DECLSPEC_ALIGN(8) limits;
    VkPhysicalDeviceSparseProperties sparseProperties;
} VkPhysicalDeviceProperties32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxGraphicsShaderGroupCount;
    uint32_t maxIndirectSequenceCount;
    uint32_t maxIndirectCommandsTokenCount;
    uint32_t maxIndirectCommandsStreamCount;
    uint32_t maxIndirectCommandsTokenOffset;
    uint32_t maxIndirectCommandsStreamStride;
    uint32_t minSequencesCountBufferOffsetAlignment;
    uint32_t minSequencesIndexBufferOffsetAlignment;
    uint32_t minIndirectCommandsBufferOffsetAlignment;
} VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV32;

typedef struct VkPhysicalDeviceMultiDrawPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxMultiDrawCount;
} VkPhysicalDeviceMultiDrawPropertiesEXT32;

typedef struct VkPhysicalDevicePushDescriptorPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPushDescriptors;
} VkPhysicalDevicePushDescriptorPropertiesKHR32;

typedef struct VkPhysicalDeviceDriverProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDriverId driverID;
    char driverName[VK_MAX_DRIVER_NAME_SIZE];
    char driverInfo[VK_MAX_DRIVER_INFO_SIZE];
    VkConformanceVersion conformanceVersion;
} VkPhysicalDeviceDriverProperties32;
typedef VkPhysicalDeviceDriverProperties32 VkPhysicalDeviceDriverPropertiesKHR32;

typedef struct VkPhysicalDeviceIDProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t deviceUUID[VK_UUID_SIZE];
    uint8_t driverUUID[VK_UUID_SIZE];
    uint8_t deviceLUID[VK_LUID_SIZE];
    uint32_t deviceNodeMask;
    VkBool32 deviceLUIDValid;
} VkPhysicalDeviceIDProperties32;
typedef VkPhysicalDeviceIDProperties32 VkPhysicalDeviceIDPropertiesKHR32;

typedef struct VkPhysicalDeviceMultiviewProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewProperties32;
typedef VkPhysicalDeviceMultiviewProperties32 VkPhysicalDeviceMultiviewPropertiesKHR32;

typedef struct VkPhysicalDeviceDiscardRectanglePropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxDiscardRectangles;
} VkPhysicalDeviceDiscardRectanglePropertiesEXT32;

typedef struct VkPhysicalDeviceSubgroupProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t subgroupSize;
    VkShaderStageFlags supportedStages;
    VkSubgroupFeatureFlags supportedOperations;
    VkBool32 quadOperationsInAllStages;
} VkPhysicalDeviceSubgroupProperties32;

typedef struct VkPhysicalDevicePointClippingProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPointClippingBehavior pointClippingBehavior;
} VkPhysicalDevicePointClippingProperties32;
typedef VkPhysicalDevicePointClippingProperties32 VkPhysicalDevicePointClippingPropertiesKHR32;

typedef struct VkPhysicalDeviceProtectedMemoryProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 protectedNoFault;
} VkPhysicalDeviceProtectedMemoryProperties32;

typedef struct VkPhysicalDeviceSamplerFilterMinmaxProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 filterMinmaxSingleComponentFormats;
    VkBool32 filterMinmaxImageComponentMapping;
} VkPhysicalDeviceSamplerFilterMinmaxProperties32;
typedef VkPhysicalDeviceSamplerFilterMinmaxProperties32 VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT32;

typedef struct VkPhysicalDeviceSampleLocationsPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlags sampleLocationSampleCounts;
    VkExtent2D maxSampleLocationGridSize;
    float sampleLocationCoordinateRange[2];
    uint32_t sampleLocationSubPixelBits;
    VkBool32 variableSampleLocations;
} VkPhysicalDeviceSampleLocationsPropertiesEXT32;

typedef struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t advancedBlendMaxColorAttachments;
    VkBool32 advancedBlendIndependentBlend;
    VkBool32 advancedBlendNonPremultipliedSrcColor;
    VkBool32 advancedBlendNonPremultipliedDstColor;
    VkBool32 advancedBlendCorrelatedOverlap;
    VkBool32 advancedBlendAllOperations;
} VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32;

typedef struct VkPhysicalDeviceInlineUniformBlockProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxInlineUniformBlockSize;
    uint32_t maxPerStageDescriptorInlineUniformBlocks;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t maxDescriptorSetInlineUniformBlocks;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
} VkPhysicalDeviceInlineUniformBlockProperties32;
typedef VkPhysicalDeviceInlineUniformBlockProperties32 VkPhysicalDeviceInlineUniformBlockPropertiesEXT32;

typedef struct VkPhysicalDeviceMaintenance3Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPerSetDescriptors;
    VkDeviceSize DECLSPEC_ALIGN(8) maxMemoryAllocationSize;
} VkPhysicalDeviceMaintenance3Properties32;
typedef VkPhysicalDeviceMaintenance3Properties32 VkPhysicalDeviceMaintenance3PropertiesKHR32;

typedef struct VkPhysicalDeviceMaintenance4Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) maxBufferSize;
} VkPhysicalDeviceMaintenance4Properties32;
typedef VkPhysicalDeviceMaintenance4Properties32 VkPhysicalDeviceMaintenance4PropertiesKHR32;

typedef struct VkPhysicalDeviceMaintenance5PropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting;
    VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting;
    VkBool32 depthStencilSwizzleOneSupport;
    VkBool32 polygonModePointSize;
    VkBool32 nonStrictSinglePixelWideLinesUseParallelogram;
    VkBool32 nonStrictWideLinesUseParallelogram;
} VkPhysicalDeviceMaintenance5PropertiesKHR32;

typedef struct VkPhysicalDeviceFloatControlsProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderFloatControlsIndependence denormBehaviorIndependence;
    VkShaderFloatControlsIndependence roundingModeIndependence;
    VkBool32 shaderSignedZeroInfNanPreserveFloat16;
    VkBool32 shaderSignedZeroInfNanPreserveFloat32;
    VkBool32 shaderSignedZeroInfNanPreserveFloat64;
    VkBool32 shaderDenormPreserveFloat16;
    VkBool32 shaderDenormPreserveFloat32;
    VkBool32 shaderDenormPreserveFloat64;
    VkBool32 shaderDenormFlushToZeroFloat16;
    VkBool32 shaderDenormFlushToZeroFloat32;
    VkBool32 shaderDenormFlushToZeroFloat64;
    VkBool32 shaderRoundingModeRTEFloat16;
    VkBool32 shaderRoundingModeRTEFloat32;
    VkBool32 shaderRoundingModeRTEFloat64;
    VkBool32 shaderRoundingModeRTZFloat16;
    VkBool32 shaderRoundingModeRTZFloat32;
    VkBool32 shaderRoundingModeRTZFloat64;
} VkPhysicalDeviceFloatControlsProperties32;
typedef VkPhysicalDeviceFloatControlsProperties32 VkPhysicalDeviceFloatControlsPropertiesKHR32;

typedef struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) minImportedHostPointerAlignment;
} VkPhysicalDeviceExternalMemoryHostPropertiesEXT32;

typedef struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float primitiveOverestimationSize;
    float maxExtraPrimitiveOverestimationSize;
    float extraPrimitiveOverestimationSizeGranularity;
    VkBool32 primitiveUnderestimation;
    VkBool32 conservativePointAndLineRasterization;
    VkBool32 degenerateTrianglesRasterized;
    VkBool32 degenerateLinesRasterized;
    VkBool32 fullyCoveredFragmentShaderInputVariable;
    VkBool32 conservativeRasterizationPostDepthCoverage;
} VkPhysicalDeviceConservativeRasterizationPropertiesEXT32;

typedef struct VkPhysicalDeviceShaderCorePropertiesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderEngineCount;
    uint32_t shaderArraysPerEngineCount;
    uint32_t computeUnitsPerShaderArray;
    uint32_t simdPerComputeUnit;
    uint32_t wavefrontsPerSimd;
    uint32_t wavefrontSize;
    uint32_t sgprsPerSimd;
    uint32_t minSgprAllocation;
    uint32_t maxSgprAllocation;
    uint32_t sgprAllocationGranularity;
    uint32_t vgprsPerSimd;
    uint32_t minVgprAllocation;
    uint32_t maxVgprAllocation;
    uint32_t vgprAllocationGranularity;
} VkPhysicalDeviceShaderCorePropertiesAMD32;

typedef struct VkPhysicalDeviceShaderCoreProperties2AMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderCorePropertiesFlagsAMD shaderCoreFeatures;
    uint32_t activeComputeUnitCount;
} VkPhysicalDeviceShaderCoreProperties2AMD32;

typedef struct VkPhysicalDeviceDescriptorIndexingProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32 robustBufferAccessUpdateAfterBind;
    VkBool32 quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
} VkPhysicalDeviceDescriptorIndexingProperties32;
typedef VkPhysicalDeviceDescriptorIndexingProperties32 VkPhysicalDeviceDescriptorIndexingPropertiesEXT32;

typedef struct VkPhysicalDeviceTimelineSemaphoreProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) maxTimelineSemaphoreValueDifference;
} VkPhysicalDeviceTimelineSemaphoreProperties32;
typedef VkPhysicalDeviceTimelineSemaphoreProperties32 VkPhysicalDeviceTimelineSemaphorePropertiesKHR32;

typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxVertexAttribDivisor;
} VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT32;

typedef struct VkPhysicalDevicePCIBusInfoPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t pciDomain;
    uint32_t pciBus;
    uint32_t pciDevice;
    uint32_t pciFunction;
} VkPhysicalDevicePCIBusInfoPropertiesEXT32;

typedef struct VkPhysicalDeviceDepthStencilResolveProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkResolveModeFlags supportedDepthResolveModes;
    VkResolveModeFlags supportedStencilResolveModes;
    VkBool32 independentResolveNone;
    VkBool32 independentResolve;
} VkPhysicalDeviceDepthStencilResolveProperties32;
typedef VkPhysicalDeviceDepthStencilResolveProperties32 VkPhysicalDeviceDepthStencilResolvePropertiesKHR32;

typedef struct VkPhysicalDeviceTransformFeedbackPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxTransformFeedbackStreams;
    uint32_t maxTransformFeedbackBuffers;
    VkDeviceSize DECLSPEC_ALIGN(8) maxTransformFeedbackBufferSize;
    uint32_t maxTransformFeedbackStreamDataSize;
    uint32_t maxTransformFeedbackBufferDataSize;
    uint32_t maxTransformFeedbackBufferDataStride;
    VkBool32 transformFeedbackQueries;
    VkBool32 transformFeedbackStreamsLinesTriangles;
    VkBool32 transformFeedbackRasterizationStreamSelect;
    VkBool32 transformFeedbackDraw;
} VkPhysicalDeviceTransformFeedbackPropertiesEXT32;

typedef struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueueFlags supportedQueues;
} VkPhysicalDeviceCopyMemoryIndirectPropertiesNV32;

typedef struct VkPhysicalDeviceMemoryDecompressionPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryDecompressionMethodFlagsNV DECLSPEC_ALIGN(8) decompressionMethods;
    uint64_t DECLSPEC_ALIGN(8) maxDecompressionIndirectCount;
} VkPhysicalDeviceMemoryDecompressionPropertiesNV32;

typedef struct VkPhysicalDeviceShadingRateImagePropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D shadingRateTexelSize;
    uint32_t shadingRatePaletteSize;
    uint32_t shadingRateMaxCoarseSamples;
} VkPhysicalDeviceShadingRateImagePropertiesNV32;

typedef struct VkPhysicalDeviceMeshShaderPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxDrawMeshTasksCount;
    uint32_t maxTaskWorkGroupInvocations;
    uint32_t maxTaskWorkGroupSize[3];
    uint32_t maxTaskTotalMemorySize;
    uint32_t maxTaskOutputCount;
    uint32_t maxMeshWorkGroupInvocations;
    uint32_t maxMeshWorkGroupSize[3];
    uint32_t maxMeshTotalMemorySize;
    uint32_t maxMeshOutputVertices;
    uint32_t maxMeshOutputPrimitives;
    uint32_t maxMeshMultiviewViewCount;
    uint32_t meshOutputPerVertexGranularity;
    uint32_t meshOutputPerPrimitiveGranularity;
} VkPhysicalDeviceMeshShaderPropertiesNV32;

typedef struct VkPhysicalDeviceMeshShaderPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxTaskWorkGroupTotalCount;
    uint32_t maxTaskWorkGroupCount[3];
    uint32_t maxTaskWorkGroupInvocations;
    uint32_t maxTaskWorkGroupSize[3];
    uint32_t maxTaskPayloadSize;
    uint32_t maxTaskSharedMemorySize;
    uint32_t maxTaskPayloadAndSharedMemorySize;
    uint32_t maxMeshWorkGroupTotalCount;
    uint32_t maxMeshWorkGroupCount[3];
    uint32_t maxMeshWorkGroupInvocations;
    uint32_t maxMeshWorkGroupSize[3];
    uint32_t maxMeshSharedMemorySize;
    uint32_t maxMeshPayloadAndSharedMemorySize;
    uint32_t maxMeshOutputMemorySize;
    uint32_t maxMeshPayloadAndOutputMemorySize;
    uint32_t maxMeshOutputComponents;
    uint32_t maxMeshOutputVertices;
    uint32_t maxMeshOutputPrimitives;
    uint32_t maxMeshOutputLayers;
    uint32_t maxMeshMultiviewViewCount;
    uint32_t meshOutputPerVertexGranularity;
    uint32_t meshOutputPerPrimitiveGranularity;
    uint32_t maxPreferredTaskWorkGroupInvocations;
    uint32_t maxPreferredMeshWorkGroupInvocations;
    VkBool32 prefersLocalInvocationVertexOutput;
    VkBool32 prefersLocalInvocationPrimitiveOutput;
    VkBool32 prefersCompactVertexOutput;
    VkBool32 prefersCompactPrimitiveOutput;
} VkPhysicalDeviceMeshShaderPropertiesEXT32;

typedef struct VkPhysicalDeviceAccelerationStructurePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) maxGeometryCount;
    uint64_t DECLSPEC_ALIGN(8) maxInstanceCount;
    uint64_t DECLSPEC_ALIGN(8) maxPrimitiveCount;
    uint32_t maxPerStageDescriptorAccelerationStructures;
    uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
    uint32_t maxDescriptorSetAccelerationStructures;
    uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures;
    uint32_t minAccelerationStructureScratchOffsetAlignment;
} VkPhysicalDeviceAccelerationStructurePropertiesKHR32;

typedef struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderGroupHandleSize;
    uint32_t maxRayRecursionDepth;
    uint32_t maxShaderGroupStride;
    uint32_t shaderGroupBaseAlignment;
    uint32_t shaderGroupHandleCaptureReplaySize;
    uint32_t maxRayDispatchInvocationCount;
    uint32_t shaderGroupHandleAlignment;
    uint32_t maxRayHitAttributeSize;
} VkPhysicalDeviceRayTracingPipelinePropertiesKHR32;

typedef struct VkPhysicalDeviceRayTracingPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderGroupHandleSize;
    uint32_t maxRecursionDepth;
    uint32_t maxShaderGroupStride;
    uint32_t shaderGroupBaseAlignment;
    uint64_t DECLSPEC_ALIGN(8) maxGeometryCount;
    uint64_t DECLSPEC_ALIGN(8) maxInstanceCount;
    uint64_t DECLSPEC_ALIGN(8) maxTriangleCount;
    uint32_t maxDescriptorSetAccelerationStructures;
} VkPhysicalDeviceRayTracingPropertiesNV32;

typedef struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D minFragmentDensityTexelSize;
    VkExtent2D maxFragmentDensityTexelSize;
    VkBool32 fragmentDensityInvocations;
} VkPhysicalDeviceFragmentDensityMapPropertiesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subsampledLoads;
    VkBool32 subsampledCoarseReconstructionEarlyAccess;
    uint32_t maxSubsampledArrayLayers;
    uint32_t maxDescriptorSetSubsampledSamplers;
} VkPhysicalDeviceFragmentDensityMap2PropertiesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D fragmentDensityOffsetGranularity;
} VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM32;

typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags cooperativeMatrixSupportedStages;
} VkPhysicalDeviceCooperativeMatrixPropertiesNV32;

typedef struct VkPhysicalDevicePerformanceQueryPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 allowCommandBufferQueryCopies;
} VkPhysicalDevicePerformanceQueryPropertiesKHR32;

typedef struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderSMCount;
    uint32_t shaderWarpsPerSM;
} VkPhysicalDeviceShaderSMBuiltinsPropertiesNV32;

typedef struct VkPhysicalDeviceTexelBufferAlignmentProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) storageTexelBufferOffsetAlignmentBytes;
    VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) uniformTexelBufferOffsetAlignmentBytes;
    VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
} VkPhysicalDeviceTexelBufferAlignmentProperties32;
typedef VkPhysicalDeviceTexelBufferAlignmentProperties32 VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT32;

typedef struct VkPhysicalDeviceSubgroupSizeControlProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t minSubgroupSize;
    uint32_t maxSubgroupSize;
    uint32_t maxComputeWorkgroupSubgroups;
    VkShaderStageFlags requiredSubgroupSizeStages;
} VkPhysicalDeviceSubgroupSizeControlProperties32;
typedef VkPhysicalDeviceSubgroupSizeControlProperties32 VkPhysicalDeviceSubgroupSizeControlPropertiesEXT32;

typedef struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxSubpassShadingWorkgroupSizeAspectRatio;
} VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32;

typedef struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxWorkGroupCount[3];
    uint32_t maxWorkGroupSize[3];
    uint32_t maxOutputClusterCount;
    VkDeviceSize DECLSPEC_ALIGN(8) indirectBufferOffsetAlignment;
} VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32;

typedef struct VkPhysicalDeviceLineRasterizationPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t lineSubPixelPrecisionBits;
} VkPhysicalDeviceLineRasterizationPropertiesEXT32;

typedef struct VkPhysicalDeviceVulkan11Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t deviceUUID[VK_UUID_SIZE];
    uint8_t driverUUID[VK_UUID_SIZE];
    uint8_t deviceLUID[VK_LUID_SIZE];
    uint32_t deviceNodeMask;
    VkBool32 deviceLUIDValid;
    uint32_t subgroupSize;
    VkShaderStageFlags subgroupSupportedStages;
    VkSubgroupFeatureFlags subgroupSupportedOperations;
    VkBool32 subgroupQuadOperationsInAllStages;
    VkPointClippingBehavior pointClippingBehavior;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
    VkBool32 protectedNoFault;
    uint32_t maxPerSetDescriptors;
    VkDeviceSize DECLSPEC_ALIGN(8) maxMemoryAllocationSize;
} VkPhysicalDeviceVulkan11Properties32;

typedef struct VkPhysicalDeviceVulkan12Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDriverId driverID;
    char driverName[VK_MAX_DRIVER_NAME_SIZE];
    char driverInfo[VK_MAX_DRIVER_INFO_SIZE];
    VkConformanceVersion conformanceVersion;
    VkShaderFloatControlsIndependence denormBehaviorIndependence;
    VkShaderFloatControlsIndependence roundingModeIndependence;
    VkBool32 shaderSignedZeroInfNanPreserveFloat16;
    VkBool32 shaderSignedZeroInfNanPreserveFloat32;
    VkBool32 shaderSignedZeroInfNanPreserveFloat64;
    VkBool32 shaderDenormPreserveFloat16;
    VkBool32 shaderDenormPreserveFloat32;
    VkBool32 shaderDenormPreserveFloat64;
    VkBool32 shaderDenormFlushToZeroFloat16;
    VkBool32 shaderDenormFlushToZeroFloat32;
    VkBool32 shaderDenormFlushToZeroFloat64;
    VkBool32 shaderRoundingModeRTEFloat16;
    VkBool32 shaderRoundingModeRTEFloat32;
    VkBool32 shaderRoundingModeRTEFloat64;
    VkBool32 shaderRoundingModeRTZFloat16;
    VkBool32 shaderRoundingModeRTZFloat32;
    VkBool32 shaderRoundingModeRTZFloat64;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32 robustBufferAccessUpdateAfterBind;
    VkBool32 quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
    VkResolveModeFlags supportedDepthResolveModes;
    VkResolveModeFlags supportedStencilResolveModes;
    VkBool32 independentResolveNone;
    VkBool32 independentResolve;
    VkBool32 filterMinmaxSingleComponentFormats;
    VkBool32 filterMinmaxImageComponentMapping;
    uint64_t DECLSPEC_ALIGN(8) maxTimelineSemaphoreValueDifference;
    VkSampleCountFlags framebufferIntegerColorSampleCounts;
} VkPhysicalDeviceVulkan12Properties32;

typedef struct VkPhysicalDeviceVulkan13Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t minSubgroupSize;
    uint32_t maxSubgroupSize;
    uint32_t maxComputeWorkgroupSubgroups;
    VkShaderStageFlags requiredSubgroupSizeStages;
    uint32_t maxInlineUniformBlockSize;
    uint32_t maxPerStageDescriptorInlineUniformBlocks;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t maxDescriptorSetInlineUniformBlocks;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    uint32_t maxInlineUniformTotalSize;
    VkBool32 integerDotProduct8BitUnsignedAccelerated;
    VkBool32 integerDotProduct8BitSignedAccelerated;
    VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProduct16BitUnsignedAccelerated;
    VkBool32 integerDotProduct16BitSignedAccelerated;
    VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct32BitUnsignedAccelerated;
    VkBool32 integerDotProduct32BitSignedAccelerated;
    VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct64BitUnsignedAccelerated;
    VkBool32 integerDotProduct64BitSignedAccelerated;
    VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    VkDeviceSize DECLSPEC_ALIGN(8) storageTexelBufferOffsetAlignmentBytes;
    VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) uniformTexelBufferOffsetAlignmentBytes;
    VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) maxBufferSize;
} VkPhysicalDeviceVulkan13Properties32;

typedef struct VkPhysicalDeviceCustomBorderColorPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxCustomBorderColorSamplers;
} VkPhysicalDeviceCustomBorderColorPropertiesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicPrimitiveTopologyUnrestricted;
} VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32;

typedef struct VkPhysicalDeviceRobustness2PropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) robustStorageBufferAccessSizeAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) robustUniformBufferAccessSizeAlignment;
} VkPhysicalDeviceRobustness2PropertiesEXT32;

typedef struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D minFragmentShadingRateAttachmentTexelSize;
    VkExtent2D maxFragmentShadingRateAttachmentTexelSize;
    uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
    VkBool32 primitiveFragmentShadingRateWithMultipleViewports;
    VkBool32 layeredShadingRateAttachments;
    VkBool32 fragmentShadingRateNonTrivialCombinerOps;
    VkExtent2D maxFragmentSize;
    uint32_t maxFragmentSizeAspectRatio;
    uint32_t maxFragmentShadingRateCoverageSamples;
    VkSampleCountFlagBits maxFragmentShadingRateRasterizationSamples;
    VkBool32 fragmentShadingRateWithShaderDepthStencilWrites;
    VkBool32 fragmentShadingRateWithSampleMask;
    VkBool32 fragmentShadingRateWithShaderSampleMask;
    VkBool32 fragmentShadingRateWithConservativeRasterization;
    VkBool32 fragmentShadingRateWithFragmentShaderInterlock;
    VkBool32 fragmentShadingRateWithCustomSampleLocations;
    VkBool32 fragmentShadingRateStrictMultiplyCombiner;
} VkPhysicalDeviceFragmentShadingRatePropertiesKHR32;

typedef struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlagBits maxFragmentShadingRateInvocationCount;
} VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32;

typedef struct VkPhysicalDeviceHostImageCopyPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t copySrcLayoutCount;
    PTR32 pCopySrcLayouts;
    uint32_t copyDstLayoutCount;
    PTR32 pCopyDstLayouts;
    uint8_t optimalTilingLayoutUUID[VK_UUID_SIZE];
    VkBool32 identicalMemoryTypeRequirements;
} VkPhysicalDeviceHostImageCopyPropertiesEXT32;

typedef struct VkPhysicalDeviceProvokingVertexPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 provokingVertexModePerPipeline;
    VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
} VkPhysicalDeviceProvokingVertexPropertiesEXT32;

typedef struct VkPhysicalDeviceDescriptorBufferPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 combinedImageSamplerDescriptorSingleArray;
    VkBool32 bufferlessPushDescriptors;
    VkBool32 allowSamplerImageViewPostSubmitCreation;
    VkDeviceSize DECLSPEC_ALIGN(8) descriptorBufferOffsetAlignment;
    uint32_t maxDescriptorBufferBindings;
    uint32_t maxResourceDescriptorBufferBindings;
    uint32_t maxSamplerDescriptorBufferBindings;
    uint32_t maxEmbeddedImmutableSamplerBindings;
    uint32_t maxEmbeddedImmutableSamplers;
    PTR32 bufferCaptureReplayDescriptorDataSize;
    PTR32 imageCaptureReplayDescriptorDataSize;
    PTR32 imageViewCaptureReplayDescriptorDataSize;
    PTR32 samplerCaptureReplayDescriptorDataSize;
    PTR32 accelerationStructureCaptureReplayDescriptorDataSize;
    PTR32 samplerDescriptorSize;
    PTR32 combinedImageSamplerDescriptorSize;
    PTR32 sampledImageDescriptorSize;
    PTR32 storageImageDescriptorSize;
    PTR32 uniformTexelBufferDescriptorSize;
    PTR32 robustUniformTexelBufferDescriptorSize;
    PTR32 storageTexelBufferDescriptorSize;
    PTR32 robustStorageTexelBufferDescriptorSize;
    PTR32 uniformBufferDescriptorSize;
    PTR32 robustUniformBufferDescriptorSize;
    PTR32 storageBufferDescriptorSize;
    PTR32 robustStorageBufferDescriptorSize;
    PTR32 inputAttachmentDescriptorSize;
    PTR32 accelerationStructureDescriptorSize;
    VkDeviceSize DECLSPEC_ALIGN(8) maxSamplerDescriptorBufferRange;
    VkDeviceSize DECLSPEC_ALIGN(8) maxResourceDescriptorBufferRange;
    VkDeviceSize DECLSPEC_ALIGN(8) samplerDescriptorBufferAddressSpaceSize;
    VkDeviceSize DECLSPEC_ALIGN(8) resourceDescriptorBufferAddressSpaceSize;
    VkDeviceSize DECLSPEC_ALIGN(8) descriptorBufferAddressSpaceSize;
} VkPhysicalDeviceDescriptorBufferPropertiesEXT32;

typedef struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 combinedImageSamplerDensityMapDescriptorSize;
} VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT32;

typedef struct VkPhysicalDeviceShaderIntegerDotProductProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 integerDotProduct8BitUnsignedAccelerated;
    VkBool32 integerDotProduct8BitSignedAccelerated;
    VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProduct16BitUnsignedAccelerated;
    VkBool32 integerDotProduct16BitSignedAccelerated;
    VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct32BitUnsignedAccelerated;
    VkBool32 integerDotProduct32BitSignedAccelerated;
    VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct64BitUnsignedAccelerated;
    VkBool32 integerDotProduct64BitSignedAccelerated;
    VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
} VkPhysicalDeviceShaderIntegerDotProductProperties32;
typedef VkPhysicalDeviceShaderIntegerDotProductProperties32 VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR32;

typedef struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 triStripVertexOrderIndependentOfProvokingVertex;
} VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR32;

typedef struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 graphicsPipelineLibraryFastLinking;
    VkBool32 graphicsPipelineLibraryIndependentInterpolationDecoration;
} VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32;

typedef struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxCommandBufferNestingLevel;
} VkPhysicalDeviceNestedCommandBufferPropertiesEXT32;

typedef struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t shaderModuleIdentifierAlgorithmUUID[VK_UUID_SIZE];
} VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT32;

typedef struct VkPhysicalDeviceOpacityMicromapPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxOpacity2StateSubdivisionLevel;
    uint32_t maxOpacity4StateSubdivisionLevel;
} VkPhysicalDeviceOpacityMicromapPropertiesEXT32;

typedef struct VkPhysicalDevicePipelineRobustnessPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRobustnessBufferBehaviorEXT defaultRobustnessStorageBuffers;
    VkPipelineRobustnessBufferBehaviorEXT defaultRobustnessUniformBuffers;
    VkPipelineRobustnessBufferBehaviorEXT defaultRobustnessVertexInputs;
    VkPipelineRobustnessImageBehaviorEXT defaultRobustnessImages;
} VkPhysicalDevicePipelineRobustnessPropertiesEXT32;

typedef struct VkPhysicalDeviceImageProcessingPropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxWeightFilterPhases;
    VkExtent2D maxWeightFilterDimension;
    VkExtent2D maxBlockMatchRegion;
    VkExtent2D maxBoxFilterBlockSize;
} VkPhysicalDeviceImageProcessingPropertiesQCOM32;

typedef struct VkPhysicalDeviceOpticalFlowPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOpticalFlowGridSizeFlagsNV supportedOutputGridSizes;
    VkOpticalFlowGridSizeFlagsNV supportedHintGridSizes;
    VkBool32 hintSupported;
    VkBool32 costSupported;
    VkBool32 bidirectionalFlowSupported;
    VkBool32 globalFlowSupported;
    uint32_t minWidth;
    uint32_t minHeight;
    uint32_t maxWidth;
    uint32_t maxHeight;
    uint32_t maxNumRegionsOfInterest;
} VkPhysicalDeviceOpticalFlowPropertiesNV32;

typedef struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) shaderCoreMask;
    uint32_t shaderCoreCount;
    uint32_t shaderWarpsPerCore;
} VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM32;

typedef struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRayTracingInvocationReorderModeNV rayTracingInvocationReorderReorderingHint;
} VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV32;

typedef struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) extendedSparseAddressSpaceSize;
    VkImageUsageFlags extendedSparseImageUsageFlags;
    VkBufferUsageFlags extendedSparseBufferUsageFlags;
} VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV32;

typedef struct VkPhysicalDeviceShaderCorePropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t pixelRate;
    uint32_t texelRate;
    uint32_t fmaRate;
} VkPhysicalDeviceShaderCorePropertiesARM32;

typedef struct VkPhysicalDeviceShaderObjectPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t shaderBinaryUUID[VK_UUID_SIZE];
    uint32_t shaderBinaryVersion;
} VkPhysicalDeviceShaderObjectPropertiesEXT32;

typedef struct VkPhysicalDeviceShaderTileImagePropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderTileImageCoherentReadAccelerated;
    VkBool32 shaderTileImageReadSampleFromPixelRateInvocation;
    VkBool32 shaderTileImageReadFromHelperInvocation;
} VkPhysicalDeviceShaderTileImagePropertiesEXT32;

typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags cooperativeMatrixSupportedStages;
} VkPhysicalDeviceCooperativeMatrixPropertiesKHR32;

typedef struct VkPhysicalDeviceImageProcessing2PropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D maxBlockMatchWindow;
} VkPhysicalDeviceImageProcessing2PropertiesQCOM32;

typedef struct VkPhysicalDeviceLayeredDriverPropertiesMSFT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkLayeredDriverUnderlyingApiMSFT underlyingAPI;
} VkPhysicalDeviceLayeredDriverPropertiesMSFT32;

typedef struct VkPhysicalDeviceProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceProperties32 DECLSPEC_ALIGN(8) properties;
} VkPhysicalDeviceProperties232;
typedef VkPhysicalDeviceProperties232 VkPhysicalDeviceProperties2KHR32;

typedef struct VkQueueFamilyGlobalPriorityPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t priorityCount;
    VkQueueGlobalPriorityKHR priorities[VK_MAX_GLOBAL_PRIORITY_SIZE_KHR];
} VkQueueFamilyGlobalPriorityPropertiesKHR32;
typedef VkQueueFamilyGlobalPriorityPropertiesKHR32 VkQueueFamilyGlobalPriorityPropertiesEXT32;

typedef struct VkQueueFamilyCheckpointPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags checkpointExecutionStageMask;
} VkQueueFamilyCheckpointPropertiesNV32;

typedef struct VkQueueFamilyCheckpointProperties2NV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) checkpointExecutionStageMask;
} VkQueueFamilyCheckpointProperties2NV32;

typedef struct VkQueueFamilyProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueueFamilyProperties queueFamilyProperties;
} VkQueueFamilyProperties232;
typedef VkQueueFamilyProperties232 VkQueueFamilyProperties2KHR32;

typedef struct VkPhysicalDeviceSparseImageFormatInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkImageType type;
    VkSampleCountFlagBits samples;
    VkImageUsageFlags usage;
    VkImageTiling tiling;
} VkPhysicalDeviceSparseImageFormatInfo232;
typedef VkPhysicalDeviceSparseImageFormatInfo232 VkPhysicalDeviceSparseImageFormatInfo2KHR32;

typedef struct VkSparseImageFormatProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSparseImageFormatProperties properties;
} VkSparseImageFormatProperties232;
typedef VkSparseImageFormatProperties232 VkSparseImageFormatProperties2KHR32;

typedef struct VkFramebufferMixedSamplesCombinationNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCoverageReductionModeNV coverageReductionMode;
    VkSampleCountFlagBits rasterizationSamples;
    VkSampleCountFlags depthStencilSamples;
    VkSampleCountFlags colorSamples;
} VkFramebufferMixedSamplesCombinationNV32;

typedef struct VkSurfacePresentModeEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPresentModeKHR presentMode;
} VkSurfacePresentModeEXT32;

typedef struct VkPhysicalDeviceSurfaceInfo2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
} VkPhysicalDeviceSurfaceInfo2KHR32;

typedef struct VkSurfaceCapabilitiesPresentBarrierNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentBarrierSupported;
} VkSurfaceCapabilitiesPresentBarrierNV32;

typedef struct VkSurfacePresentScalingCapabilitiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPresentScalingFlagsEXT supportedPresentScaling;
    VkPresentGravityFlagsEXT supportedPresentGravityX;
    VkPresentGravityFlagsEXT supportedPresentGravityY;
    VkExtent2D minScaledImageExtent;
    VkExtent2D maxScaledImageExtent;
} VkSurfacePresentScalingCapabilitiesEXT32;

typedef struct VkSurfacePresentModeCompatibilityEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentModeCount;
    PTR32 pPresentModes;
} VkSurfacePresentModeCompatibilityEXT32;

typedef struct VkLatencySurfaceCapabilitiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentModeCount;
    PTR32 pPresentModes;
} VkLatencySurfaceCapabilitiesNV32;

typedef struct VkSurfaceCapabilities2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceCapabilitiesKHR surfaceCapabilities;
} VkSurfaceCapabilities2KHR32;

typedef struct VkSurfaceFormat2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceFormatKHR surfaceFormat;
} VkSurfaceFormat2KHR32;

typedef struct VkPhysicalDeviceToolProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    char name[VK_MAX_EXTENSION_NAME_SIZE];
    char version[VK_MAX_EXTENSION_NAME_SIZE];
    VkToolPurposeFlags purposes;
    char description[VK_MAX_DESCRIPTION_SIZE];
    char layer[VK_MAX_EXTENSION_NAME_SIZE];
} VkPhysicalDeviceToolProperties32;
typedef VkPhysicalDeviceToolProperties32 VkPhysicalDeviceToolPropertiesEXT32;

typedef struct VkPipelineExecutableInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    uint32_t executableIndex;
} VkPipelineExecutableInfoKHR32;

typedef struct VkPipelineExecutableInternalRepresentationKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
    VkBool32 isText;
    PTR32 dataSize;
    PTR32 pData;
} VkPipelineExecutableInternalRepresentationKHR32;

typedef struct VkPipelineInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkPipelineInfoKHR32;
typedef VkPipelineInfoKHR32 VkPipelineInfoEXT32;

typedef struct VkPipelineExecutablePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags stages;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
    uint32_t subgroupSize;
} VkPipelineExecutablePropertiesKHR32;

typedef union VkPipelineExecutableStatisticValueKHR32
{
    VkBool32 b32;
    int64_t i64;
    uint64_t DECLSPEC_ALIGN(8) u64;
    double f64;
} VkPipelineExecutableStatisticValueKHR32;

typedef struct VkPipelineExecutableStatisticKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
    VkPipelineExecutableStatisticFormatKHR format;
    VkPipelineExecutableStatisticValueKHR32 DECLSPEC_ALIGN(8) value;
} VkPipelineExecutableStatisticKHR32;

typedef struct VkPipelineIndirectDeviceAddressInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkPipelineIndirectDeviceAddressInfoNV32;


typedef struct VkCheckpointData2NV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
    PTR32 pCheckpointMarker;
} VkCheckpointData2NV32;

typedef struct VkCheckpointDataNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlagBits stage;
    PTR32 pCheckpointMarker;
} VkCheckpointDataNV32;

typedef struct VkRenderingAreaInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentFormats;
    VkFormat depthAttachmentFormat;
    VkFormat stencilAttachmentFormat;
} VkRenderingAreaInfoKHR32;

typedef struct VkSamplerCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampler DECLSPEC_ALIGN(8) sampler;
} VkSamplerCaptureDescriptorDataInfoEXT32;

typedef struct VkSemaphoreGetFdInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
} VkSemaphoreGetFdInfoKHR32;

typedef struct VkSemaphoreGetWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
} VkSemaphoreGetWin32HandleInfoKHR32;

typedef struct VkShaderModuleIdentifierEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t identifierSize;
    uint8_t identifier[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT];
} VkShaderModuleIdentifierEXT32;

typedef struct VkImportSemaphoreFdInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkSemaphoreImportFlags flags;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
    int fd;
} VkImportSemaphoreFdInfoKHR32;

typedef struct VkImportSemaphoreWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkSemaphoreImportFlags flags;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
    HANDLE handle;
    LPCWSTR name;
} VkImportSemaphoreWin32HandleInfoKHR32;

typedef struct VkInitializePerformanceApiInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pUserData;
} VkInitializePerformanceApiInfoINTEL32;

typedef struct VkLatencySleepInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) signalSemaphore;
    uint64_t DECLSPEC_ALIGN(8) value;
} VkLatencySleepInfoNV32;

typedef struct VkMemoryMapInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryMapFlags flags;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkMemoryMapInfoKHR32;

typedef struct VkSparseMemoryBind32
{
    VkDeviceSize DECLSPEC_ALIGN(8) resourceOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    VkSparseMemoryBindFlags flags;
} VkSparseMemoryBind32;

typedef struct VkSparseBufferMemoryBindInfo32
{
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    uint32_t bindCount;
    PTR32 pBinds;
} VkSparseBufferMemoryBindInfo32;

typedef struct VkSparseImageOpaqueMemoryBindInfo32
{
    VkImage DECLSPEC_ALIGN(8) image;
    uint32_t bindCount;
    PTR32 pBinds;
} VkSparseImageOpaqueMemoryBindInfo32;

typedef struct VkSparseImageMemoryBind32
{
    VkImageSubresource subresource;
    VkOffset3D offset;
    VkExtent3D extent;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    VkSparseMemoryBindFlags flags;
} VkSparseImageMemoryBind32;

typedef struct VkSparseImageMemoryBindInfo32
{
    VkImage DECLSPEC_ALIGN(8) image;
    uint32_t bindCount;
    PTR32 pBinds;
} VkSparseImageMemoryBindInfo32;

typedef struct VkDeviceGroupBindSparseInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t resourceDeviceIndex;
    uint32_t memoryDeviceIndex;
} VkDeviceGroupBindSparseInfo32;
typedef VkDeviceGroupBindSparseInfo32 VkDeviceGroupBindSparseInfoKHR32;

typedef struct VkTimelineSemaphoreSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreValueCount;
    PTR32 pWaitSemaphoreValues;
    uint32_t signalSemaphoreValueCount;
    PTR32 pSignalSemaphoreValues;
} VkTimelineSemaphoreSubmitInfo32;
typedef VkTimelineSemaphoreSubmitInfo32 VkTimelineSemaphoreSubmitInfoKHR32;

typedef struct VkFrameBoundaryEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFrameBoundaryFlagsEXT flags;
    uint64_t DECLSPEC_ALIGN(8) frameID;
    uint32_t imageCount;
    PTR32 pImages;
    uint32_t bufferCount;
    PTR32 pBuffers;
    uint64_t DECLSPEC_ALIGN(8) tagName;
    PTR32 tagSize;
    PTR32 pTag;
} VkFrameBoundaryEXT32;

typedef struct VkBindSparseInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphores;
    uint32_t bufferBindCount;
    PTR32 pBufferBinds;
    uint32_t imageOpaqueBindCount;
    PTR32 pImageOpaqueBinds;
    uint32_t imageBindCount;
    PTR32 pImageBinds;
    uint32_t signalSemaphoreCount;
    PTR32 pSignalSemaphores;
} VkBindSparseInfo32;

typedef struct VkOutOfBandQueueTypeInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOutOfBandQueueTypeNV queueType;
} VkOutOfBandQueueTypeInfoNV32;

typedef struct VkPresentRegionKHR32
{
    uint32_t rectangleCount;
    PTR32 pRectangles;
} VkPresentRegionKHR32;

typedef struct VkPresentRegionsKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pRegions;
} VkPresentRegionsKHR32;

typedef struct VkDeviceGroupPresentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHR mode;
} VkDeviceGroupPresentInfoKHR32;

typedef struct VkPresentIdKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pPresentIds;
} VkPresentIdKHR32;

typedef struct VkSwapchainPresentFenceInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pFences;
} VkSwapchainPresentFenceInfoEXT32;

typedef struct VkSwapchainPresentModeInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pPresentModes;
} VkSwapchainPresentModeInfoEXT32;

typedef struct VkPresentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphores;
    uint32_t swapchainCount;
    PTR32 pSwapchains;
    PTR32 pImageIndices;
    PTR32 pResults;
} VkPresentInfoKHR32;

typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t acquireCount;
    PTR32 pAcquireSyncs;
    PTR32 pAcquireKeys;
    PTR32 pAcquireTimeouts;
    uint32_t releaseCount;
    PTR32 pReleaseSyncs;
    PTR32 pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoKHR32;

typedef struct VkD3D12FenceSubmitInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreValuesCount;
    PTR32 pWaitSemaphoreValues;
    uint32_t signalSemaphoreValuesCount;
    PTR32 pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR32;

typedef struct VkDeviceGroupSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphoreDeviceIndices;
    uint32_t commandBufferCount;
    PTR32 pCommandBufferDeviceMasks;
    uint32_t signalSemaphoreCount;
    PTR32 pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfo32;
typedef VkDeviceGroupSubmitInfo32 VkDeviceGroupSubmitInfoKHR32;

typedef struct VkProtectedSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 protectedSubmit;
} VkProtectedSubmitInfo32;

typedef struct VkPerformanceQuerySubmitInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t counterPassIndex;
} VkPerformanceQuerySubmitInfoKHR32;

typedef struct VkLatencySubmissionPresentIdNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentID;
} VkLatencySubmissionPresentIdNV32;

typedef struct VkSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphores;
    PTR32 pWaitDstStageMask;
    uint32_t commandBufferCount;
    PTR32 pCommandBuffers;
    uint32_t signalSemaphoreCount;
    PTR32 pSignalSemaphores;
} VkSubmitInfo32;

typedef struct VkSemaphoreSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    uint64_t DECLSPEC_ALIGN(8) value;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
    uint32_t deviceIndex;
} VkSemaphoreSubmitInfo32;
typedef VkSemaphoreSubmitInfo32 VkSemaphoreSubmitInfoKHR32;

typedef struct VkCommandBufferSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 commandBuffer;
    uint32_t deviceMask;
} VkCommandBufferSubmitInfo32;
typedef VkCommandBufferSubmitInfo32 VkCommandBufferSubmitInfoKHR32;

typedef struct VkSubmitInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubmitFlags flags;
    uint32_t waitSemaphoreInfoCount;
    PTR32 pWaitSemaphoreInfos;
    uint32_t commandBufferInfoCount;
    PTR32 pCommandBufferInfos;
    uint32_t signalSemaphoreInfoCount;
    PTR32 pSignalSemaphoreInfos;
} VkSubmitInfo232;
typedef VkSubmitInfo232 VkSubmitInfo2KHR32;

typedef struct VkReleaseSwapchainImagesInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
    uint32_t imageIndexCount;
    PTR32 pImageIndices;
} VkReleaseSwapchainImagesInfoEXT32;

typedef struct VkDebugUtilsObjectTagInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkObjectType objectType;
    uint64_t DECLSPEC_ALIGN(8) objectHandle;
    uint64_t DECLSPEC_ALIGN(8) tagName;
    PTR32 tagSize;
    PTR32 pTag;
} VkDebugUtilsObjectTagInfoEXT32;

typedef struct VkHdrMetadataEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkXYColorEXT displayPrimaryRed;
    VkXYColorEXT displayPrimaryGreen;
    VkXYColorEXT displayPrimaryBlue;
    VkXYColorEXT whitePoint;
    float maxLuminance;
    float minLuminance;
    float maxContentLightLevel;
    float maxFrameAverageLightLevel;
} VkHdrMetadataEXT32;

typedef struct VkSetLatencyMarkerInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentID;
    VkLatencyMarkerNV marker;
} VkSetLatencyMarkerInfoNV32;

typedef struct VkLatencySleepModeInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 lowLatencyMode;
    VkBool32 lowLatencyBoost;
    uint32_t minimumIntervalUs;
} VkLatencySleepModeInfoNV32;

typedef struct VkSemaphoreSignalInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    uint64_t DECLSPEC_ALIGN(8) value;
} VkSemaphoreSignalInfo32;
typedef VkSemaphoreSignalInfo32 VkSemaphoreSignalInfoKHR32;

typedef struct VkDeviceAddressBindingCallbackDataEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddressBindingFlagsEXT flags;
    VkDeviceAddress DECLSPEC_ALIGN(8) baseAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceAddressBindingTypeEXT bindingType;
} VkDeviceAddressBindingCallbackDataEXT32;

typedef struct VkDebugUtilsMessengerCallbackDataEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
    PTR32 pMessageIdName;
    int32_t messageIdNumber;
    PTR32 pMessage;
    uint32_t queueLabelCount;
    PTR32 pQueueLabels;
    uint32_t cmdBufLabelCount;
    PTR32 pCmdBufLabels;
    uint32_t objectCount;
    PTR32 pObjects;
} VkDebugUtilsMessengerCallbackDataEXT32;

typedef struct VkHostImageLayoutTransitionInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageLayout oldLayout;
    VkImageLayout newLayout;
    VkImageSubresourceRange subresourceRange;
} VkHostImageLayoutTransitionInfoEXT32;

typedef struct VkMemoryUnmapInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryUnmapFlagsKHR flags;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
} VkMemoryUnmapInfoKHR32;

typedef struct VkCopyDescriptorSet32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSet DECLSPEC_ALIGN(8) srcSet;
    uint32_t srcBinding;
    uint32_t srcArrayElement;
    VkDescriptorSet DECLSPEC_ALIGN(8) dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
} VkCopyDescriptorSet32;

typedef struct VkSemaphoreWaitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphoreWaitFlags flags;
    uint32_t semaphoreCount;
    PTR32 pSemaphores;
    PTR32 pValues;
} VkSemaphoreWaitInfo32;
typedef VkSemaphoreWaitInfo32 VkSemaphoreWaitInfoKHR32;

static uint64_t wine_vk_unwrap_handle(uint32_t type, uint64_t handle)
{
    switch(type)
    {
    case VK_OBJECT_TYPE_COMMAND_BUFFER:
        return (uint64_t) (uintptr_t) wine_cmd_buffer_from_handle(((VkCommandBuffer) (uintptr_t) handle))->command_buffer;
    case VK_OBJECT_TYPE_COMMAND_POOL:
        return (uint64_t) wine_cmd_pool_from_handle(handle)->command_pool;
    case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
        return (uint64_t) wine_debug_report_callback_from_handle(handle)->debug_callback;
    case VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT:
        return (uint64_t) wine_debug_utils_messenger_from_handle(handle)->debug_messenger;
    case VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR:
        return (uint64_t) wine_deferred_operation_from_handle(handle)->deferred_operation;
    case VK_OBJECT_TYPE_DEVICE:
        return (uint64_t) (uintptr_t) wine_device_from_handle(((VkDevice) (uintptr_t) handle))->device;
    case VK_OBJECT_TYPE_DEVICE_MEMORY:
        return (uint64_t) wine_device_memory_from_handle(handle)->memory;
    case VK_OBJECT_TYPE_INSTANCE:
        return (uint64_t) (uintptr_t) wine_instance_from_handle(((VkInstance) (uintptr_t) handle))->instance;
    case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
        return (uint64_t) (uintptr_t) wine_phys_dev_from_handle(((VkPhysicalDevice) (uintptr_t) handle))->phys_dev;
    case VK_OBJECT_TYPE_QUEUE:
        return (uint64_t) (uintptr_t) wine_queue_from_handle(((VkQueue) (uintptr_t) handle))->queue;
    case VK_OBJECT_TYPE_SEMAPHORE:
        return (uint64_t) wine_semaphore_host_handle( wine_semaphore_from_handle(handle) );
    case VK_OBJECT_TYPE_SURFACE_KHR:
        return (uint64_t) wine_surface_from_handle(handle)->surface;
    case VK_OBJECT_TYPE_SWAPCHAIN_KHR:
        return (uint64_t) wine_swapchain_from_handle(handle)->swapchain;
    default:
       return handle;
    }
}

#ifdef _WIN64
static inline void convert_VkAcquireNextImageInfoKHR_win64_to_host(const VkAcquireNextImageInfoKHR *in, VkAcquireNextImageInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->swapchain = in->swapchain ? wine_swapchain_from_handle(in->swapchain)->swapchain : VK_NULL_HANDLE;
    out->timeout = in->timeout;
    out->semaphore = in->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->semaphore) ) : 0;
    out->fence = in->fence;
    out->deviceMask = in->deviceMask;
}
#endif /* _WIN64 */

static inline void convert_VkAcquireNextImageInfoKHR_win32_to_host(const VkAcquireNextImageInfoKHR32 *in, VkAcquireNextImageInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->swapchain = in->swapchain ? wine_swapchain_from_handle(in->swapchain)->swapchain : VK_NULL_HANDLE;
    out->timeout = in->timeout;
    out->semaphore = in->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->semaphore) ) : 0;
    out->fence = in->fence;
    out->deviceMask = in->deviceMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPerformanceConfigurationAcquireInfoINTEL_win32_to_host(const VkPerformanceConfigurationAcquireInfoINTEL32 *in, VkPerformanceConfigurationAcquireInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAcquireProfilingLockInfoKHR_win32_to_host(const VkAcquireProfilingLockInfoKHR32 *in, VkAcquireProfilingLockInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->timeout = in->timeout;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCommandBufferAllocateInfo_win32_to_unwrapped_host(const VkCommandBufferAllocateInfo32 *in, VkCommandBufferAllocateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->commandPool = in->commandPool;
    out->level = in->level;
    out->commandBufferCount = in->commandBufferCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline VkCommandBuffer *convert_VkCommandBuffer_array_win32_to_unwrapped_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return out;
}

static inline void convert_VkDescriptorSetAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetAllocateInfo32 *in, VkDescriptorSetAllocateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorPool = in->descriptorPool;
    out->descriptorSetCount = in->descriptorSetCount;
    out->pSetLayouts = (const VkDescriptorSetLayout *)UlongToPtr(in->pSetLayouts);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            VkDescriptorSetVariableDescriptorCountAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorSetVariableDescriptorCountAllocateInfo32 *in_ext = (const VkDescriptorSetVariableDescriptorCountAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->descriptorSetCount = in_ext->descriptorSetCount;
            out_ext->pDescriptorCounts = (const uint32_t *)UlongToPtr(in_ext->pDescriptorCounts);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkMemoryAllocateInfo_win64_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo *in, VkMemoryAllocateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->allocationSize = in->allocationSize;
    out->memoryTypeIndex = in->memoryTypeIndex;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            VkDedicatedAllocationMemoryAllocateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationMemoryAllocateInfoNV *in_ext = (const VkDedicatedAllocationMemoryAllocateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            VkExportMemoryAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportMemoryAllocateInfo *in_ext = (const VkExportMemoryAllocateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            VkImportMemoryFdInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryFdInfoKHR *in_ext = (const VkImportMemoryFdInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->fd = in_ext->fd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryAllocateFlagsInfo *in_ext = (const VkMemoryAllocateFlagsInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->deviceMask = in_ext->deviceMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            VkMemoryDedicatedAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryDedicatedAllocateInfo *in_ext = (const VkMemoryDedicatedAllocateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryHostPointerInfoEXT *in_ext = (const VkImportMemoryHostPointerInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->pHostPointer = in_ext->pHostPointer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            VkMemoryPriorityAllocateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryPriorityAllocateInfoEXT *in_ext = (const VkMemoryPriorityAllocateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->priority = in_ext->priority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            VkMemoryOpaqueCaptureAddressAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryOpaqueCaptureAddressAllocateInfo *in_ext = (const VkMemoryOpaqueCaptureAddressAllocateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo32 *in, VkMemoryAllocateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->allocationSize = in->allocationSize;
    out->memoryTypeIndex = in->memoryTypeIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            VkDedicatedAllocationMemoryAllocateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationMemoryAllocateInfoNV32 *in_ext = (const VkDedicatedAllocationMemoryAllocateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            VkExportMemoryAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportMemoryAllocateInfo32 *in_ext = (const VkExportMemoryAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            VkImportMemoryFdInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryFdInfoKHR32 *in_ext = (const VkImportMemoryFdInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->fd = in_ext->fd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryAllocateFlagsInfo32 *in_ext = (const VkMemoryAllocateFlagsInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->deviceMask = in_ext->deviceMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            VkMemoryDedicatedAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryDedicatedAllocateInfo32 *in_ext = (const VkMemoryDedicatedAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryHostPointerInfoEXT32 *in_ext = (const VkImportMemoryHostPointerInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->pHostPointer = (void *)UlongToPtr(in_ext->pHostPointer);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            VkMemoryPriorityAllocateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryPriorityAllocateInfoEXT32 *in_ext = (const VkMemoryPriorityAllocateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->priority = in_ext->priority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            VkMemoryOpaqueCaptureAddressAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryOpaqueCaptureAddressAllocateInfo32 *in_ext = (const VkMemoryOpaqueCaptureAddressAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkCommandBufferInheritanceInfo_win32_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo32 *in, VkCommandBufferInheritanceInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->framebuffer = in->framebuffer;
    out->occlusionQueryEnable = in->occlusionQueryEnable;
    out->queryFlags = in->queryFlags;
    out->pipelineStatistics = in->pipelineStatistics;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            VkCommandBufferInheritanceConditionalRenderingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceConditionalRenderingInfoEXT32 *in_ext = (const VkCommandBufferInheritanceConditionalRenderingInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRenderingEnable = in_ext->conditionalRenderingEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            VkCommandBufferInheritanceRenderPassTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceRenderPassTransformInfoQCOM32 *in_ext = (const VkCommandBufferInheritanceRenderPassTransformInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_ext->renderArea = in_ext->renderArea;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
            VkCommandBufferInheritanceViewportScissorInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceViewportScissorInfoNV32 *in_ext = (const VkCommandBufferInheritanceViewportScissorInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->viewportScissor2D = in_ext->viewportScissor2D;
            out_ext->viewportDepthCount = in_ext->viewportDepthCount;
            out_ext->pViewportDepths = (const VkViewport *)UlongToPtr(in_ext->pViewportDepths);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
            VkCommandBufferInheritanceRenderingInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceRenderingInfo32 *in_ext = (const VkCommandBufferInheritanceRenderingInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = (const VkFormat *)UlongToPtr(in_ext->pColorAttachmentFormats);
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD32 *in_ext = (const VkAttachmentSampleCountInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = (const VkSampleCountFlagBits *)UlongToPtr(in_ext->pColorAttachmentSamples);
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
            VkMultiviewPerViewAttributesInfoNVX *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewAttributesInfoNVX32 *in_ext = (const VkMultiviewPerViewAttributesInfoNVX32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
            out_ext->pNext = NULL;
            out_ext->perViewAttributes = in_ext->perViewAttributes;
            out_ext->perViewAttributesPositionXOnly = in_ext->perViewAttributesPositionXOnly;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkCommandBufferInheritanceInfo *convert_VkCommandBufferInheritanceInfo_array_win32_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo32 *in, uint32_t count)
{
    VkCommandBufferInheritanceInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCommandBufferInheritanceInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCommandBufferBeginInfo_win32_to_host(struct conversion_context *ctx, const VkCommandBufferBeginInfo32 *in, VkCommandBufferBeginInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pInheritanceInfo = convert_VkCommandBufferInheritanceInfo_array_win32_to_host(ctx, (const VkCommandBufferInheritanceInfo32 *)UlongToPtr(in->pInheritanceInfo), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            VkDeviceGroupCommandBufferBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupCommandBufferBeginInfo32 *in_ext = (const VkDeviceGroupCommandBufferBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceMask = in_ext->deviceMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkBindAccelerationStructureMemoryInfoNV_win64_to_host(const VkBindAccelerationStructureMemoryInfoNV *in, VkBindAccelerationStructureMemoryInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->accelerationStructure = in->accelerationStructure;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->memoryOffset = in->memoryOffset;
    out->deviceIndexCount = in->deviceIndexCount;
    out->pDeviceIndices = in->pDeviceIndices;
}
#endif /* _WIN64 */

static inline void convert_VkBindAccelerationStructureMemoryInfoNV_win32_to_host(const VkBindAccelerationStructureMemoryInfoNV32 *in, VkBindAccelerationStructureMemoryInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructure = in->accelerationStructure;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->memoryOffset = in->memoryOffset;
    out->deviceIndexCount = in->deviceIndexCount;
    out->pDeviceIndices = (const uint32_t *)UlongToPtr(in->pDeviceIndices);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline const VkBindAccelerationStructureMemoryInfoNV *convert_VkBindAccelerationStructureMemoryInfoNV_array_win64_to_host(struct conversion_context *ctx, const VkBindAccelerationStructureMemoryInfoNV *in, uint32_t count)
{
    VkBindAccelerationStructureMemoryInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindAccelerationStructureMemoryInfoNV_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkBindAccelerationStructureMemoryInfoNV *convert_VkBindAccelerationStructureMemoryInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkBindAccelerationStructureMemoryInfoNV32 *in, uint32_t count)
{
    VkBindAccelerationStructureMemoryInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindAccelerationStructureMemoryInfoNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkBindBufferMemoryInfo_win64_to_host(const VkBindBufferMemoryInfo *in, VkBindBufferMemoryInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->buffer = in->buffer;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->memoryOffset = in->memoryOffset;
}
#endif /* _WIN64 */

static inline void convert_VkBindBufferMemoryInfo_win32_to_host(struct conversion_context *ctx, const VkBindBufferMemoryInfo32 *in, VkBindBufferMemoryInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->memoryOffset = in->memoryOffset;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            VkBindBufferMemoryDeviceGroupInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindBufferMemoryDeviceGroupInfo32 *in_ext = (const VkBindBufferMemoryDeviceGroupInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceIndexCount = in_ext->deviceIndexCount;
            out_ext->pDeviceIndices = (const uint32_t *)UlongToPtr(in_ext->pDeviceIndices);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkBindBufferMemoryInfo *convert_VkBindBufferMemoryInfo_array_win64_to_host(struct conversion_context *ctx, const VkBindBufferMemoryInfo *in, uint32_t count)
{
    VkBindBufferMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindBufferMemoryInfo_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkBindBufferMemoryInfo *convert_VkBindBufferMemoryInfo_array_win32_to_host(struct conversion_context *ctx, const VkBindBufferMemoryInfo32 *in, uint32_t count)
{
    VkBindBufferMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindBufferMemoryInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkBindImageMemoryInfo_win64_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo *in, VkBindImageMemoryInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->memoryOffset = in->memoryOffset;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            VkBindImageMemoryDeviceGroupInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemoryDeviceGroupInfo *in_ext = (const VkBindImageMemoryDeviceGroupInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceIndexCount = in_ext->deviceIndexCount;
            out_ext->pDeviceIndices = in_ext->pDeviceIndices;
            out_ext->splitInstanceBindRegionCount = in_ext->splitInstanceBindRegionCount;
            out_ext->pSplitInstanceBindRegions = in_ext->pSplitInstanceBindRegions;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            VkBindImageMemorySwapchainInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemorySwapchainInfoKHR *in_ext = (const VkBindImageMemorySwapchainInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = in_ext->swapchain ? wine_swapchain_from_handle(in_ext->swapchain)->swapchain : VK_NULL_HANDLE;
            out_ext->imageIndex = in_ext->imageIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            VkBindImagePlaneMemoryInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImagePlaneMemoryInfo *in_ext = (const VkBindImagePlaneMemoryInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
            out_ext->pNext = NULL;
            out_ext->planeAspect = in_ext->planeAspect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkBindImageMemoryInfo_win32_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo32 *in, VkBindImageMemoryInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->memoryOffset = in->memoryOffset;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            VkBindImageMemoryDeviceGroupInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemoryDeviceGroupInfo32 *in_ext = (const VkBindImageMemoryDeviceGroupInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceIndexCount = in_ext->deviceIndexCount;
            out_ext->pDeviceIndices = (const uint32_t *)UlongToPtr(in_ext->pDeviceIndices);
            out_ext->splitInstanceBindRegionCount = in_ext->splitInstanceBindRegionCount;
            out_ext->pSplitInstanceBindRegions = (const VkRect2D *)UlongToPtr(in_ext->pSplitInstanceBindRegions);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            VkBindImageMemorySwapchainInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemorySwapchainInfoKHR32 *in_ext = (const VkBindImageMemorySwapchainInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = in_ext->swapchain ? wine_swapchain_from_handle(in_ext->swapchain)->swapchain : VK_NULL_HANDLE;
            out_ext->imageIndex = in_ext->imageIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            VkBindImagePlaneMemoryInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImagePlaneMemoryInfo32 *in_ext = (const VkBindImagePlaneMemoryInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
            out_ext->pNext = NULL;
            out_ext->planeAspect = in_ext->planeAspect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkBindImageMemoryInfo *convert_VkBindImageMemoryInfo_array_win64_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo *in, uint32_t count)
{
    VkBindImageMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindImageMemoryInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkBindImageMemoryInfo *convert_VkBindImageMemoryInfo_array_win32_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo32 *in, uint32_t count)
{
    VkBindImageMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindImageMemoryInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline const VkMicromapUsageEXT * const*convert_VkMicromapUsageEXT_pointer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkMicromapUsageEXT **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return (void *)out;
}

static inline void convert_VkAccelerationStructureGeometryTrianglesDataKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryTrianglesDataKHR32 *in, VkAccelerationStructureGeometryTrianglesDataKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->vertexFormat = in->vertexFormat;
    out->vertexData = in->vertexData;
    out->vertexStride = in->vertexStride;
    out->maxVertex = in->maxVertex;
    out->indexType = in->indexType;
    out->indexData = in->indexData;
    out->transformData = in->transformData;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {
            VkAccelerationStructureGeometryMotionTrianglesDataNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureGeometryMotionTrianglesDataNV32 *in_ext = (const VkAccelerationStructureGeometryMotionTrianglesDataNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
            out_ext->pNext = NULL;
            out_ext->vertexData = in_ext->vertexData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
        {
            VkAccelerationStructureTrianglesOpacityMicromapEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureTrianglesOpacityMicromapEXT32 *in_ext = (const VkAccelerationStructureTrianglesOpacityMicromapEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT;
            out_ext->pNext = NULL;
            out_ext->indexType = in_ext->indexType;
            out_ext->indexBuffer = in_ext->indexBuffer;
            out_ext->indexStride = in_ext->indexStride;
            out_ext->baseTriangle = in_ext->baseTriangle;
            out_ext->usageCountsCount = in_ext->usageCountsCount;
            out_ext->pUsageCounts = (const VkMicromapUsageEXT *)UlongToPtr(in_ext->pUsageCounts);
            out_ext->ppUsageCounts = convert_VkMicromapUsageEXT_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in_ext->ppUsageCounts), in_ext->usageCountsCount);
            out_ext->micromap = in_ext->micromap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkAccelerationStructureGeometryAabbsDataKHR_win32_to_host(const VkAccelerationStructureGeometryAabbsDataKHR32 *in, VkAccelerationStructureGeometryAabbsDataKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->data = in->data;
    out->stride = in->stride;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAccelerationStructureGeometryInstancesDataKHR_win32_to_host(const VkAccelerationStructureGeometryInstancesDataKHR32 *in, VkAccelerationStructureGeometryInstancesDataKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->arrayOfPointers = in->arrayOfPointers;
    out->data = in->data;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAccelerationStructureGeometryDataKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryDataKHR32 *in, VkAccelerationStructureGeometryDataKHR *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_GEOMETRY_TYPE_TRIANGLES_KHR)
        convert_VkAccelerationStructureGeometryTrianglesDataKHR_win32_to_host(ctx, &in->triangles, &out->triangles);
    if (selector == VK_GEOMETRY_TYPE_AABBS_KHR)
        convert_VkAccelerationStructureGeometryAabbsDataKHR_win32_to_host(&in->aabbs, &out->aabbs);
    if (selector == VK_GEOMETRY_TYPE_INSTANCES_KHR)
        convert_VkAccelerationStructureGeometryInstancesDataKHR_win32_to_host(&in->instances, &out->instances);
}

static inline void convert_VkAccelerationStructureGeometryKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryKHR32 *in, VkAccelerationStructureGeometryKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->geometryType = in->geometryType;
    convert_VkAccelerationStructureGeometryDataKHR_win32_to_host(ctx, &in->geometry, &out->geometry, in->geometryType);
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkAccelerationStructureGeometryKHR *convert_VkAccelerationStructureGeometryKHR_array_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryKHR32 *in, uint32_t count)
{
    VkAccelerationStructureGeometryKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAccelerationStructureGeometryKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline const VkAccelerationStructureGeometryKHR * const*convert_VkAccelerationStructureGeometryKHR_pointer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkAccelerationStructureGeometryKHR **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        if (in[i])
        {
            out[i] = conversion_context_alloc(ctx, sizeof(*out[i]));
            convert_VkAccelerationStructureGeometryKHR_win32_to_host(ctx, (VkAccelerationStructureGeometryKHR32 *)UlongToPtr(in[i]), out[i]);
        }
        else
            out[i] = NULL;
    }

    return (void *)out;
}

static inline void convert_VkAccelerationStructureBuildGeometryInfoKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureBuildGeometryInfoKHR32 *in, VkAccelerationStructureBuildGeometryInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->flags = in->flags;
    out->mode = in->mode;
    out->srcAccelerationStructure = in->srcAccelerationStructure;
    out->dstAccelerationStructure = in->dstAccelerationStructure;
    out->geometryCount = in->geometryCount;
    out->pGeometries = convert_VkAccelerationStructureGeometryKHR_array_win32_to_host(ctx, (const VkAccelerationStructureGeometryKHR32 *)UlongToPtr(in->pGeometries), in->geometryCount);
    out->ppGeometries = convert_VkAccelerationStructureGeometryKHR_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppGeometries), in->geometryCount);
    out->scratchData = in->scratchData;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkAccelerationStructureBuildGeometryInfoKHR *convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureBuildGeometryInfoKHR32 *in, uint32_t count)
{
    VkAccelerationStructureBuildGeometryInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAccelerationStructureBuildGeometryInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkMicromapBuildInfoEXT_win32_to_host(struct conversion_context *ctx, const VkMicromapBuildInfoEXT32 *in, VkMicromapBuildInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->flags = in->flags;
    out->mode = in->mode;
    out->dstMicromap = in->dstMicromap;
    out->usageCountsCount = in->usageCountsCount;
    out->pUsageCounts = (const VkMicromapUsageEXT *)UlongToPtr(in->pUsageCounts);
    out->ppUsageCounts = convert_VkMicromapUsageEXT_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppUsageCounts), in->usageCountsCount);
    out->data = in->data;
    out->scratchData = in->scratchData;
    out->triangleArray = in->triangleArray;
    out->triangleArrayStride = in->triangleArrayStride;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkMicromapBuildInfoEXT *convert_VkMicromapBuildInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkMicromapBuildInfoEXT32 *in, uint32_t count)
{
    VkMicromapBuildInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMicromapBuildInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkConditionalRenderingBeginInfoEXT_win32_to_host(const VkConditionalRenderingBeginInfoEXT32 *in, VkConditionalRenderingBeginInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDebugUtilsLabelEXT_win32_to_host(const VkDebugUtilsLabelEXT32 *in, VkDebugUtilsLabelEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pLabelName = (const char *)UlongToPtr(in->pLabelName);
    memcpy(out->color, in->color, 4 * sizeof(float));
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSampleLocationsInfoEXT_win32_to_host(const VkSampleLocationsInfoEXT32 *in, VkSampleLocationsInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->sampleLocationsPerPixel = in->sampleLocationsPerPixel;
    out->sampleLocationGridSize = in->sampleLocationGridSize;
    out->sampleLocationsCount = in->sampleLocationsCount;
    out->pSampleLocations = (const VkSampleLocationEXT *)UlongToPtr(in->pSampleLocations);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAttachmentSampleLocationsEXT_win32_to_host(const VkAttachmentSampleLocationsEXT32 *in, VkAttachmentSampleLocationsEXT *out)
{
    if (!in) return;

    out->attachmentIndex = in->attachmentIndex;
    convert_VkSampleLocationsInfoEXT_win32_to_host(&in->sampleLocationsInfo, &out->sampleLocationsInfo);
}

static inline const VkAttachmentSampleLocationsEXT *convert_VkAttachmentSampleLocationsEXT_array_win32_to_host(struct conversion_context *ctx, const VkAttachmentSampleLocationsEXT32 *in, uint32_t count)
{
    VkAttachmentSampleLocationsEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAttachmentSampleLocationsEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSubpassSampleLocationsEXT_win32_to_host(const VkSubpassSampleLocationsEXT32 *in, VkSubpassSampleLocationsEXT *out)
{
    if (!in) return;

    out->subpassIndex = in->subpassIndex;
    convert_VkSampleLocationsInfoEXT_win32_to_host(&in->sampleLocationsInfo, &out->sampleLocationsInfo);
}

static inline const VkSubpassSampleLocationsEXT *convert_VkSubpassSampleLocationsEXT_array_win32_to_host(struct conversion_context *ctx, const VkSubpassSampleLocationsEXT32 *in, uint32_t count)
{
    VkSubpassSampleLocationsEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassSampleLocationsEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRenderPassBeginInfo_win32_to_host(struct conversion_context *ctx, const VkRenderPassBeginInfo32 *in, VkRenderPassBeginInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->renderPass = in->renderPass;
    out->framebuffer = in->framebuffer;
    out->renderArea = in->renderArea;
    out->clearValueCount = in->clearValueCount;
    out->pClearValues = (const VkClearValue *)UlongToPtr(in->pClearValues);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            VkDeviceGroupRenderPassBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupRenderPassBeginInfo32 *in_ext = (const VkDeviceGroupRenderPassBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceMask = in_ext->deviceMask;
            out_ext->deviceRenderAreaCount = in_ext->deviceRenderAreaCount;
            out_ext->pDeviceRenderAreas = (const VkRect2D *)UlongToPtr(in_ext->pDeviceRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            VkRenderPassSampleLocationsBeginInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassSampleLocationsBeginInfoEXT32 *in_ext = (const VkRenderPassSampleLocationsBeginInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentInitialSampleLocationsCount = in_ext->attachmentInitialSampleLocationsCount;
            out_ext->pAttachmentInitialSampleLocations = convert_VkAttachmentSampleLocationsEXT_array_win32_to_host(ctx, (const VkAttachmentSampleLocationsEXT32 *)UlongToPtr(in_ext->pAttachmentInitialSampleLocations), in_ext->attachmentInitialSampleLocationsCount);
            out_ext->postSubpassSampleLocationsCount = in_ext->postSubpassSampleLocationsCount;
            out_ext->pPostSubpassSampleLocations = convert_VkSubpassSampleLocationsEXT_array_win32_to_host(ctx, (const VkSubpassSampleLocationsEXT32 *)UlongToPtr(in_ext->pPostSubpassSampleLocations), in_ext->postSubpassSampleLocationsCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            VkRenderPassAttachmentBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassAttachmentBeginInfo32 *in_ext = (const VkRenderPassAttachmentBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->attachmentCount = in_ext->attachmentCount;
            out_ext->pAttachments = (const VkImageView *)UlongToPtr(in_ext->pAttachments);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            VkRenderPassTransformBeginInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTransformBeginInfoQCOM32 *in_ext = (const VkRenderPassTransformBeginInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
            VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *in_ext = (const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->perViewRenderAreaCount = in_ext->perViewRenderAreaCount;
            out_ext->pPerViewRenderAreas = (const VkRect2D *)UlongToPtr(in_ext->pPerViewRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSubpassBeginInfo_win32_to_host(const VkSubpassBeginInfo32 *in, VkSubpassBeginInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->contents = in->contents;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkRenderingAttachmentInfo_win32_to_host(const VkRenderingAttachmentInfo32 *in, VkRenderingAttachmentInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageView = in->imageView;
    out->imageLayout = in->imageLayout;
    out->resolveMode = in->resolveMode;
    out->resolveImageView = in->resolveImageView;
    out->resolveImageLayout = in->resolveImageLayout;
    out->loadOp = in->loadOp;
    out->storeOp = in->storeOp;
    out->clearValue = in->clearValue;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkRenderingAttachmentInfo *convert_VkRenderingAttachmentInfo_array_win32_to_host(struct conversion_context *ctx, const VkRenderingAttachmentInfo32 *in, uint32_t count)
{
    VkRenderingAttachmentInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRenderingAttachmentInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRenderingInfo_win32_to_host(struct conversion_context *ctx, const VkRenderingInfo32 *in, VkRenderingInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->renderArea = in->renderArea;
    out->layerCount = in->layerCount;
    out->viewMask = in->viewMask;
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachments = convert_VkRenderingAttachmentInfo_array_win32_to_host(ctx, (const VkRenderingAttachmentInfo32 *)UlongToPtr(in->pColorAttachments), in->colorAttachmentCount);
    out->pDepthAttachment = convert_VkRenderingAttachmentInfo_array_win32_to_host(ctx, (const VkRenderingAttachmentInfo32 *)UlongToPtr(in->pDepthAttachment), 1);
    out->pStencilAttachment = convert_VkRenderingAttachmentInfo_array_win32_to_host(ctx, (const VkRenderingAttachmentInfo32 *)UlongToPtr(in->pStencilAttachment), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            VkDeviceGroupRenderPassBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupRenderPassBeginInfo32 *in_ext = (const VkDeviceGroupRenderPassBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceMask = in_ext->deviceMask;
            out_ext->deviceRenderAreaCount = in_ext->deviceRenderAreaCount;
            out_ext->pDeviceRenderAreas = (const VkRect2D *)UlongToPtr(in_ext->pDeviceRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
            VkMultisampledRenderToSingleSampledInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultisampledRenderToSingleSampledInfoEXT32 *in_ext = (const VkMultisampledRenderToSingleSampledInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampledEnable = in_ext->multisampledRenderToSingleSampledEnable;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            VkRenderingFragmentShadingRateAttachmentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingFragmentShadingRateAttachmentInfoKHR32 *in_ext = (const VkRenderingFragmentShadingRateAttachmentInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->imageView = in_ext->imageView;
            out_ext->imageLayout = in_ext->imageLayout;
            out_ext->shadingRateAttachmentTexelSize = in_ext->shadingRateAttachmentTexelSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
        {
            VkRenderingFragmentDensityMapAttachmentInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingFragmentDensityMapAttachmentInfoEXT32 *in_ext = (const VkRenderingFragmentDensityMapAttachmentInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->imageView = in_ext->imageView;
            out_ext->imageLayout = in_ext->imageLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
            VkMultiviewPerViewAttributesInfoNVX *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewAttributesInfoNVX32 *in_ext = (const VkMultiviewPerViewAttributesInfoNVX32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
            out_ext->pNext = NULL;
            out_ext->perViewAttributes = in_ext->perViewAttributes;
            out_ext->perViewAttributesPositionXOnly = in_ext->perViewAttributesPositionXOnly;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
            VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *in_ext = (const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->perViewRenderAreaCount = in_ext->perViewRenderAreaCount;
            out_ext->pPerViewRenderAreas = (const VkRect2D *)UlongToPtr(in_ext->pPerViewRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkDescriptorBufferBindingInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorBufferBindingInfoEXT32 *in, VkDescriptorBufferBindingInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->address = in->address;
    out->usage = in->usage;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkBufferUsageFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfoKHR32 *in_ext = (const VkBufferUsageFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
        {
            VkDescriptorBufferBindingPushDescriptorBufferHandleEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32 *in_ext = (const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT;
            out_ext->pNext = NULL;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkDescriptorBufferBindingInfoEXT *convert_VkDescriptorBufferBindingInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorBufferBindingInfoEXT32 *in, uint32_t count)
{
    VkDescriptorBufferBindingInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorBufferBindingInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkImageBlit2_win32_to_host(struct conversion_context *ctx, const VkImageBlit232 *in, VkImageBlit2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubresource = in->srcSubresource;
    memcpy(out->srcOffsets, in->srcOffsets, 2 * sizeof(VkOffset3D));
    out->dstSubresource = in->dstSubresource;
    memcpy(out->dstOffsets, in->dstOffsets, 2 * sizeof(VkOffset3D));

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            VkCopyCommandTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCopyCommandTransformInfoQCOM32 *in_ext = (const VkCopyCommandTransformInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkImageBlit2 *convert_VkImageBlit2_array_win32_to_host(struct conversion_context *ctx, const VkImageBlit232 *in, uint32_t count)
{
    VkImageBlit2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageBlit2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkBlitImageInfo2_win32_to_host(struct conversion_context *ctx, const VkBlitImageInfo232 *in, VkBlitImageInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageBlit2_array_win32_to_host(ctx, (const VkImageBlit232 *)UlongToPtr(in->pRegions), in->regionCount);
    out->filter = in->filter;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
        {
            VkBlitImageCubicWeightsInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBlitImageCubicWeightsInfoQCOM32 *in_ext = (const VkBlitImageCubicWeightsInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicWeights = in_ext->cubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkGeometryTrianglesNV_win32_to_host(const VkGeometryTrianglesNV32 *in, VkGeometryTrianglesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->vertexData = in->vertexData;
    out->vertexOffset = in->vertexOffset;
    out->vertexCount = in->vertexCount;
    out->vertexStride = in->vertexStride;
    out->vertexFormat = in->vertexFormat;
    out->indexData = in->indexData;
    out->indexOffset = in->indexOffset;
    out->indexCount = in->indexCount;
    out->indexType = in->indexType;
    out->transformData = in->transformData;
    out->transformOffset = in->transformOffset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkGeometryAABBNV_win32_to_host(const VkGeometryAABBNV32 *in, VkGeometryAABBNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->aabbData = in->aabbData;
    out->numAABBs = in->numAABBs;
    out->stride = in->stride;
    out->offset = in->offset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkGeometryDataNV_win32_to_host(const VkGeometryDataNV32 *in, VkGeometryDataNV *out)
{
    if (!in) return;

    convert_VkGeometryTrianglesNV_win32_to_host(&in->triangles, &out->triangles);
    convert_VkGeometryAABBNV_win32_to_host(&in->aabbs, &out->aabbs);
}

static inline void convert_VkGeometryNV_win32_to_host(const VkGeometryNV32 *in, VkGeometryNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->geometryType = in->geometryType;
    convert_VkGeometryDataNV_win32_to_host(&in->geometry, &out->geometry);
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkGeometryNV *convert_VkGeometryNV_array_win32_to_host(struct conversion_context *ctx, const VkGeometryNV32 *in, uint32_t count)
{
    VkGeometryNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGeometryNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkAccelerationStructureInfoNV_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureInfoNV32 *in, VkAccelerationStructureInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->flags = in->flags;
    out->instanceCount = in->instanceCount;
    out->geometryCount = in->geometryCount;
    out->pGeometries = convert_VkGeometryNV_array_win32_to_host(ctx, (const VkGeometryNV32 *)UlongToPtr(in->pGeometries), in->geometryCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyAccelerationStructureInfoKHR_win32_to_host(const VkCopyAccelerationStructureInfoKHR32 *in, VkCopyAccelerationStructureInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host(const VkCopyAccelerationStructureToMemoryInfoKHR32 *in, VkCopyAccelerationStructureToMemoryInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkBufferCopy_win32_to_host(const VkBufferCopy32 *in, VkBufferCopy *out)
{
    if (!in) return;

    out->srcOffset = in->srcOffset;
    out->dstOffset = in->dstOffset;
    out->size = in->size;
}

static inline const VkBufferCopy *convert_VkBufferCopy_array_win32_to_host(struct conversion_context *ctx, const VkBufferCopy32 *in, uint32_t count)
{
    VkBufferCopy *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCopy_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkBufferCopy2_win32_to_host(const VkBufferCopy232 *in, VkBufferCopy2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcOffset = in->srcOffset;
    out->dstOffset = in->dstOffset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkBufferCopy2 *convert_VkBufferCopy2_array_win32_to_host(struct conversion_context *ctx, const VkBufferCopy232 *in, uint32_t count)
{
    VkBufferCopy2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCopy2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCopyBufferInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyBufferInfo232 *in, VkCopyBufferInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcBuffer = in->srcBuffer;
    out->dstBuffer = in->dstBuffer;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkBufferCopy2_array_win32_to_host(ctx, (const VkBufferCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkBufferImageCopy_win32_to_host(const VkBufferImageCopy32 *in, VkBufferImageCopy *out)
{
    if (!in) return;

    out->bufferOffset = in->bufferOffset;
    out->bufferRowLength = in->bufferRowLength;
    out->bufferImageHeight = in->bufferImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;
}

static inline const VkBufferImageCopy *convert_VkBufferImageCopy_array_win32_to_host(struct conversion_context *ctx, const VkBufferImageCopy32 *in, uint32_t count)
{
    VkBufferImageCopy *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferImageCopy_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkBufferImageCopy2_win32_to_host(struct conversion_context *ctx, const VkBufferImageCopy232 *in, VkBufferImageCopy2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->bufferOffset = in->bufferOffset;
    out->bufferRowLength = in->bufferRowLength;
    out->bufferImageHeight = in->bufferImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            VkCopyCommandTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCopyCommandTransformInfoQCOM32 *in_ext = (const VkCopyCommandTransformInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkBufferImageCopy2 *convert_VkBufferImageCopy2_array_win32_to_host(struct conversion_context *ctx, const VkBufferImageCopy232 *in, uint32_t count)
{
    VkBufferImageCopy2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferImageCopy2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCopyBufferToImageInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyBufferToImageInfo232 *in, VkCopyBufferToImageInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcBuffer = in->srcBuffer;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkBufferImageCopy2_array_win32_to_host(ctx, (const VkBufferImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImageCopy2_win32_to_host(const VkImageCopy232 *in, VkImageCopy2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubresource = in->srcSubresource;
    out->srcOffset = in->srcOffset;
    out->dstSubresource = in->dstSubresource;
    out->dstOffset = in->dstOffset;
    out->extent = in->extent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkImageCopy2 *convert_VkImageCopy2_array_win32_to_host(struct conversion_context *ctx, const VkImageCopy232 *in, uint32_t count)
{
    VkImageCopy2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageCopy2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCopyImageInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyImageInfo232 *in, VkCopyImageInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageCopy2_array_win32_to_host(ctx, (const VkImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyImageToBufferInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyImageToBufferInfo232 *in, VkCopyImageToBufferInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstBuffer = in->dstBuffer;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkBufferImageCopy2_array_win32_to_host(ctx, (const VkBufferImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host(const VkCopyMemoryToAccelerationStructureInfoKHR32 *in, VkCopyMemoryToAccelerationStructureInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host(const VkCopyMemoryToMicromapInfoEXT32 *in, VkCopyMemoryToMicromapInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyMicromapInfoEXT_win32_to_host(const VkCopyMicromapInfoEXT32 *in, VkCopyMicromapInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host(const VkCopyMicromapToMemoryInfoEXT32 *in, VkCopyMicromapToMemoryInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCuLaunchInfoNVX_win32_to_host(const VkCuLaunchInfoNVX32 *in, VkCuLaunchInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->function = in->function;
    out->gridDimX = in->gridDimX;
    out->gridDimY = in->gridDimY;
    out->gridDimZ = in->gridDimZ;
    out->blockDimX = in->blockDimX;
    out->blockDimY = in->blockDimY;
    out->blockDimZ = in->blockDimZ;
    out->sharedMemBytes = in->sharedMemBytes;
    out->paramCount = in->paramCount;
    out->pParams = (const void * const *)UlongToPtr(in->pParams);
    out->extraCount = in->extraCount;
    out->pExtras = (const void * const *)UlongToPtr(in->pExtras);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDebugMarkerMarkerInfoEXT_win32_to_host(const VkDebugMarkerMarkerInfoEXT32 *in, VkDebugMarkerMarkerInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pMarkerName = (const char *)UlongToPtr(in->pMarkerName);
    memcpy(out->color, in->color, 4 * sizeof(float));
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDecompressMemoryRegionNV_win32_to_host(const VkDecompressMemoryRegionNV32 *in, VkDecompressMemoryRegionNV *out)
{
    if (!in) return;

    out->srcAddress = in->srcAddress;
    out->dstAddress = in->dstAddress;
    out->compressedSize = in->compressedSize;
    out->decompressedSize = in->decompressedSize;
    out->decompressionMethod = in->decompressionMethod;
}

static inline const VkDecompressMemoryRegionNV *convert_VkDecompressMemoryRegionNV_array_win32_to_host(struct conversion_context *ctx, const VkDecompressMemoryRegionNV32 *in, uint32_t count)
{
    VkDecompressMemoryRegionNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDecompressMemoryRegionNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSubpassEndInfo_win32_to_host(struct conversion_context *ctx, const VkSubpassEndInfo32 *in, VkSubpassEndInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
        {
            VkSubpassFragmentDensityMapOffsetEndInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSubpassFragmentDensityMapOffsetEndInfoQCOM32 *in_ext = (const VkSubpassFragmentDensityMapOffsetEndInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityOffsetCount = in_ext->fragmentDensityOffsetCount;
            out_ext->pFragmentDensityOffsets = (const VkOffset2D *)UlongToPtr(in_ext->pFragmentDensityOffsets);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkCommandBuffer *convert_VkCommandBuffer_array_win64_to_host(struct conversion_context *ctx, const VkCommandBuffer *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_cmd_buffer_from_handle(in[i])->command_buffer;
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkCommandBuffer *convert_VkCommandBuffer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_cmd_buffer_from_handle(UlongToPtr(in[i]))->command_buffer;
    }

    return out;
}

static inline void convert_VkIndirectCommandsStreamNV_win32_to_host(const VkIndirectCommandsStreamNV32 *in, VkIndirectCommandsStreamNV *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->offset = in->offset;
}

static inline const VkIndirectCommandsStreamNV *convert_VkIndirectCommandsStreamNV_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsStreamNV32 *in, uint32_t count)
{
    VkIndirectCommandsStreamNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectCommandsStreamNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkGeneratedCommandsInfoNV_win32_to_host(struct conversion_context *ctx, const VkGeneratedCommandsInfoNV32 *in, VkGeneratedCommandsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipeline = in->pipeline;
    out->indirectCommandsLayout = in->indirectCommandsLayout;
    out->streamCount = in->streamCount;
    out->pStreams = convert_VkIndirectCommandsStreamNV_array_win32_to_host(ctx, (const VkIndirectCommandsStreamNV32 *)UlongToPtr(in->pStreams), in->streamCount);
    out->sequencesCount = in->sequencesCount;
    out->preprocessBuffer = in->preprocessBuffer;
    out->preprocessOffset = in->preprocessOffset;
    out->preprocessSize = in->preprocessSize;
    out->sequencesCountBuffer = in->sequencesCountBuffer;
    out->sequencesCountOffset = in->sequencesCountOffset;
    out->sequencesIndexBuffer = in->sequencesIndexBuffer;
    out->sequencesIndexOffset = in->sequencesIndexOffset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkOpticalFlowExecuteInfoNV_win32_to_host(const VkOpticalFlowExecuteInfoNV32 *in, VkOpticalFlowExecuteInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->regionCount = in->regionCount;
    out->pRegions = (const VkRect2D *)UlongToPtr(in->pRegions);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryBarrier_win32_to_host(const VkMemoryBarrier32 *in, VkMemoryBarrier *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkMemoryBarrier *convert_VkMemoryBarrier_array_win32_to_host(struct conversion_context *ctx, const VkMemoryBarrier32 *in, uint32_t count)
{
    VkMemoryBarrier *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMemoryBarrier_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkBufferMemoryBarrier_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier32 *in, VkBufferMemoryBarrier *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkBufferMemoryBarrier *convert_VkBufferMemoryBarrier_array_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier32 *in, uint32_t count)
{
    VkBufferMemoryBarrier *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferMemoryBarrier_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkImageMemoryBarrier_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier32 *in, VkImageMemoryBarrier *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    out->oldLayout = in->oldLayout;
    out->newLayout = in->newLayout;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->image = in->image;
    out->subresourceRange = in->subresourceRange;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            VkSampleLocationsInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSampleLocationsInfoEXT32 *in_ext = (const VkSampleLocationsInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sampleLocationsPerPixel = in_ext->sampleLocationsPerPixel;
            out_ext->sampleLocationGridSize = in_ext->sampleLocationGridSize;
            out_ext->sampleLocationsCount = in_ext->sampleLocationsCount;
            out_ext->pSampleLocations = (const VkSampleLocationEXT *)UlongToPtr(in_ext->pSampleLocations);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkImageMemoryBarrier *convert_VkImageMemoryBarrier_array_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier32 *in, uint32_t count)
{
    VkImageMemoryBarrier *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageMemoryBarrier_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkMemoryBarrier2_win32_to_host(const VkMemoryBarrier232 *in, VkMemoryBarrier2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkMemoryBarrier2 *convert_VkMemoryBarrier2_array_win32_to_host(struct conversion_context *ctx, const VkMemoryBarrier232 *in, uint32_t count)
{
    VkMemoryBarrier2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMemoryBarrier2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkBufferMemoryBarrier2_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier232 *in, VkBufferMemoryBarrier2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkBufferMemoryBarrier2 *convert_VkBufferMemoryBarrier2_array_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier232 *in, uint32_t count)
{
    VkBufferMemoryBarrier2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferMemoryBarrier2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkImageMemoryBarrier2_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier232 *in, VkImageMemoryBarrier2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    out->oldLayout = in->oldLayout;
    out->newLayout = in->newLayout;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->image = in->image;
    out->subresourceRange = in->subresourceRange;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            VkSampleLocationsInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSampleLocationsInfoEXT32 *in_ext = (const VkSampleLocationsInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sampleLocationsPerPixel = in_ext->sampleLocationsPerPixel;
            out_ext->sampleLocationGridSize = in_ext->sampleLocationGridSize;
            out_ext->sampleLocationsCount = in_ext->sampleLocationsCount;
            out_ext->pSampleLocations = (const VkSampleLocationEXT *)UlongToPtr(in_ext->pSampleLocations);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkImageMemoryBarrier2 *convert_VkImageMemoryBarrier2_array_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier232 *in, uint32_t count)
{
    VkImageMemoryBarrier2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageMemoryBarrier2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDependencyInfo_win32_to_host(struct conversion_context *ctx, const VkDependencyInfo32 *in, VkDependencyInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dependencyFlags = in->dependencyFlags;
    out->memoryBarrierCount = in->memoryBarrierCount;
    out->pMemoryBarriers = convert_VkMemoryBarrier2_array_win32_to_host(ctx, (const VkMemoryBarrier232 *)UlongToPtr(in->pMemoryBarriers), in->memoryBarrierCount);
    out->bufferMemoryBarrierCount = in->bufferMemoryBarrierCount;
    out->pBufferMemoryBarriers = convert_VkBufferMemoryBarrier2_array_win32_to_host(ctx, (const VkBufferMemoryBarrier232 *)UlongToPtr(in->pBufferMemoryBarriers), in->bufferMemoryBarrierCount);
    out->imageMemoryBarrierCount = in->imageMemoryBarrierCount;
    out->pImageMemoryBarriers = convert_VkImageMemoryBarrier2_array_win32_to_host(ctx, (const VkImageMemoryBarrier232 *)UlongToPtr(in->pImageMemoryBarriers), in->imageMemoryBarrierCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDescriptorImageInfo_win32_to_host(const VkDescriptorImageInfo32 *in, VkDescriptorImageInfo *out)
{
    if (!in) return;

    out->sampler = in->sampler;
    out->imageView = in->imageView;
    out->imageLayout = in->imageLayout;
}

static inline const VkDescriptorImageInfo *convert_VkDescriptorImageInfo_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorImageInfo32 *in, uint32_t count)
{
    VkDescriptorImageInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorImageInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDescriptorBufferInfo_win32_to_host(const VkDescriptorBufferInfo32 *in, VkDescriptorBufferInfo *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->offset = in->offset;
    out->range = in->range;
}

static inline const VkDescriptorBufferInfo *convert_VkDescriptorBufferInfo_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorBufferInfo32 *in, uint32_t count)
{
    VkDescriptorBufferInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorBufferInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkWriteDescriptorSet_win32_to_host(struct conversion_context *ctx, const VkWriteDescriptorSet32 *in, VkWriteDescriptorSet *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dstSet = in->dstSet;
    out->dstBinding = in->dstBinding;
    out->dstArrayElement = in->dstArrayElement;
    out->descriptorCount = in->descriptorCount;
    out->descriptorType = in->descriptorType;
    out->pImageInfo = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pImageInfo), in->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER || in->descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER || in->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE || in->descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE || in->descriptorType == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT || in->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM || in->descriptorType == VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM ? in->descriptorCount : 0);
    out->pBufferInfo = convert_VkDescriptorBufferInfo_array_win32_to_host(ctx, (const VkDescriptorBufferInfo32 *)UlongToPtr(in->pBufferInfo), in->descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER || in->descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER || in->descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC || in->descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC ? in->descriptorCount : 0);
    out->pTexelBufferView = (const VkBufferView *)UlongToPtr(in->pTexelBufferView);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
        {
            VkWriteDescriptorSetInlineUniformBlock *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetInlineUniformBlock32 *in_ext = (const VkWriteDescriptorSetInlineUniformBlock32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
            out_ext->pNext = NULL;
            out_ext->dataSize = in_ext->dataSize;
            out_ext->pData = (const void *)UlongToPtr(in_ext->pData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            VkWriteDescriptorSetAccelerationStructureKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetAccelerationStructureKHR32 *in_ext = (const VkWriteDescriptorSetAccelerationStructureKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructureCount = in_ext->accelerationStructureCount;
            out_ext->pAccelerationStructures = (const VkAccelerationStructureKHR *)UlongToPtr(in_ext->pAccelerationStructures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            VkWriteDescriptorSetAccelerationStructureNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetAccelerationStructureNV32 *in_ext = (const VkWriteDescriptorSetAccelerationStructureNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
            out_ext->pNext = NULL;
            out_ext->accelerationStructureCount = in_ext->accelerationStructureCount;
            out_ext->pAccelerationStructures = (const VkAccelerationStructureNV *)UlongToPtr(in_ext->pAccelerationStructures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkWriteDescriptorSet *convert_VkWriteDescriptorSet_array_win32_to_host(struct conversion_context *ctx, const VkWriteDescriptorSet32 *in, uint32_t count)
{
    VkWriteDescriptorSet *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkWriteDescriptorSet_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkImageResolve2_win32_to_host(const VkImageResolve232 *in, VkImageResolve2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubresource = in->srcSubresource;
    out->srcOffset = in->srcOffset;
    out->dstSubresource = in->dstSubresource;
    out->dstOffset = in->dstOffset;
    out->extent = in->extent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkImageResolve2 *convert_VkImageResolve2_array_win32_to_host(struct conversion_context *ctx, const VkImageResolve232 *in, uint32_t count)
{
    VkImageResolve2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageResolve2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkResolveImageInfo2_win32_to_host(struct conversion_context *ctx, const VkResolveImageInfo232 *in, VkResolveImageInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageResolve2_array_win32_to_host(ctx, (const VkImageResolve232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCoarseSampleOrderCustomNV_win32_to_host(const VkCoarseSampleOrderCustomNV32 *in, VkCoarseSampleOrderCustomNV *out)
{
    if (!in) return;

    out->shadingRate = in->shadingRate;
    out->sampleCount = in->sampleCount;
    out->sampleLocationCount = in->sampleLocationCount;
    out->pSampleLocations = (const VkCoarseSampleLocationNV *)UlongToPtr(in->pSampleLocations);
}

static inline const VkCoarseSampleOrderCustomNV *convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(struct conversion_context *ctx, const VkCoarseSampleOrderCustomNV32 *in, uint32_t count)
{
    VkCoarseSampleOrderCustomNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCoarseSampleOrderCustomNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDepthBiasInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDepthBiasInfoEXT32 *in, VkDepthBiasInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->depthBiasConstantFactor = in->depthBiasConstantFactor;
    out->depthBiasClamp = in->depthBiasClamp;
    out->depthBiasSlopeFactor = in->depthBiasSlopeFactor;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
            VkDepthBiasRepresentationInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDepthBiasRepresentationInfoEXT32 *in_ext = (const VkDepthBiasRepresentationInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasRepresentation = in_ext->depthBiasRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkPerformanceMarkerInfoINTEL_win32_to_host(const VkPerformanceMarkerInfoINTEL32 *in, VkPerformanceMarkerInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->marker = in->marker;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPerformanceOverrideInfoINTEL_win32_to_host(const VkPerformanceOverrideInfoINTEL32 *in, VkPerformanceOverrideInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->enable = in->enable;
    out->parameter = in->parameter;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPerformanceStreamMarkerInfoINTEL_win32_to_host(const VkPerformanceStreamMarkerInfoINTEL32 *in, VkPerformanceStreamMarkerInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->marker = in->marker;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkVertexInputBindingDescription2EXT_win32_to_host(const VkVertexInputBindingDescription2EXT32 *in, VkVertexInputBindingDescription2EXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->binding = in->binding;
    out->stride = in->stride;
    out->inputRate = in->inputRate;
    out->divisor = in->divisor;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkVertexInputBindingDescription2EXT *convert_VkVertexInputBindingDescription2EXT_array_win32_to_host(struct conversion_context *ctx, const VkVertexInputBindingDescription2EXT32 *in, uint32_t count)
{
    VkVertexInputBindingDescription2EXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVertexInputBindingDescription2EXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkVertexInputAttributeDescription2EXT_win32_to_host(const VkVertexInputAttributeDescription2EXT32 *in, VkVertexInputAttributeDescription2EXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->location = in->location;
    out->binding = in->binding;
    out->format = in->format;
    out->offset = in->offset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkVertexInputAttributeDescription2EXT *convert_VkVertexInputAttributeDescription2EXT_array_win32_to_host(struct conversion_context *ctx, const VkVertexInputAttributeDescription2EXT32 *in, uint32_t count)
{
    VkVertexInputAttributeDescription2EXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVertexInputAttributeDescription2EXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkShadingRatePaletteNV_win32_to_host(const VkShadingRatePaletteNV32 *in, VkShadingRatePaletteNV *out)
{
    if (!in) return;

    out->shadingRatePaletteEntryCount = in->shadingRatePaletteEntryCount;
    out->pShadingRatePaletteEntries = (const VkShadingRatePaletteEntryNV *)UlongToPtr(in->pShadingRatePaletteEntries);
}

static inline const VkShadingRatePaletteNV *convert_VkShadingRatePaletteNV_array_win32_to_host(struct conversion_context *ctx, const VkShadingRatePaletteNV32 *in, uint32_t count)
{
    VkShadingRatePaletteNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkShadingRatePaletteNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkStridedDeviceAddressRegionKHR_win32_to_host(const VkStridedDeviceAddressRegionKHR32 *in, VkStridedDeviceAddressRegionKHR *out)
{
    if (!in) return;

    out->deviceAddress = in->deviceAddress;
    out->stride = in->stride;
    out->size = in->size;
}

static inline const VkDependencyInfo *convert_VkDependencyInfo_array_win32_to_host(struct conversion_context *ctx, const VkDependencyInfo32 *in, uint32_t count)
{
    VkDependencyInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDependencyInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCopyImageToImageInfoEXT_win32_to_host(struct conversion_context *ctx, const VkCopyImageToImageInfoEXT32 *in, VkCopyImageToImageInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageCopy2_array_win32_to_host(ctx, (const VkImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImageToMemoryCopyEXT_win32_to_host(const VkImageToMemoryCopyEXT32 *in, VkImageToMemoryCopyEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pHostPointer = (void *)UlongToPtr(in->pHostPointer);
    out->memoryRowLength = in->memoryRowLength;
    out->memoryImageHeight = in->memoryImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkImageToMemoryCopyEXT *convert_VkImageToMemoryCopyEXT_array_win32_to_host(struct conversion_context *ctx, const VkImageToMemoryCopyEXT32 *in, uint32_t count)
{
    VkImageToMemoryCopyEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageToMemoryCopyEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCopyImageToMemoryInfoEXT_win32_to_host(struct conversion_context *ctx, const VkCopyImageToMemoryInfoEXT32 *in, VkCopyImageToMemoryInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageToMemoryCopyEXT_array_win32_to_host(ctx, (const VkImageToMemoryCopyEXT32 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryToImageCopyEXT_win32_to_host(const VkMemoryToImageCopyEXT32 *in, VkMemoryToImageCopyEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pHostPointer = (const void *)UlongToPtr(in->pHostPointer);
    out->memoryRowLength = in->memoryRowLength;
    out->memoryImageHeight = in->memoryImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkMemoryToImageCopyEXT *convert_VkMemoryToImageCopyEXT_array_win32_to_host(struct conversion_context *ctx, const VkMemoryToImageCopyEXT32 *in, uint32_t count)
{
    VkMemoryToImageCopyEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMemoryToImageCopyEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCopyMemoryToImageInfoEXT_win32_to_host(struct conversion_context *ctx, const VkCopyMemoryToImageInfoEXT32 *in, VkCopyMemoryToImageInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkMemoryToImageCopyEXT_array_win32_to_host(ctx, (const VkMemoryToImageCopyEXT32 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAccelerationStructureCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureCreateInfoKHR32 *in, VkAccelerationStructureCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->createFlags = in->createFlags;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;
    out->type = in->type;
    out->deviceAddress = in->deviceAddress;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = (const void *)UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {
            VkAccelerationStructureMotionInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureMotionInfoNV32 *in_ext = (const VkAccelerationStructureMotionInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->maxInstances = in_ext->maxInstances;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkAccelerationStructureCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureCreateInfoNV32 *in, VkAccelerationStructureCreateInfoNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->compactedSize = in->compactedSize;
    convert_VkAccelerationStructureInfoNV_win32_to_host(ctx, &in->info, &out->info);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = (const void *)UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkBufferCreateInfo_win64_to_host(struct conversion_context *ctx, const VkBufferCreateInfo *in, VkBufferCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->size = in->size;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = in->pQueueFamilyIndices;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkBufferUsageFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfoKHR *in_ext = (const VkBufferUsageFlags2CreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            VkDedicatedAllocationBufferCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationBufferCreateInfoNV *in_ext = (const VkDedicatedAllocationBufferCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            VkExternalMemoryBufferCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryBufferCreateInfo *in_ext = (const VkExternalMemoryBufferCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            VkBufferOpaqueCaptureAddressCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferOpaqueCaptureAddressCreateInfo *in_ext = (const VkBufferOpaqueCaptureAddressCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            VkBufferDeviceAddressCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferDeviceAddressCreateInfoEXT *in_ext = (const VkBufferDeviceAddressCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceAddress = in_ext->deviceAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = in_ext->opaqueCaptureDescriptorData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkBufferCreateInfo_win32_to_host(struct conversion_context *ctx, const VkBufferCreateInfo32 *in, VkBufferCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->size = in->size;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = (const uint32_t *)UlongToPtr(in->pQueueFamilyIndices);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkBufferUsageFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfoKHR32 *in_ext = (const VkBufferUsageFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            VkDedicatedAllocationBufferCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationBufferCreateInfoNV32 *in_ext = (const VkDedicatedAllocationBufferCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            VkExternalMemoryBufferCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryBufferCreateInfo32 *in_ext = (const VkExternalMemoryBufferCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            VkBufferOpaqueCaptureAddressCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferOpaqueCaptureAddressCreateInfo32 *in_ext = (const VkBufferOpaqueCaptureAddressCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            VkBufferDeviceAddressCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferDeviceAddressCreateInfoEXT32 *in_ext = (const VkBufferDeviceAddressCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceAddress = in_ext->deviceAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = (const void *)UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkBufferViewCreateInfo_win32_to_host(struct conversion_context *ctx, const VkBufferViewCreateInfo32 *in, VkBufferViewCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->buffer = in->buffer;
    out->format = in->format;
    out->offset = in->offset;
    out->range = in->range;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkBufferUsageFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfoKHR32 *in_ext = (const VkBufferUsageFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkCommandPoolCreateInfo_win32_to_host(const VkCommandPoolCreateInfo32 *in, VkCommandPoolCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueFamilyIndex = in->queueFamilyIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineCreationFeedback_host_to_win32(const VkPipelineCreationFeedback *in, VkPipelineCreationFeedback32 *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->duration = in->duration;
}

static inline VkPipelineCreationFeedback *convert_VkPipelineCreationFeedback_array_win32_to_host(struct conversion_context *ctx, const VkPipelineCreationFeedback32 *in, uint32_t count)
{
    VkPipelineCreationFeedback *out;
    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));

    return out;
}

static inline void convert_VkPipelineCreationFeedback_array_host_to_win32(const VkPipelineCreationFeedback *in, VkPipelineCreationFeedback32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineCreationFeedback_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkSpecializationMapEntry_win32_to_host(const VkSpecializationMapEntry32 *in, VkSpecializationMapEntry *out)
{
    if (!in) return;

    out->constantID = in->constantID;
    out->offset = in->offset;
    out->size = in->size;
}

static inline const VkSpecializationMapEntry *convert_VkSpecializationMapEntry_array_win32_to_host(struct conversion_context *ctx, const VkSpecializationMapEntry32 *in, uint32_t count)
{
    VkSpecializationMapEntry *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSpecializationMapEntry_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSpecializationInfo_win32_to_host(struct conversion_context *ctx, const VkSpecializationInfo32 *in, VkSpecializationInfo *out)
{
    if (!in) return;

    out->mapEntryCount = in->mapEntryCount;
    out->pMapEntries = convert_VkSpecializationMapEntry_array_win32_to_host(ctx, (const VkSpecializationMapEntry32 *)UlongToPtr(in->pMapEntries), in->mapEntryCount);
    out->dataSize = in->dataSize;
    out->pData = (const void *)UlongToPtr(in->pData);
}

static inline const VkSpecializationInfo *convert_VkSpecializationInfo_array_win32_to_host(struct conversion_context *ctx, const VkSpecializationInfo32 *in, uint32_t count)
{
    VkSpecializationInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSpecializationInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkPipelineShaderStageCreateInfo_win64_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo *in, VkPipelineShaderStageCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stage = in->stage;
    out->module = in->module;
    out->pName = in->pName;
    out->pSpecializationInfo = in->pSpecializationInfo;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
            VkShaderModuleCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleCreateInfo *in_ext = (const VkShaderModuleCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->codeSize = in_ext->codeSize;
            out_ext->pCode = in_ext->pCode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            VkShaderModuleValidationCacheCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleValidationCacheCreateInfoEXT *in_ext = (const VkShaderModuleValidationCacheCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->validationCache = in_ext->validationCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsObjectNameInfoEXT *in_ext = (const VkDebugUtilsObjectNameInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->objectType = in_ext->objectType;
            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
            out_ext->pObjectName = in_ext->pObjectName;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
            VkPipelineShaderStageModuleIdentifierCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageModuleIdentifierCreateInfoEXT *in_ext = (const VkPipelineShaderStageModuleIdentifierCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->identifierSize = in_ext->identifierSize;
            out_ext->pIdentifier = in_ext->pIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
            VkPipelineRobustnessCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfoEXT *in_ext = (const VkPipelineRobustnessCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkPipelineShaderStageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo32 *in, VkPipelineShaderStageCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stage = in->stage;
    out->module = in->module;
    out->pName = (const char *)UlongToPtr(in->pName);
    out->pSpecializationInfo = convert_VkSpecializationInfo_array_win32_to_host(ctx, (const VkSpecializationInfo32 *)UlongToPtr(in->pSpecializationInfo), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
            VkShaderModuleCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleCreateInfo32 *in_ext = (const VkShaderModuleCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->codeSize = in_ext->codeSize;
            out_ext->pCode = (const uint32_t *)UlongToPtr(in_ext->pCode);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            VkShaderModuleValidationCacheCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleValidationCacheCreateInfoEXT32 *in_ext = (const VkShaderModuleValidationCacheCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->validationCache = in_ext->validationCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsObjectNameInfoEXT32 *in_ext = (const VkDebugUtilsObjectNameInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->objectType = in_ext->objectType;
            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
            out_ext->pObjectName = (const char *)UlongToPtr(in_ext->pObjectName);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
            VkPipelineShaderStageModuleIdentifierCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageModuleIdentifierCreateInfoEXT32 *in_ext = (const VkPipelineShaderStageModuleIdentifierCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->identifierSize = in_ext->identifierSize;
            out_ext->pIdentifier = (const uint8_t *)UlongToPtr(in_ext->pIdentifier);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
            VkPipelineRobustnessCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfoEXT32 *in_ext = (const VkPipelineRobustnessCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkComputePipelineCreateInfo_win64_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo *in, VkComputePipelineCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    convert_VkPipelineShaderStageCreateInfo_win64_to_host(ctx, &in->stage, &out->stage);
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;
}
#endif /* _WIN64 */

static inline void convert_VkComputePipelineCreateInfo_win32_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo32 *in, VkComputePipelineCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    convert_VkPipelineShaderStageCreateInfo_win32_to_host(ctx, &in->stage, &out->stage);
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkPipelineCreateFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfoKHR32 *in_ext = (const VkPipelineCreateFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {
            VkSubpassShadingPipelineCreateInfoHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSubpassShadingPipelineCreateInfoHUAWEI32 *in_ext = (const VkSubpassShadingPipelineCreateInfoHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->renderPass = in_ext->renderPass;
            out_ext->subpass = in_ext->subpass;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            VkPipelineCompilerControlCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCompilerControlCreateInfoAMD32 *in_ext = (const VkPipelineCompilerControlCreateInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->compilerControlFlags = in_ext->compilerControlFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
            VkPipelineRobustnessCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfoEXT32 *in_ext = (const VkPipelineRobustnessCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkComputePipelineCreateInfo_host_to_win32(const VkComputePipelineCreateInfo *in, const VkComputePipelineCreateInfo32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkComputePipelineCreateInfo *convert_VkComputePipelineCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo *in, uint32_t count)
{
    VkComputePipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkComputePipelineCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkComputePipelineCreateInfo *convert_VkComputePipelineCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo32 *in, uint32_t count)
{
    VkComputePipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkComputePipelineCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkComputePipelineCreateInfo_array_host_to_win32(const VkComputePipelineCreateInfo *in, const VkComputePipelineCreateInfo32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkComputePipelineCreateInfo_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkCuFunctionCreateInfoNVX_win32_to_host(const VkCuFunctionCreateInfoNVX32 *in, VkCuFunctionCreateInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->module = in->module;
    out->pName = (const char *)UlongToPtr(in->pName);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCuModuleCreateInfoNVX_win32_to_host(const VkCuModuleCreateInfoNVX32 *in, VkCuModuleCreateInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dataSize = in->dataSize;
    out->pData = (const void *)UlongToPtr(in->pData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDebugReportCallbackCreateInfoEXT_win32_to_host(const VkDebugReportCallbackCreateInfoEXT32 *in, VkDebugReportCallbackCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pfnCallback = in->pfnCallback;
    out->pUserData = (void *)UlongToPtr(in->pUserData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDebugUtilsMessengerCreateInfoEXT_win32_to_host(const VkDebugUtilsMessengerCreateInfoEXT32 *in, VkDebugUtilsMessengerCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->messageSeverity = in->messageSeverity;
    out->messageType = in->messageType;
    out->pfnUserCallback = in->pfnUserCallback;
    out->pUserData = (void *)UlongToPtr(in->pUserData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMutableDescriptorTypeListEXT_win32_to_host(const VkMutableDescriptorTypeListEXT32 *in, VkMutableDescriptorTypeListEXT *out)
{
    if (!in) return;

    out->descriptorTypeCount = in->descriptorTypeCount;
    out->pDescriptorTypes = (const VkDescriptorType *)UlongToPtr(in->pDescriptorTypes);
}

static inline const VkMutableDescriptorTypeListEXT *convert_VkMutableDescriptorTypeListEXT_array_win32_to_host(struct conversion_context *ctx, const VkMutableDescriptorTypeListEXT32 *in, uint32_t count)
{
    VkMutableDescriptorTypeListEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMutableDescriptorTypeListEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDescriptorPoolCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorPoolCreateInfo32 *in, VkDescriptorPoolCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->maxSets = in->maxSets;
    out->poolSizeCount = in->poolSizeCount;
    out->pPoolSizes = (const VkDescriptorPoolSize *)UlongToPtr(in->pPoolSizes);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
        {
            VkDescriptorPoolInlineUniformBlockCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorPoolInlineUniformBlockCreateInfo32 *in_ext = (const VkDescriptorPoolInlineUniformBlockCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->maxInlineUniformBlockBindings = in_ext->maxInlineUniformBlockBindings;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
            VkMutableDescriptorTypeCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMutableDescriptorTypeCreateInfoEXT32 *in_ext = (const VkMutableDescriptorTypeCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorTypeListCount = in_ext->mutableDescriptorTypeListCount;
            out_ext->pMutableDescriptorTypeLists = convert_VkMutableDescriptorTypeListEXT_array_win32_to_host(ctx, (const VkMutableDescriptorTypeListEXT32 *)UlongToPtr(in_ext->pMutableDescriptorTypeLists), in_ext->mutableDescriptorTypeListCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkDescriptorSetLayoutBinding_win32_to_host(const VkDescriptorSetLayoutBinding32 *in, VkDescriptorSetLayoutBinding *out)
{
    if (!in) return;

    out->binding = in->binding;
    out->descriptorType = in->descriptorType;
    out->descriptorCount = in->descriptorCount;
    out->stageFlags = in->stageFlags;
    out->pImmutableSamplers = (const VkSampler *)UlongToPtr(in->pImmutableSamplers);
}

static inline const VkDescriptorSetLayoutBinding *convert_VkDescriptorSetLayoutBinding_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetLayoutBinding32 *in, uint32_t count)
{
    VkDescriptorSetLayoutBinding *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorSetLayoutBinding_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetLayoutCreateInfo32 *in, VkDescriptorSetLayoutCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->bindingCount = in->bindingCount;
    out->pBindings = convert_VkDescriptorSetLayoutBinding_array_win32_to_host(ctx, (const VkDescriptorSetLayoutBinding32 *)UlongToPtr(in->pBindings), in->bindingCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            VkDescriptorSetLayoutBindingFlagsCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorSetLayoutBindingFlagsCreateInfo32 *in_ext = (const VkDescriptorSetLayoutBindingFlagsCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->bindingCount = in_ext->bindingCount;
            out_ext->pBindingFlags = (const VkDescriptorBindingFlags *)UlongToPtr(in_ext->pBindingFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
            VkMutableDescriptorTypeCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMutableDescriptorTypeCreateInfoEXT32 *in_ext = (const VkMutableDescriptorTypeCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorTypeListCount = in_ext->mutableDescriptorTypeListCount;
            out_ext->pMutableDescriptorTypeLists = convert_VkMutableDescriptorTypeListEXT_array_win32_to_host(ctx, (const VkMutableDescriptorTypeListEXT32 *)UlongToPtr(in_ext->pMutableDescriptorTypeLists), in_ext->mutableDescriptorTypeListCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkDescriptorUpdateTemplateEntry_win32_to_host(const VkDescriptorUpdateTemplateEntry32 *in, VkDescriptorUpdateTemplateEntry *out)
{
    if (!in) return;

    out->dstBinding = in->dstBinding;
    out->dstArrayElement = in->dstArrayElement;
    out->descriptorCount = in->descriptorCount;
    out->descriptorType = in->descriptorType;
    out->offset = in->offset;
    out->stride = in->stride;
}

static inline const VkDescriptorUpdateTemplateEntry *convert_VkDescriptorUpdateTemplateEntry_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorUpdateTemplateEntry32 *in, uint32_t count)
{
    VkDescriptorUpdateTemplateEntry *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorUpdateTemplateEntry_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDescriptorUpdateTemplateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorUpdateTemplateCreateInfo32 *in, VkDescriptorUpdateTemplateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->descriptorUpdateEntryCount = in->descriptorUpdateEntryCount;
    out->pDescriptorUpdateEntries = convert_VkDescriptorUpdateTemplateEntry_array_win32_to_host(ctx, (const VkDescriptorUpdateTemplateEntry32 *)UlongToPtr(in->pDescriptorUpdateEntries), in->descriptorUpdateEntryCount);
    out->templateType = in->templateType;
    out->descriptorSetLayout = in->descriptorSetLayout;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipelineLayout = in->pipelineLayout;
    out->set = in->set;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline const VkPhysicalDevice *convert_VkPhysicalDevice_array_win64_to_host(struct conversion_context *ctx, const VkPhysicalDevice *in, uint32_t count)
{
    VkPhysicalDevice *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_phys_dev_from_handle(in[i])->phys_dev;
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkPhysicalDevice *convert_VkPhysicalDevice_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkPhysicalDevice *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_phys_dev_from_handle(UlongToPtr(in[i]))->phys_dev;
    }

    return out;
}

static inline void convert_VkDeviceQueueCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDeviceQueueCreateInfo32 *in, VkDeviceQueueCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->queueCount = in->queueCount;
    out->pQueuePriorities = (const float *)UlongToPtr(in->pQueuePriorities);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
        {
            VkDeviceQueueGlobalPriorityCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceQueueGlobalPriorityCreateInfoKHR32 *in_ext = (const VkDeviceQueueGlobalPriorityCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->globalPriority = in_ext->globalPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkDeviceQueueCreateInfo *convert_VkDeviceQueueCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkDeviceQueueCreateInfo32 *in, uint32_t count)
{
    VkDeviceQueueCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDeviceQueueCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline const char * const*convert_char_pointer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    char **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return (void *)out;
}

#ifdef _WIN64
static inline void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkDeviceCreateInfo *in, VkDeviceCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueCreateInfoCount = in->queueCreateInfoCount;
    out->pQueueCreateInfos = in->pQueueCreateInfos;
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = in->ppEnabledLayerNames;
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = in->ppEnabledExtensionNames;
    out->pEnabledFeatures = in->pEnabledFeatures;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
            VkDevicePrivateDataCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDevicePrivateDataCreateInfo *in_ext = (const VkDevicePrivateDataCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->privateDataSlotRequestCount = in_ext->privateDataSlotRequestCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrivateDataFeatures *in_ext = (const VkPhysicalDevicePrivateDataFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->pNext = NULL;
            out_ext->privateData = in_ext->privateData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            VkPhysicalDeviceFeatures2 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFeatures2 *in_ext = (const VkPhysicalDeviceFeatures2 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
            out_ext->pNext = NULL;
            out_ext->features = in_ext->features;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVariablePointersFeatures *in_ext = (const VkPhysicalDeviceVariablePointersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewFeatures *in_ext = (const VkPhysicalDeviceMultiviewFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->pNext = NULL;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            VkDeviceGroupDeviceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupDeviceCreateInfo *in_ext = (const VkDeviceGroupDeviceCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->physicalDeviceCount = in_ext->physicalDeviceCount;
            out_ext->pPhysicalDevices = convert_VkPhysicalDevice_array_win64_to_host(ctx, in_ext->pPhysicalDevices, in_ext->physicalDeviceCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentIdFeaturesKHR *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId = in_ext->presentId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWaitFeaturesKHR *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait = in_ext->presentWait;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice16BitStorageFeatures *in_ext = (const VkPhysicalDevice16BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProtectedMemoryFeatures *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiDrawFeaturesEXT *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInlineUniformBlockFeatures *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->pNext = NULL;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance4Features *in_ext = (const VkPhysicalDeviceMaintenance4Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance5FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance5FeaturesKHR *in_ext = (const VkPhysicalDeviceMaintenance5FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDrawParametersFeatures *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat16Int8Features *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostQueryResetFeatures *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorIndexingFeatures *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTimelineSemaphoreFeatures *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice8BitStorageFeatures *in_ext = (const VkPhysicalDevice8BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkanMemoryModelFeatures *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicInt64Features *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceASTCDecodeFeaturesEXT *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExclusiveScissorFeaturesNV *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCornerSampledImageFeaturesNV *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShadingRateImageFeaturesNV *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesNV *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesEXT *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayQueryFeaturesKHR *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            VkDeviceMemoryOverallocationCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceMemoryOverallocationCreateInfoAMD *in_ext = (const VkDeviceMemoryOverallocationCreateInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->overallocationBehavior = in_ext->overallocationBehavior;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceScalarBlockLayoutFeatures *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeatures *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImagelessFramebufferFeatures *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->pNext = NULL;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentBarrierFeaturesNV *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerformanceQueryFeaturesKHR *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR:
        {
            VkPerformanceQueryReservationInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQueryReservationInfoKHR *in_ext = (const VkPerformanceQueryReservationInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->maxPerformanceQueriesPerPool = in_ext->maxPerformanceQueriesPerPool;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderClockFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            VkPhysicalDeviceIndexTypeUint8FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *in_ext = (const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubgroupSizeControlFeatures *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            VkPhysicalDeviceLineRasterizationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLineRasterizationFeaturesEXT *in_ext = (const VkPhysicalDeviceLineRasterizationFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCreationCacheControlFeatures *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan11Features *in_ext = (const VkPhysicalDeviceVulkan11Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan12Features *in_ext = (const VkPhysicalDeviceVulkan12Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan13Features *in_ext = (const VkPhysicalDeviceVulkan13Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            VkDeviceDiagnosticsConfigCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceDiagnosticsConfigCreateInfoNV *in_ext = (const VkDeviceDiagnosticsConfigCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            VkPhysicalDeviceRobustness2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRobustness2FeaturesEXT *in_ext = (const VkPhysicalDeviceRobustness2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageRobustnessFeatures *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice4444FormatsFeaturesEXT *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTerminateInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSynchronization2Features *in_ext = (const VkPhysicalDeviceSynchronization2Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
            VkPhysicalDeviceHostImageCopyFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyFeaturesEXT *in_ext = (const VkPhysicalDeviceHostImageCopyFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProvokingVertexFeaturesEXT *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerDotProductFeatures *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingFeatures *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineRobustnessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineRobustnessFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineRobustnessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessingFeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpticalFlowFeaturesNV *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFaultFeaturesEXT *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderObjectFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTileImageFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicClampFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDeviceCreateInfo32 *in, VkDeviceCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueCreateInfoCount = in->queueCreateInfoCount;
    out->pQueueCreateInfos = convert_VkDeviceQueueCreateInfo_array_win32_to_host(ctx, (const VkDeviceQueueCreateInfo32 *)UlongToPtr(in->pQueueCreateInfos), in->queueCreateInfoCount);
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledLayerNames), in->enabledLayerCount);
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledExtensionNames), in->enabledExtensionCount);
    out->pEnabledFeatures = (const VkPhysicalDeviceFeatures *)UlongToPtr(in->pEnabledFeatures);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
            VkDevicePrivateDataCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDevicePrivateDataCreateInfo32 *in_ext = (const VkDevicePrivateDataCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->privateDataSlotRequestCount = in_ext->privateDataSlotRequestCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrivateDataFeatures32 *in_ext = (const VkPhysicalDevicePrivateDataFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->pNext = NULL;
            out_ext->privateData = in_ext->privateData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            VkPhysicalDeviceFeatures2 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFeatures232 *in_ext = (const VkPhysicalDeviceFeatures232 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
            out_ext->pNext = NULL;
            out_ext->features = in_ext->features;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVariablePointersFeatures32 *in_ext = (const VkPhysicalDeviceVariablePointersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewFeatures32 *in_ext = (const VkPhysicalDeviceMultiviewFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->pNext = NULL;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            VkDeviceGroupDeviceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupDeviceCreateInfo32 *in_ext = (const VkDeviceGroupDeviceCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->physicalDeviceCount = in_ext->physicalDeviceCount;
            out_ext->pPhysicalDevices = convert_VkPhysicalDevice_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in_ext->pPhysicalDevices), in_ext->physicalDeviceCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentIdFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId = in_ext->presentId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWaitFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait = in_ext->presentWait;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice16BitStorageFeatures32 *in_ext = (const VkPhysicalDevice16BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProtectedMemoryFeatures32 *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiDrawFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInlineUniformBlockFeatures32 *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->pNext = NULL;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance4Features32 *in_ext = (const VkPhysicalDeviceMaintenance4Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance5FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance5FeaturesKHR32 *in_ext = (const VkPhysicalDeviceMaintenance5FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDrawParametersFeatures32 *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat16Int8Features32 *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostQueryResetFeatures32 *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32 *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorIndexingFeatures32 *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTimelineSemaphoreFeatures32 *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice8BitStorageFeatures32 *in_ext = (const VkPhysicalDevice8BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkanMemoryModelFeatures32 *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicInt64Features32 *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32 *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShadingRateImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesNV32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayQueryFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            VkDeviceMemoryOverallocationCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceMemoryOverallocationCreateInfoAMD32 *in_ext = (const VkDeviceMemoryOverallocationCreateInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->overallocationBehavior = in_ext->overallocationBehavior;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceScalarBlockLayoutFeatures32 *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeatures32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImagelessFramebufferFeatures32 *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->pNext = NULL;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentBarrierFeaturesNV32 *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR:
        {
            VkPerformanceQueryReservationInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQueryReservationInfoKHR32 *in_ext = (const VkPerformanceQueryReservationInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->maxPerformanceQueriesPerPool = in_ext->maxPerformanceQueriesPerPool;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderClockFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            VkPhysicalDeviceIndexTypeUint8FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceIndexTypeUint8FeaturesEXT32 *in_ext = (const VkPhysicalDeviceIndexTypeUint8FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubgroupSizeControlFeatures32 *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            VkPhysicalDeviceLineRasterizationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLineRasterizationFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLineRasterizationFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan11Features32 *in_ext = (const VkPhysicalDeviceVulkan11Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan12Features32 *in_ext = (const VkPhysicalDeviceVulkan12Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan13Features32 *in_ext = (const VkPhysicalDeviceVulkan13Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            VkDeviceDiagnosticsConfigCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceDiagnosticsConfigCreateInfoNV32 *in_ext = (const VkDeviceDiagnosticsConfigCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            VkPhysicalDeviceRobustness2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRobustness2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceRobustness2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageRobustnessFeatures32 *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice4444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSynchronization2Features32 *in_ext = (const VkPhysicalDeviceSynchronization2Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
            VkPhysicalDeviceHostImageCopyFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyFeaturesEXT32 *in_ext = (const VkPhysicalDeviceHostImageCopyFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingFeatures32 *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineRobustnessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineRobustnessFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineRobustnessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpticalFlowFeaturesNV32 *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFaultFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32 *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderObjectFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicClampFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkEventCreateInfo_win32_to_host(const VkEventCreateInfo32 *in, VkEventCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkFenceCreateInfo32 *in, VkFenceCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            VkExportFenceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportFenceCreateInfo32 *in_ext = (const VkExportFenceCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkFramebufferAttachmentImageInfo_win32_to_host(const VkFramebufferAttachmentImageInfo32 *in, VkFramebufferAttachmentImageInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->usage = in->usage;
    out->width = in->width;
    out->height = in->height;
    out->layerCount = in->layerCount;
    out->viewFormatCount = in->viewFormatCount;
    out->pViewFormats = (const VkFormat *)UlongToPtr(in->pViewFormats);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkFramebufferAttachmentImageInfo *convert_VkFramebufferAttachmentImageInfo_array_win32_to_host(struct conversion_context *ctx, const VkFramebufferAttachmentImageInfo32 *in, uint32_t count)
{
    VkFramebufferAttachmentImageInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkFramebufferAttachmentImageInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkFramebufferCreateInfo_win32_to_host(struct conversion_context *ctx, const VkFramebufferCreateInfo32 *in, VkFramebufferCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->renderPass = in->renderPass;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = (const VkImageView *)UlongToPtr(in->pAttachments);
    out->width = in->width;
    out->height = in->height;
    out->layers = in->layers;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            VkFramebufferAttachmentsCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFramebufferAttachmentsCreateInfo32 *in_ext = (const VkFramebufferAttachmentsCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->attachmentImageInfoCount = in_ext->attachmentImageInfoCount;
            out_ext->pAttachmentImageInfos = convert_VkFramebufferAttachmentImageInfo_array_win32_to_host(ctx, (const VkFramebufferAttachmentImageInfo32 *)UlongToPtr(in_ext->pAttachmentImageInfos), in_ext->attachmentImageInfoCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkPipelineShaderStageCreateInfo *convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo *in, uint32_t count)
{
    VkPipelineShaderStageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineShaderStageCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkPipelineShaderStageCreateInfo *convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo32 *in, uint32_t count)
{
    VkPipelineShaderStageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineShaderStageCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineVertexInputStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineVertexInputStateCreateInfo32 *in, VkPipelineVertexInputStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->vertexBindingDescriptionCount = in->vertexBindingDescriptionCount;
    out->pVertexBindingDescriptions = (const VkVertexInputBindingDescription *)UlongToPtr(in->pVertexBindingDescriptions);
    out->vertexAttributeDescriptionCount = in->vertexAttributeDescriptionCount;
    out->pVertexAttributeDescriptions = (const VkVertexInputAttributeDescription *)UlongToPtr(in->pVertexAttributeDescriptions);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            VkPipelineVertexInputDivisorStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineVertexInputDivisorStateCreateInfoEXT32 *in_ext = (const VkPipelineVertexInputDivisorStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexBindingDivisorCount = in_ext->vertexBindingDivisorCount;
            out_ext->pVertexBindingDivisors = (const VkVertexInputBindingDivisorDescriptionEXT *)UlongToPtr(in_ext->pVertexBindingDivisors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkPipelineVertexInputStateCreateInfo *convert_VkPipelineVertexInputStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineVertexInputStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineVertexInputStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineVertexInputStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineTessellationStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineTessellationStateCreateInfo32 *in, VkPipelineTessellationStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->patchControlPoints = in->patchControlPoints;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            VkPipelineTessellationDomainOriginStateCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineTessellationDomainOriginStateCreateInfo32 *in_ext = (const VkPipelineTessellationDomainOriginStateCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->domainOrigin = in_ext->domainOrigin;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkPipelineTessellationStateCreateInfo *convert_VkPipelineTessellationStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineTessellationStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineTessellationStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineTessellationStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkGraphicsShaderGroupCreateInfoNV_win64_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV *in, VkGraphicsShaderGroupCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->pVertexInputState = in->pVertexInputState;
    out->pTessellationState = in->pTessellationState;
}
#endif /* _WIN64 */

static inline void convert_VkGraphicsShaderGroupCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV32 *in, VkGraphicsShaderGroupCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->pVertexInputState = convert_VkPipelineVertexInputStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineVertexInputStateCreateInfo32 *)UlongToPtr(in->pVertexInputState), 1);
    out->pTessellationState = convert_VkPipelineTessellationStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineTessellationStateCreateInfo32 *)UlongToPtr(in->pTessellationState), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline const VkGraphicsShaderGroupCreateInfoNV *convert_VkGraphicsShaderGroupCreateInfoNV_array_win64_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV *in, uint32_t count)
{
    VkGraphicsShaderGroupCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsShaderGroupCreateInfoNV_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkGraphicsShaderGroupCreateInfoNV *convert_VkGraphicsShaderGroupCreateInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV32 *in, uint32_t count)
{
    VkGraphicsShaderGroupCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsShaderGroupCreateInfoNV_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineInputAssemblyStateCreateInfo_win32_to_host(const VkPipelineInputAssemblyStateCreateInfo32 *in, VkPipelineInputAssemblyStateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->topology = in->topology;
    out->primitiveRestartEnable = in->primitiveRestartEnable;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkPipelineInputAssemblyStateCreateInfo *convert_VkPipelineInputAssemblyStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineInputAssemblyStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineInputAssemblyStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineInputAssemblyStateCreateInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineViewportStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineViewportStateCreateInfo32 *in, VkPipelineViewportStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->viewportCount = in->viewportCount;
    out->pViewports = (const VkViewport *)UlongToPtr(in->pViewports);
    out->scissorCount = in->scissorCount;
    out->pScissors = (const VkRect2D *)UlongToPtr(in->pScissors);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportWScalingStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportWScalingStateCreateInfoNV32 *in_ext = (const VkPipelineViewportWScalingStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->viewportWScalingEnable = in_ext->viewportWScalingEnable;
            out_ext->viewportCount = in_ext->viewportCount;
            out_ext->pViewportWScalings = (const VkViewportWScalingNV *)UlongToPtr(in_ext->pViewportWScalings);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportSwizzleStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportSwizzleStateCreateInfoNV32 *in_ext = (const VkPipelineViewportSwizzleStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->viewportCount = in_ext->viewportCount;
            out_ext->pViewportSwizzles = (const VkViewportSwizzleNV *)UlongToPtr(in_ext->pViewportSwizzles);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportExclusiveScissorStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportExclusiveScissorStateCreateInfoNV32 *in_ext = (const VkPipelineViewportExclusiveScissorStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissorCount = in_ext->exclusiveScissorCount;
            out_ext->pExclusiveScissors = (const VkRect2D *)UlongToPtr(in_ext->pExclusiveScissors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportShadingRateImageStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportShadingRateImageStateCreateInfoNV32 *in_ext = (const VkPipelineViewportShadingRateImageStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImageEnable = in_ext->shadingRateImageEnable;
            out_ext->viewportCount = in_ext->viewportCount;
            out_ext->pShadingRatePalettes = convert_VkShadingRatePaletteNV_array_win32_to_host(ctx, (const VkShadingRatePaletteNV32 *)UlongToPtr(in_ext->pShadingRatePalettes), in_ext->viewportCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32 *in_ext = (const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->sampleOrderType = in_ext->sampleOrderType;
            out_ext->customSampleOrderCount = in_ext->customSampleOrderCount;
            out_ext->pCustomSampleOrders = convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(ctx, (const VkCoarseSampleOrderCustomNV32 *)UlongToPtr(in_ext->pCustomSampleOrders), in_ext->customSampleOrderCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
        {
            VkPipelineViewportDepthClipControlCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportDepthClipControlCreateInfoEXT32 *in_ext = (const VkPipelineViewportDepthClipControlCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->negativeOneToOne = in_ext->negativeOneToOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkPipelineViewportStateCreateInfo *convert_VkPipelineViewportStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineViewportStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineViewportStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineViewportStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineRasterizationStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineRasterizationStateCreateInfo32 *in, VkPipelineRasterizationStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->depthClampEnable = in->depthClampEnable;
    out->rasterizerDiscardEnable = in->rasterizerDiscardEnable;
    out->polygonMode = in->polygonMode;
    out->cullMode = in->cullMode;
    out->frontFace = in->frontFace;
    out->depthBiasEnable = in->depthBiasEnable;
    out->depthBiasConstantFactor = in->depthBiasConstantFactor;
    out->depthBiasClamp = in->depthBiasClamp;
    out->depthBiasSlopeFactor = in->depthBiasSlopeFactor;
    out->lineWidth = in->lineWidth;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            VkPipelineRasterizationStateRasterizationOrderAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationStateRasterizationOrderAMD32 *in_ext = (const VkPipelineRasterizationStateRasterizationOrderAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrder = in_ext->rasterizationOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationConservativeStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationConservativeStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationConservativeStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->conservativeRasterizationMode = in_ext->conservativeRasterizationMode;
            out_ext->extraPrimitiveOverestimationSize = in_ext->extraPrimitiveOverestimationSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationStateStreamCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationStateStreamCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationStateStreamCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->rasterizationStream = in_ext->rasterizationStream;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationDepthClipStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationDepthClipStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationDepthClipStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationLineStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationLineStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationLineStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->lineRasterizationMode = in_ext->lineRasterizationMode;
            out_ext->stippledLineEnable = in_ext->stippledLineEnable;
            out_ext->lineStippleFactor = in_ext->lineStippleFactor;
            out_ext->lineStipplePattern = in_ext->lineStipplePattern;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexMode = in_ext->provokingVertexMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
            VkDepthBiasRepresentationInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDepthBiasRepresentationInfoEXT32 *in_ext = (const VkDepthBiasRepresentationInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasRepresentation = in_ext->depthBiasRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkPipelineRasterizationStateCreateInfo *convert_VkPipelineRasterizationStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineRasterizationStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineRasterizationStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineRasterizationStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineMultisampleStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineMultisampleStateCreateInfo32 *in, VkPipelineMultisampleStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->rasterizationSamples = in->rasterizationSamples;
    out->sampleShadingEnable = in->sampleShadingEnable;
    out->minSampleShading = in->minSampleShading;
    out->pSampleMask = (const VkSampleMask *)UlongToPtr(in->pSampleMask);
    out->alphaToCoverageEnable = in->alphaToCoverageEnable;
    out->alphaToOneEnable = in->alphaToOneEnable;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            VkPipelineCoverageToColorStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCoverageToColorStateCreateInfoNV32 *in_ext = (const VkPipelineCoverageToColorStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->coverageToColorEnable = in_ext->coverageToColorEnable;
            out_ext->coverageToColorLocation = in_ext->coverageToColorLocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            VkPipelineSampleLocationsStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineSampleLocationsStateCreateInfoEXT32 *in_ext = (const VkPipelineSampleLocationsStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sampleLocationsEnable = in_ext->sampleLocationsEnable;
            convert_VkSampleLocationsInfoEXT_win32_to_host(&in_ext->sampleLocationsInfo, &out_ext->sampleLocationsInfo);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            VkPipelineCoverageModulationStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCoverageModulationStateCreateInfoNV32 *in_ext = (const VkPipelineCoverageModulationStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->coverageModulationMode = in_ext->coverageModulationMode;
            out_ext->coverageModulationTableEnable = in_ext->coverageModulationTableEnable;
            out_ext->coverageModulationTableCount = in_ext->coverageModulationTableCount;
            out_ext->pCoverageModulationTable = (const float *)UlongToPtr(in_ext->pCoverageModulationTable);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            VkPipelineCoverageReductionStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCoverageReductionStateCreateInfoNV32 *in_ext = (const VkPipelineCoverageReductionStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkPipelineMultisampleStateCreateInfo *convert_VkPipelineMultisampleStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineMultisampleStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineMultisampleStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineMultisampleStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineDepthStencilStateCreateInfo_win32_to_host(const VkPipelineDepthStencilStateCreateInfo32 *in, VkPipelineDepthStencilStateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->depthTestEnable = in->depthTestEnable;
    out->depthWriteEnable = in->depthWriteEnable;
    out->depthCompareOp = in->depthCompareOp;
    out->depthBoundsTestEnable = in->depthBoundsTestEnable;
    out->stencilTestEnable = in->stencilTestEnable;
    out->front = in->front;
    out->back = in->back;
    out->minDepthBounds = in->minDepthBounds;
    out->maxDepthBounds = in->maxDepthBounds;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkPipelineDepthStencilStateCreateInfo *convert_VkPipelineDepthStencilStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineDepthStencilStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineDepthStencilStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineDepthStencilStateCreateInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineColorBlendStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineColorBlendStateCreateInfo32 *in, VkPipelineColorBlendStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->logicOpEnable = in->logicOpEnable;
    out->logicOp = in->logicOp;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = (const VkPipelineColorBlendAttachmentState *)UlongToPtr(in->pAttachments);
    memcpy(out->blendConstants, in->blendConstants, 4 * sizeof(float));

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            VkPipelineColorBlendAdvancedStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineColorBlendAdvancedStateCreateInfoEXT32 *in_ext = (const VkPipelineColorBlendAdvancedStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->srcPremultiplied = in_ext->srcPremultiplied;
            out_ext->dstPremultiplied = in_ext->dstPremultiplied;
            out_ext->blendOverlap = in_ext->blendOverlap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {
            VkPipelineColorWriteCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineColorWriteCreateInfoEXT32 *in_ext = (const VkPipelineColorWriteCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentCount = in_ext->attachmentCount;
            out_ext->pColorWriteEnables = (const VkBool32 *)UlongToPtr(in_ext->pColorWriteEnables);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkPipelineColorBlendStateCreateInfo *convert_VkPipelineColorBlendStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineColorBlendStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineColorBlendStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineColorBlendStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineDynamicStateCreateInfo_win32_to_host(const VkPipelineDynamicStateCreateInfo32 *in, VkPipelineDynamicStateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->dynamicStateCount = in->dynamicStateCount;
    out->pDynamicStates = (const VkDynamicState *)UlongToPtr(in->pDynamicStates);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkPipelineDynamicStateCreateInfo *convert_VkPipelineDynamicStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineDynamicStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineDynamicStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineDynamicStateCreateInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkGraphicsPipelineCreateInfo_win64_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo *in, VkGraphicsPipelineCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->pVertexInputState = in->pVertexInputState;
    out->pInputAssemblyState = in->pInputAssemblyState;
    out->pTessellationState = in->pTessellationState;
    out->pViewportState = in->pViewportState;
    out->pRasterizationState = in->pRasterizationState;
    out->pMultisampleState = in->pMultisampleState;
    out->pDepthStencilState = in->pDepthStencilState;
    out->pColorBlendState = in->pColorBlendState;
    out->pDynamicState = in->pDynamicState;
    out->layout = in->layout;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkPipelineCreateFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfoKHR *in_ext = (const VkPipelineCreateFlags2CreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            VkGraphicsPipelineShaderGroupsCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineShaderGroupsCreateInfoNV *in_ext = (const VkGraphicsPipelineShaderGroupsCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->groupCount = in_ext->groupCount;
            out_ext->pGroups = convert_VkGraphicsShaderGroupCreateInfoNV_array_win64_to_host(ctx, in_ext->pGroups, in_ext->groupCount);
            out_ext->pipelineCount = in_ext->pipelineCount;
            out_ext->pPipelines = in_ext->pPipelines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineDiscardRectangleStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineDiscardRectangleStateCreateInfoEXT *in_ext = (const VkPipelineDiscardRectangleStateCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->discardRectangleMode = in_ext->discardRectangleMode;
            out_ext->discardRectangleCount = in_ext->discardRectangleCount;
            out_ext->pDiscardRectangles = in_ext->pDiscardRectangles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *in_ext = (const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTestEnable = in_ext->representativeFragmentTestEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = in_ext->pPipelineCreationFeedback;
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = in_ext->pPipelineStageCreationFeedbacks;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            VkPipelineCompilerControlCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCompilerControlCreateInfoAMD *in_ext = (const VkPipelineCompilerControlCreateInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->compilerControlFlags = in_ext->compilerControlFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
            VkPipelineLibraryCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLibraryCreateInfoKHR *in_ext = (const VkPipelineLibraryCreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->libraryCount = in_ext->libraryCount;
            out_ext->pLibraries = in_ext->pLibraries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            VkPipelineFragmentShadingRateStateCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateStateCreateInfoKHR *in_ext = (const VkPipelineFragmentShadingRateStateCreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentSize = in_ext->fragmentSize;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateEnumStateCreateInfoNV *in_ext = (const VkPipelineFragmentShadingRateEnumStateCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateType = in_ext->shadingRateType;
            out_ext->shadingRate = in_ext->shadingRate;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
            VkPipelineRenderingCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRenderingCreateInfo *in_ext = (const VkPipelineRenderingCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = in_ext->pColorAttachmentFormats;
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD *in_ext = (const VkAttachmentSampleCountInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = in_ext->pColorAttachmentSamples;
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
            VkMultiviewPerViewAttributesInfoNVX *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewAttributesInfoNVX *in_ext = (const VkMultiviewPerViewAttributesInfoNVX *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
            out_ext->pNext = NULL;
            out_ext->perViewAttributes = in_ext->perViewAttributes;
            out_ext->perViewAttributesPositionXOnly = in_ext->perViewAttributesPositionXOnly;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
            VkGraphicsPipelineLibraryCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineLibraryCreateInfoEXT *in_ext = (const VkGraphicsPipelineLibraryCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
            VkPipelineRobustnessCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfoEXT *in_ext = (const VkPipelineRobustnessCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkGraphicsPipelineCreateInfo_win32_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo32 *in, VkGraphicsPipelineCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->pVertexInputState = convert_VkPipelineVertexInputStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineVertexInputStateCreateInfo32 *)UlongToPtr(in->pVertexInputState), 1);
    out->pInputAssemblyState = convert_VkPipelineInputAssemblyStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineInputAssemblyStateCreateInfo32 *)UlongToPtr(in->pInputAssemblyState), 1);
    out->pTessellationState = convert_VkPipelineTessellationStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineTessellationStateCreateInfo32 *)UlongToPtr(in->pTessellationState), 1);
    out->pViewportState = convert_VkPipelineViewportStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineViewportStateCreateInfo32 *)UlongToPtr(in->pViewportState), 1);
    out->pRasterizationState = convert_VkPipelineRasterizationStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineRasterizationStateCreateInfo32 *)UlongToPtr(in->pRasterizationState), 1);
    out->pMultisampleState = convert_VkPipelineMultisampleStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineMultisampleStateCreateInfo32 *)UlongToPtr(in->pMultisampleState), 1);
    out->pDepthStencilState = convert_VkPipelineDepthStencilStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineDepthStencilStateCreateInfo32 *)UlongToPtr(in->pDepthStencilState), 1);
    out->pColorBlendState = convert_VkPipelineColorBlendStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineColorBlendStateCreateInfo32 *)UlongToPtr(in->pColorBlendState), 1);
    out->pDynamicState = convert_VkPipelineDynamicStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineDynamicStateCreateInfo32 *)UlongToPtr(in->pDynamicState), 1);
    out->layout = in->layout;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkPipelineCreateFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfoKHR32 *in_ext = (const VkPipelineCreateFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            VkGraphicsPipelineShaderGroupsCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineShaderGroupsCreateInfoNV32 *in_ext = (const VkGraphicsPipelineShaderGroupsCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->groupCount = in_ext->groupCount;
            out_ext->pGroups = convert_VkGraphicsShaderGroupCreateInfoNV_array_win32_to_host(ctx, (const VkGraphicsShaderGroupCreateInfoNV32 *)UlongToPtr(in_ext->pGroups), in_ext->groupCount);
            out_ext->pipelineCount = in_ext->pipelineCount;
            out_ext->pPipelines = (const VkPipeline *)UlongToPtr(in_ext->pPipelines);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineDiscardRectangleStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineDiscardRectangleStateCreateInfoEXT32 *in_ext = (const VkPipelineDiscardRectangleStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->discardRectangleMode = in_ext->discardRectangleMode;
            out_ext->discardRectangleCount = in_ext->discardRectangleCount;
            out_ext->pDiscardRectangles = (const VkRect2D *)UlongToPtr(in_ext->pDiscardRectangles);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRepresentativeFragmentTestStateCreateInfoNV32 *in_ext = (const VkPipelineRepresentativeFragmentTestStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTestEnable = in_ext->representativeFragmentTestEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            VkPipelineCompilerControlCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCompilerControlCreateInfoAMD32 *in_ext = (const VkPipelineCompilerControlCreateInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->compilerControlFlags = in_ext->compilerControlFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
            VkPipelineLibraryCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLibraryCreateInfoKHR32 *in_ext = (const VkPipelineLibraryCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->libraryCount = in_ext->libraryCount;
            out_ext->pLibraries = (const VkPipeline *)UlongToPtr(in_ext->pLibraries);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            VkPipelineFragmentShadingRateStateCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateStateCreateInfoKHR32 *in_ext = (const VkPipelineFragmentShadingRateStateCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentSize = in_ext->fragmentSize;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateEnumStateCreateInfoNV32 *in_ext = (const VkPipelineFragmentShadingRateEnumStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateType = in_ext->shadingRateType;
            out_ext->shadingRate = in_ext->shadingRate;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
            VkPipelineRenderingCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRenderingCreateInfo32 *in_ext = (const VkPipelineRenderingCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = (const VkFormat *)UlongToPtr(in_ext->pColorAttachmentFormats);
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD32 *in_ext = (const VkAttachmentSampleCountInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = (const VkSampleCountFlagBits *)UlongToPtr(in_ext->pColorAttachmentSamples);
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
            VkMultiviewPerViewAttributesInfoNVX *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewAttributesInfoNVX32 *in_ext = (const VkMultiviewPerViewAttributesInfoNVX32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
            out_ext->pNext = NULL;
            out_ext->perViewAttributes = in_ext->perViewAttributes;
            out_ext->perViewAttributesPositionXOnly = in_ext->perViewAttributesPositionXOnly;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
            VkGraphicsPipelineLibraryCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineLibraryCreateInfoEXT32 *in_ext = (const VkGraphicsPipelineLibraryCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
            VkPipelineRobustnessCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfoEXT32 *in_ext = (const VkPipelineRobustnessCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkGraphicsPipelineCreateInfo_host_to_win32(const VkGraphicsPipelineCreateInfo *in, const VkGraphicsPipelineCreateInfo32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkGraphicsPipelineCreateInfo *convert_VkGraphicsPipelineCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo *in, uint32_t count)
{
    VkGraphicsPipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsPipelineCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkGraphicsPipelineCreateInfo *convert_VkGraphicsPipelineCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo32 *in, uint32_t count)
{
    VkGraphicsPipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsPipelineCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkGraphicsPipelineCreateInfo_array_host_to_win32(const VkGraphicsPipelineCreateInfo *in, const VkGraphicsPipelineCreateInfo32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsPipelineCreateInfo_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static inline void convert_VkImageCreateInfo_win64_to_host(struct conversion_context *ctx, const VkImageCreateInfo *in, VkImageCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->imageType = in->imageType;
    out->format = in->format;
    out->extent = in->extent;
    out->mipLevels = in->mipLevels;
    out->arrayLayers = in->arrayLayers;
    out->samples = in->samples;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = in->pQueueFamilyIndices;
    out->initialLayout = in->initialLayout;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            VkDedicatedAllocationImageCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationImageCreateInfoNV *in_ext = (const VkDedicatedAllocationImageCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            VkExternalMemoryImageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryImageCreateInfo *in_ext = (const VkExternalMemoryImageCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            VkImageSwapchainCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageSwapchainCreateInfoKHR *in_ext = (const VkImageSwapchainCreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = in_ext->swapchain ? wine_swapchain_from_handle(in_ext->swapchain)->swapchain : 0;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo *in_ext = (const VkImageFormatListCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = in_ext->pViewFormats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo *in_ext = (const VkImageStencilUsageCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = in_ext->opaqueCaptureDescriptorData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT *in_ext = (const VkImageCompressionControlEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = in_ext->pFixedRateFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV *in_ext = (const VkOpticalFlowImageFormatInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkImageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, VkImageCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->imageType = in->imageType;
    out->format = in->format;
    out->extent = in->extent;
    out->mipLevels = in->mipLevels;
    out->arrayLayers = in->arrayLayers;
    out->samples = in->samples;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = (const uint32_t *)UlongToPtr(in->pQueueFamilyIndices);
    out->initialLayout = in->initialLayout;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            VkDedicatedAllocationImageCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationImageCreateInfoNV32 *in_ext = (const VkDedicatedAllocationImageCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            VkExternalMemoryImageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryImageCreateInfo32 *in_ext = (const VkExternalMemoryImageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            VkImageSwapchainCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageSwapchainCreateInfoKHR32 *in_ext = (const VkImageSwapchainCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = in_ext->swapchain ? wine_swapchain_from_handle(in_ext->swapchain)->swapchain : 0;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo32 *in_ext = (const VkImageFormatListCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = (const VkFormat *)UlongToPtr(in_ext->pViewFormats);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo32 *in_ext = (const VkImageStencilUsageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = (const void *)UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT32 *in_ext = (const VkImageCompressionControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = (VkImageCompressionFixedRateFlagsEXT *)UlongToPtr(in_ext->pFixedRateFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV32 *in_ext = (const VkOpticalFlowImageFormatInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkImageViewCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageViewCreateInfo32 *in, VkImageViewCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->image = in->image;
    out->viewType = in->viewType;
    out->format = in->format;
    out->components = in->components;
    out->subresourceRange = in->subresourceRange;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            VkImageViewUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewUsageCreateInfo32 *in_ext = (const VkImageViewUsageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
        {
            VkImageViewSlicedCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewSlicedCreateInfoEXT32 *in_ext = (const VkImageViewSlicedCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sliceOffset = in_ext->sliceOffset;
            out_ext->sliceCount = in_ext->sliceCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerYcbcrConversionInfo32 *in_ext = (const VkSamplerYcbcrConversionInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
            out_ext->pNext = NULL;
            out_ext->conversion = in_ext->conversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            VkImageViewASTCDecodeModeEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewASTCDecodeModeEXT32 *in_ext = (const VkImageViewASTCDecodeModeEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeMode = in_ext->decodeMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = (const void *)UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
        {
            VkImageViewMinLodCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewMinLodCreateInfoEXT32 *in_ext = (const VkImageViewMinLodCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
        {
            VkImageViewSampleWeightCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewSampleWeightCreateInfoQCOM32 *in_ext = (const VkImageViewSampleWeightCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->filterCenter = in_ext->filterCenter;
            out_ext->filterSize = in_ext->filterSize;
            out_ext->numPhases = in_ext->numPhases;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(const VkIndirectCommandsLayoutTokenNV32 *in, VkIndirectCommandsLayoutTokenNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tokenType = in->tokenType;
    out->stream = in->stream;
    out->offset = in->offset;
    out->vertexBindingUnit = in->vertexBindingUnit;
    out->vertexDynamicStride = in->vertexDynamicStride;
    out->pushconstantPipelineLayout = in->pushconstantPipelineLayout;
    out->pushconstantShaderStageFlags = in->pushconstantShaderStageFlags;
    out->pushconstantOffset = in->pushconstantOffset;
    out->pushconstantSize = in->pushconstantSize;
    out->indirectStateFlags = in->indirectStateFlags;
    out->indexTypeCount = in->indexTypeCount;
    out->pIndexTypes = (const VkIndexType *)UlongToPtr(in->pIndexTypes);
    out->pIndexTypeValues = (const uint32_t *)UlongToPtr(in->pIndexTypeValues);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkIndirectCommandsLayoutTokenNV *convert_VkIndirectCommandsLayoutTokenNV_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenNV32 *in, uint32_t count)
{
    VkIndirectCommandsLayoutTokenNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkIndirectCommandsLayoutCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutCreateInfoNV32 *in, VkIndirectCommandsLayoutCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->tokenCount = in->tokenCount;
    out->pTokens = convert_VkIndirectCommandsLayoutTokenNV_array_win32_to_host(ctx, (const VkIndirectCommandsLayoutTokenNV32 *)UlongToPtr(in->pTokens), in->tokenCount);
    out->streamCount = in->streamCount;
    out->pStreamStrides = (const uint32_t *)UlongToPtr(in->pStreamStrides);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkApplicationInfo_win32_to_host(const VkApplicationInfo32 *in, VkApplicationInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pApplicationName = (const char *)UlongToPtr(in->pApplicationName);
    out->applicationVersion = in->applicationVersion;
    out->pEngineName = (const char *)UlongToPtr(in->pEngineName);
    out->engineVersion = in->engineVersion;
    out->apiVersion = in->apiVersion;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkApplicationInfo *convert_VkApplicationInfo_array_win32_to_host(struct conversion_context *ctx, const VkApplicationInfo32 *in, uint32_t count)
{
    VkApplicationInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkApplicationInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkInstanceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkInstanceCreateInfo *in, VkInstanceCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pApplicationInfo = in->pApplicationInfo;
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = in->ppEnabledLayerNames;
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = in->ppEnabledExtensionNames;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            VkDebugReportCallbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugReportCallbackCreateInfoEXT *in_ext = (const VkDebugReportCallbackCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->pfnCallback = in_ext->pfnCallback;
            out_ext->pUserData = in_ext->pUserData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            VkValidationFlagsEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFlagsEXT *in_ext = (const VkValidationFlagsEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
            out_ext->pNext = NULL;
            out_ext->disabledValidationCheckCount = in_ext->disabledValidationCheckCount;
            out_ext->pDisabledValidationChecks = in_ext->pDisabledValidationChecks;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFeaturesEXT *in_ext = (const VkValidationFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
            out_ext->pEnabledValidationFeatures = in_ext->pEnabledValidationFeatures;
            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
            out_ext->pDisabledValidationFeatures = in_ext->pDisabledValidationFeatures;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            VkDebugUtilsMessengerCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsMessengerCreateInfoEXT *in_ext = (const VkDebugUtilsMessengerCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->messageSeverity = in_ext->messageSeverity;
            out_ext->messageType = in_ext->messageType;
            out_ext->pfnUserCallback = in_ext->pfnUserCallback;
            out_ext->pUserData = in_ext->pUserData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkInstanceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkInstanceCreateInfo32 *in, VkInstanceCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pApplicationInfo = convert_VkApplicationInfo_array_win32_to_host(ctx, (const VkApplicationInfo32 *)UlongToPtr(in->pApplicationInfo), 1);
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledLayerNames), in->enabledLayerCount);
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledExtensionNames), in->enabledExtensionCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            VkDebugReportCallbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugReportCallbackCreateInfoEXT32 *in_ext = (const VkDebugReportCallbackCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->pfnCallback = in_ext->pfnCallback;
            out_ext->pUserData = (void *)UlongToPtr(in_ext->pUserData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            VkValidationFlagsEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFlagsEXT32 *in_ext = (const VkValidationFlagsEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
            out_ext->pNext = NULL;
            out_ext->disabledValidationCheckCount = in_ext->disabledValidationCheckCount;
            out_ext->pDisabledValidationChecks = (const VkValidationCheckEXT *)UlongToPtr(in_ext->pDisabledValidationChecks);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFeaturesEXT32 *in_ext = (const VkValidationFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
            out_ext->pEnabledValidationFeatures = (const VkValidationFeatureEnableEXT *)UlongToPtr(in_ext->pEnabledValidationFeatures);
            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
            out_ext->pDisabledValidationFeatures = (const VkValidationFeatureDisableEXT *)UlongToPtr(in_ext->pDisabledValidationFeatures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            VkDebugUtilsMessengerCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsMessengerCreateInfoEXT32 *in_ext = (const VkDebugUtilsMessengerCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->messageSeverity = in_ext->messageSeverity;
            out_ext->messageType = in_ext->messageType;
            out_ext->pfnUserCallback = in_ext->pfnUserCallback;
            out_ext->pUserData = (void *)UlongToPtr(in_ext->pUserData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkMicromapCreateInfoEXT_win32_to_host(const VkMicromapCreateInfoEXT32 *in, VkMicromapCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->createFlags = in->createFlags;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;
    out->type = in->type;
    out->deviceAddress = in->deviceAddress;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkOpticalFlowSessionCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkOpticalFlowSessionCreateInfoNV32 *in, VkOpticalFlowSessionCreateInfoNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->width = in->width;
    out->height = in->height;
    out->imageFormat = in->imageFormat;
    out->flowVectorFormat = in->flowVectorFormat;
    out->costFormat = in->costFormat;
    out->outputGridSize = in->outputGridSize;
    out->hintGridSize = in->hintGridSize;
    out->performanceLevel = in->performanceLevel;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
        {
            VkOpticalFlowSessionCreatePrivateDataInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowSessionCreatePrivateDataInfoNV32 *in_ext = (const VkOpticalFlowSessionCreatePrivateDataInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->id = in_ext->id;
            out_ext->size = in_ext->size;
            out_ext->pPrivateData = (const void *)UlongToPtr(in_ext->pPrivateData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkPipelineCacheCreateInfo_win32_to_host(const VkPipelineCacheCreateInfo32 *in, VkPipelineCacheCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->initialDataSize = in->initialDataSize;
    out->pInitialData = (const void *)UlongToPtr(in->pInitialData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineLayoutCreateInfo_win32_to_host(const VkPipelineLayoutCreateInfo32 *in, VkPipelineLayoutCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->setLayoutCount = in->setLayoutCount;
    out->pSetLayouts = (const VkDescriptorSetLayout *)UlongToPtr(in->pSetLayouts);
    out->pushConstantRangeCount = in->pushConstantRangeCount;
    out->pPushConstantRanges = (const VkPushConstantRange *)UlongToPtr(in->pPushConstantRanges);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPrivateDataSlotCreateInfo_win32_to_host(const VkPrivateDataSlotCreateInfo32 *in, VkPrivateDataSlotCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkQueryPoolCreateInfo_win32_to_host(struct conversion_context *ctx, const VkQueryPoolCreateInfo32 *in, VkQueryPoolCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queryType = in->queryType;
    out->queryCount = in->queryCount;
    out->pipelineStatistics = in->pipelineStatistics;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            VkQueryPoolPerformanceCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryPoolPerformanceCreateInfoKHR32 *in_ext = (const VkQueryPoolPerformanceCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->queueFamilyIndex = in_ext->queueFamilyIndex;
            out_ext->counterIndexCount = in_ext->counterIndexCount;
            out_ext->pCounterIndices = (const uint32_t *)UlongToPtr(in_ext->pCounterIndices);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            VkQueryPoolPerformanceQueryCreateInfoINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryPoolPerformanceQueryCreateInfoINTEL32 *in_ext = (const VkQueryPoolPerformanceQueryCreateInfoINTEL32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
            out_ext->pNext = NULL;
            out_ext->performanceCountersSampling = in_ext->performanceCountersSampling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkRayTracingShaderGroupCreateInfoKHR_win32_to_host(const VkRayTracingShaderGroupCreateInfoKHR32 *in, VkRayTracingShaderGroupCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->generalShader = in->generalShader;
    out->closestHitShader = in->closestHitShader;
    out->anyHitShader = in->anyHitShader;
    out->intersectionShader = in->intersectionShader;
    out->pShaderGroupCaptureReplayHandle = (const void *)UlongToPtr(in->pShaderGroupCaptureReplayHandle);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkRayTracingShaderGroupCreateInfoKHR *convert_VkRayTracingShaderGroupCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingShaderGroupCreateInfoKHR32 *in, uint32_t count)
{
    VkRayTracingShaderGroupCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingShaderGroupCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineLibraryCreateInfoKHR_win32_to_host(const VkPipelineLibraryCreateInfoKHR32 *in, VkPipelineLibraryCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->libraryCount = in->libraryCount;
    out->pLibraries = (const VkPipeline *)UlongToPtr(in->pLibraries);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkPipelineLibraryCreateInfoKHR *convert_VkPipelineLibraryCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineLibraryCreateInfoKHR32 *in, uint32_t count)
{
    VkPipelineLibraryCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineLibraryCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRayTracingPipelineInterfaceCreateInfoKHR_win32_to_host(const VkRayTracingPipelineInterfaceCreateInfoKHR32 *in, VkRayTracingPipelineInterfaceCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->maxPipelineRayPayloadSize = in->maxPipelineRayPayloadSize;
    out->maxPipelineRayHitAttributeSize = in->maxPipelineRayHitAttributeSize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkRayTracingPipelineInterfaceCreateInfoKHR *convert_VkRayTracingPipelineInterfaceCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineInterfaceCreateInfoKHR32 *in, uint32_t count)
{
    VkRayTracingPipelineInterfaceCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineInterfaceCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkRayTracingPipelineCreateInfoKHR_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR *in, VkRayTracingPipelineCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = in->pGroups;
    out->maxPipelineRayRecursionDepth = in->maxPipelineRayRecursionDepth;
    out->pLibraryInfo = in->pLibraryInfo;
    out->pLibraryInterface = in->pLibraryInterface;
    out->pDynamicState = in->pDynamicState;
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;
}
#endif /* _WIN64 */

static inline void convert_VkRayTracingPipelineCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR32 *in, VkRayTracingPipelineCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = convert_VkRayTracingShaderGroupCreateInfoKHR_array_win32_to_host(ctx, (const VkRayTracingShaderGroupCreateInfoKHR32 *)UlongToPtr(in->pGroups), in->groupCount);
    out->maxPipelineRayRecursionDepth = in->maxPipelineRayRecursionDepth;
    out->pLibraryInfo = convert_VkPipelineLibraryCreateInfoKHR_array_win32_to_host(ctx, (const VkPipelineLibraryCreateInfoKHR32 *)UlongToPtr(in->pLibraryInfo), 1);
    out->pLibraryInterface = convert_VkRayTracingPipelineInterfaceCreateInfoKHR_array_win32_to_host(ctx, (const VkRayTracingPipelineInterfaceCreateInfoKHR32 *)UlongToPtr(in->pLibraryInterface), 1);
    out->pDynamicState = convert_VkPipelineDynamicStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineDynamicStateCreateInfo32 *)UlongToPtr(in->pDynamicState), 1);
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkPipelineCreateFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfoKHR32 *in_ext = (const VkPipelineCreateFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
            VkPipelineRobustnessCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfoEXT32 *in_ext = (const VkPipelineRobustnessCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkRayTracingPipelineCreateInfoKHR_host_to_win32(const VkRayTracingPipelineCreateInfoKHR *in, const VkRayTracingPipelineCreateInfoKHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkRayTracingPipelineCreateInfoKHR *convert_VkRayTracingPipelineCreateInfoKHR_array_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoKHR_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkRayTracingPipelineCreateInfoKHR *convert_VkRayTracingPipelineCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR32 *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRayTracingPipelineCreateInfoKHR_array_host_to_win32(const VkRayTracingPipelineCreateInfoKHR *in, const VkRayTracingPipelineCreateInfoKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkRayTracingShaderGroupCreateInfoNV_win32_to_host(const VkRayTracingShaderGroupCreateInfoNV32 *in, VkRayTracingShaderGroupCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->generalShader = in->generalShader;
    out->closestHitShader = in->closestHitShader;
    out->anyHitShader = in->anyHitShader;
    out->intersectionShader = in->intersectionShader;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkRayTracingShaderGroupCreateInfoNV *convert_VkRayTracingShaderGroupCreateInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingShaderGroupCreateInfoNV32 *in, uint32_t count)
{
    VkRayTracingShaderGroupCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingShaderGroupCreateInfoNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkRayTracingPipelineCreateInfoNV_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV *in, VkRayTracingPipelineCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = in->pGroups;
    out->maxRecursionDepth = in->maxRecursionDepth;
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;
}
#endif /* _WIN64 */

static inline void convert_VkRayTracingPipelineCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV32 *in, VkRayTracingPipelineCreateInfoNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = convert_VkRayTracingShaderGroupCreateInfoNV_array_win32_to_host(ctx, (const VkRayTracingShaderGroupCreateInfoNV32 *)UlongToPtr(in->pGroups), in->groupCount);
    out->maxRecursionDepth = in->maxRecursionDepth;
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkPipelineCreateFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfoKHR32 *in_ext = (const VkPipelineCreateFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkRayTracingPipelineCreateInfoNV_host_to_win32(const VkRayTracingPipelineCreateInfoNV *in, const VkRayTracingPipelineCreateInfoNV32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkRayTracingPipelineCreateInfoNV *convert_VkRayTracingPipelineCreateInfoNV_array_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoNV_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkRayTracingPipelineCreateInfoNV *convert_VkRayTracingPipelineCreateInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV32 *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoNV_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRayTracingPipelineCreateInfoNV_array_host_to_win32(const VkRayTracingPipelineCreateInfoNV *in, const VkRayTracingPipelineCreateInfoNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoNV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkSubpassDescription_win32_to_host(const VkSubpassDescription32 *in, VkSubpassDescription *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->inputAttachmentCount = in->inputAttachmentCount;
    out->pInputAttachments = (const VkAttachmentReference *)UlongToPtr(in->pInputAttachments);
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachments = (const VkAttachmentReference *)UlongToPtr(in->pColorAttachments);
    out->pResolveAttachments = (const VkAttachmentReference *)UlongToPtr(in->pResolveAttachments);
    out->pDepthStencilAttachment = (const VkAttachmentReference *)UlongToPtr(in->pDepthStencilAttachment);
    out->preserveAttachmentCount = in->preserveAttachmentCount;
    out->pPreserveAttachments = (const uint32_t *)UlongToPtr(in->pPreserveAttachments);
}

static inline const VkSubpassDescription *convert_VkSubpassDescription_array_win32_to_host(struct conversion_context *ctx, const VkSubpassDescription32 *in, uint32_t count)
{
    VkSubpassDescription *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassDescription_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRenderPassCreateInfo_win32_to_host(struct conversion_context *ctx, const VkRenderPassCreateInfo32 *in, VkRenderPassCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = (const VkAttachmentDescription *)UlongToPtr(in->pAttachments);
    out->subpassCount = in->subpassCount;
    out->pSubpasses = convert_VkSubpassDescription_array_win32_to_host(ctx, (const VkSubpassDescription32 *)UlongToPtr(in->pSubpasses), in->subpassCount);
    out->dependencyCount = in->dependencyCount;
    out->pDependencies = (const VkSubpassDependency *)UlongToPtr(in->pDependencies);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            VkRenderPassMultiviewCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassMultiviewCreateInfo32 *in_ext = (const VkRenderPassMultiviewCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->subpassCount = in_ext->subpassCount;
            out_ext->pViewMasks = (const uint32_t *)UlongToPtr(in_ext->pViewMasks);
            out_ext->dependencyCount = in_ext->dependencyCount;
            out_ext->pViewOffsets = (const int32_t *)UlongToPtr(in_ext->pViewOffsets);
            out_ext->correlationMaskCount = in_ext->correlationMaskCount;
            out_ext->pCorrelationMasks = (const uint32_t *)UlongToPtr(in_ext->pCorrelationMasks);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            VkRenderPassInputAttachmentAspectCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassInputAttachmentAspectCreateInfo32 *in_ext = (const VkRenderPassInputAttachmentAspectCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->aspectReferenceCount = in_ext->aspectReferenceCount;
            out_ext->pAspectReferences = (const VkInputAttachmentAspectReference *)UlongToPtr(in_ext->pAspectReferences);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            VkRenderPassFragmentDensityMapCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassFragmentDensityMapCreateInfoEXT32 *in_ext = (const VkRenderPassFragmentDensityMapCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapAttachment = in_ext->fragmentDensityMapAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkAttachmentDescription2_win32_to_host(struct conversion_context *ctx, const VkAttachmentDescription232 *in, VkAttachmentDescription2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->format = in->format;
    out->samples = in->samples;
    out->loadOp = in->loadOp;
    out->storeOp = in->storeOp;
    out->stencilLoadOp = in->stencilLoadOp;
    out->stencilStoreOp = in->stencilStoreOp;
    out->initialLayout = in->initialLayout;
    out->finalLayout = in->finalLayout;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            VkAttachmentDescriptionStencilLayout *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentDescriptionStencilLayout32 *in_ext = (const VkAttachmentDescriptionStencilLayout32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
            out_ext->pNext = NULL;
            out_ext->stencilInitialLayout = in_ext->stencilInitialLayout;
            out_ext->stencilFinalLayout = in_ext->stencilFinalLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkAttachmentDescription2 *convert_VkAttachmentDescription2_array_win32_to_host(struct conversion_context *ctx, const VkAttachmentDescription232 *in, uint32_t count)
{
    VkAttachmentDescription2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAttachmentDescription2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkAttachmentReference2_win32_to_host(struct conversion_context *ctx, const VkAttachmentReference232 *in, VkAttachmentReference2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->attachment = in->attachment;
    out->layout = in->layout;
    out->aspectMask = in->aspectMask;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            VkAttachmentReferenceStencilLayout *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentReferenceStencilLayout32 *in_ext = (const VkAttachmentReferenceStencilLayout32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
            out_ext->pNext = NULL;
            out_ext->stencilLayout = in_ext->stencilLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkAttachmentReference2 *convert_VkAttachmentReference2_array_win32_to_host(struct conversion_context *ctx, const VkAttachmentReference232 *in, uint32_t count)
{
    VkAttachmentReference2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAttachmentReference2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSubpassDescription2_win32_to_host(struct conversion_context *ctx, const VkSubpassDescription232 *in, VkSubpassDescription2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->viewMask = in->viewMask;
    out->inputAttachmentCount = in->inputAttachmentCount;
    out->pInputAttachments = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pInputAttachments), in->inputAttachmentCount);
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachments = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pColorAttachments), in->colorAttachmentCount);
    out->pResolveAttachments = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pResolveAttachments), in->colorAttachmentCount);
    out->pDepthStencilAttachment = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pDepthStencilAttachment), 1);
    out->preserveAttachmentCount = in->preserveAttachmentCount;
    out->pPreserveAttachments = (const uint32_t *)UlongToPtr(in->pPreserveAttachments);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            VkSubpassDescriptionDepthStencilResolve *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSubpassDescriptionDepthStencilResolve32 *in_ext = (const VkSubpassDescriptionDepthStencilResolve32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
            out_ext->pNext = NULL;
            out_ext->depthResolveMode = in_ext->depthResolveMode;
            out_ext->stencilResolveMode = in_ext->stencilResolveMode;
            out_ext->pDepthStencilResolveAttachment = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in_ext->pDepthStencilResolveAttachment), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            VkFragmentShadingRateAttachmentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFragmentShadingRateAttachmentInfoKHR32 *in_ext = (const VkFragmentShadingRateAttachmentInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pFragmentShadingRateAttachment = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in_ext->pFragmentShadingRateAttachment), 1);
            out_ext->shadingRateAttachmentTexelSize = in_ext->shadingRateAttachmentTexelSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
            VkMultisampledRenderToSingleSampledInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultisampledRenderToSingleSampledInfoEXT32 *in_ext = (const VkMultisampledRenderToSingleSampledInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampledEnable = in_ext->multisampledRenderToSingleSampledEnable;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
            VkRenderPassCreationControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassCreationControlEXT32 *in_ext = (const VkRenderPassCreationControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->disallowMerging = in_ext->disallowMerging;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
        {
            VkRenderPassSubpassFeedbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassSubpassFeedbackCreateInfoEXT32 *in_ext = (const VkRenderPassSubpassFeedbackCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->pSubpassFeedback = (VkRenderPassSubpassFeedbackInfoEXT *)UlongToPtr(in_ext->pSubpassFeedback);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkSubpassDescription2 *convert_VkSubpassDescription2_array_win32_to_host(struct conversion_context *ctx, const VkSubpassDescription232 *in, uint32_t count)
{
    VkSubpassDescription2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassDescription2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSubpassDependency2_win32_to_host(struct conversion_context *ctx, const VkSubpassDependency232 *in, VkSubpassDependency2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubpass = in->srcSubpass;
    out->dstSubpass = in->dstSubpass;
    out->srcStageMask = in->srcStageMask;
    out->dstStageMask = in->dstStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    out->dependencyFlags = in->dependencyFlags;
    out->viewOffset = in->viewOffset;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
        {
            VkMemoryBarrier2 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryBarrier232 *in_ext = (const VkMemoryBarrier232 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
            out_ext->pNext = NULL;
            out_ext->srcStageMask = in_ext->srcStageMask;
            out_ext->srcAccessMask = in_ext->srcAccessMask;
            out_ext->dstStageMask = in_ext->dstStageMask;
            out_ext->dstAccessMask = in_ext->dstAccessMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkSubpassDependency2 *convert_VkSubpassDependency2_array_win32_to_host(struct conversion_context *ctx, const VkSubpassDependency232 *in, uint32_t count)
{
    VkSubpassDependency2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassDependency2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkRenderPassCreateInfo2_win32_to_host(struct conversion_context *ctx, const VkRenderPassCreateInfo232 *in, VkRenderPassCreateInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = convert_VkAttachmentDescription2_array_win32_to_host(ctx, (const VkAttachmentDescription232 *)UlongToPtr(in->pAttachments), in->attachmentCount);
    out->subpassCount = in->subpassCount;
    out->pSubpasses = convert_VkSubpassDescription2_array_win32_to_host(ctx, (const VkSubpassDescription232 *)UlongToPtr(in->pSubpasses), in->subpassCount);
    out->dependencyCount = in->dependencyCount;
    out->pDependencies = convert_VkSubpassDependency2_array_win32_to_host(ctx, (const VkSubpassDependency232 *)UlongToPtr(in->pDependencies), in->dependencyCount);
    out->correlatedViewMaskCount = in->correlatedViewMaskCount;
    out->pCorrelatedViewMasks = (const uint32_t *)UlongToPtr(in->pCorrelatedViewMasks);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            VkRenderPassFragmentDensityMapCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassFragmentDensityMapCreateInfoEXT32 *in_ext = (const VkRenderPassFragmentDensityMapCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapAttachment = in_ext->fragmentDensityMapAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
            VkRenderPassCreationControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassCreationControlEXT32 *in_ext = (const VkRenderPassCreationControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->disallowMerging = in_ext->disallowMerging;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            VkRenderPassCreationFeedbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassCreationFeedbackCreateInfoEXT32 *in_ext = (const VkRenderPassCreationFeedbackCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->pRenderPassFeedback = (VkRenderPassCreationFeedbackInfoEXT *)UlongToPtr(in_ext->pRenderPassFeedback);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSamplerCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo32 *in, VkSamplerCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->magFilter = in->magFilter;
    out->minFilter = in->minFilter;
    out->mipmapMode = in->mipmapMode;
    out->addressModeU = in->addressModeU;
    out->addressModeV = in->addressModeV;
    out->addressModeW = in->addressModeW;
    out->mipLodBias = in->mipLodBias;
    out->anisotropyEnable = in->anisotropyEnable;
    out->maxAnisotropy = in->maxAnisotropy;
    out->compareEnable = in->compareEnable;
    out->compareOp = in->compareOp;
    out->minLod = in->minLod;
    out->maxLod = in->maxLod;
    out->borderColor = in->borderColor;
    out->unnormalizedCoordinates = in->unnormalizedCoordinates;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerYcbcrConversionInfo32 *in_ext = (const VkSamplerYcbcrConversionInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
            out_ext->pNext = NULL;
            out_ext->conversion = in_ext->conversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            VkSamplerReductionModeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerReductionModeCreateInfo32 *in_ext = (const VkSamplerReductionModeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->reductionMode = in_ext->reductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            VkSamplerCustomBorderColorCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerCustomBorderColorCreateInfoEXT32 *in_ext = (const VkSamplerCustomBorderColorCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColor = in_ext->customBorderColor;
            out_ext->format = in_ext->format;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
        {
            VkSamplerBorderColorComponentMappingCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *in_ext = (const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->components = in_ext->components;
            out_ext->srgb = in_ext->srgb;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = (const void *)UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
        {
            VkSamplerCubicWeightsCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerCubicWeightsCreateInfoQCOM32 *in_ext = (const VkSamplerCubicWeightsCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicWeights = in_ext->cubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
        {
            VkSamplerBlockMatchWindowCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerBlockMatchWindowCreateInfoQCOM32 *in_ext = (const VkSamplerBlockMatchWindowCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->windowExtent = in_ext->windowExtent;
            out_ext->windowCompareMode = in_ext->windowCompareMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerYcbcrConversionCreateInfo32 *in, VkSamplerYcbcrConversionCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->ycbcrModel = in->ycbcrModel;
    out->ycbcrRange = in->ycbcrRange;
    out->components = in->components;
    out->xChromaOffset = in->xChromaOffset;
    out->yChromaOffset = in->yChromaOffset;
    out->chromaFilter = in->chromaFilter;
    out->forceExplicitReconstruction = in->forceExplicitReconstruction;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
        {
            VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32 *in_ext = (const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->enableYDegamma = in_ext->enableYDegamma;
            out_ext->enableCbCrDegamma = in_ext->enableCbCrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkSemaphoreCreateInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreCreateInfo *in, VkSemaphoreCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            VkExportSemaphoreCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportSemaphoreCreateInfo *in_ext = (const VkExportSemaphoreCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo *in_ext = (const VkSemaphoreTypeCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
            VkQueryLowLatencySupportNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryLowLatencySupportNV *in_ext = (const VkQueryLowLatencySupportNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
            out_ext->pNext = NULL;
            out_ext->pQueriedLowLatencyData = in_ext->pQueriedLowLatencyData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreCreateInfo32 *in, VkSemaphoreCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            VkExportSemaphoreCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportSemaphoreCreateInfo32 *in_ext = (const VkExportSemaphoreCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo32 *in_ext = (const VkSemaphoreTypeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
            VkQueryLowLatencySupportNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryLowLatencySupportNV32 *in_ext = (const VkQueryLowLatencySupportNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
            out_ext->pNext = NULL;
            out_ext->pQueriedLowLatencyData = (void *)UlongToPtr(in_ext->pQueriedLowLatencyData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkShaderModuleCreateInfo_win32_to_host(struct conversion_context *ctx, const VkShaderModuleCreateInfo32 *in, VkShaderModuleCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->codeSize = in->codeSize;
    out->pCode = (const uint32_t *)UlongToPtr(in->pCode);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            VkShaderModuleValidationCacheCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleValidationCacheCreateInfoEXT32 *in_ext = (const VkShaderModuleValidationCacheCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->validationCache = in_ext->validationCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkShaderCreateInfoEXT_win32_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT32 *in, VkShaderCreateInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stage = in->stage;
    out->nextStage = in->nextStage;
    out->codeType = in->codeType;
    out->codeSize = in->codeSize;
    out->pCode = (const void *)UlongToPtr(in->pCode);
    out->pName = (const char *)UlongToPtr(in->pName);
    out->setLayoutCount = in->setLayoutCount;
    out->pSetLayouts = (const VkDescriptorSetLayout *)UlongToPtr(in->pSetLayouts);
    out->pushConstantRangeCount = in->pushConstantRangeCount;
    out->pPushConstantRanges = (const VkPushConstantRange *)UlongToPtr(in->pPushConstantRanges);
    out->pSpecializationInfo = convert_VkSpecializationInfo_array_win32_to_host(ctx, (const VkSpecializationInfo32 *)UlongToPtr(in->pSpecializationInfo), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline const VkShaderCreateInfoEXT *convert_VkShaderCreateInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT32 *in, uint32_t count)
{
    VkShaderCreateInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkShaderCreateInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSwapchainCreateInfoKHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainCreateInfoKHR32 *in, VkSwapchainCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->surface = in->surface;
    out->minImageCount = in->minImageCount;
    out->imageFormat = in->imageFormat;
    out->imageColorSpace = in->imageColorSpace;
    out->imageExtent = in->imageExtent;
    out->imageArrayLayers = in->imageArrayLayers;
    out->imageUsage = in->imageUsage;
    out->imageSharingMode = in->imageSharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = (const uint32_t *)UlongToPtr(in->pQueueFamilyIndices);
    out->preTransform = in->preTransform;
    out->compositeAlpha = in->compositeAlpha;
    out->presentMode = in->presentMode;
    out->clipped = in->clipped;
    out->oldSwapchain = in->oldSwapchain;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            VkDeviceGroupSwapchainCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSwapchainCreateInfoKHR32 *in_ext = (const VkDeviceGroupSwapchainCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->modes = in_ext->modes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo32 *in_ext = (const VkImageFormatListCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = (const VkFormat *)UlongToPtr(in_ext->pViewFormats);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
        {
            VkSwapchainPresentBarrierCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentBarrierCreateInfoNV32 *in_ext = (const VkSwapchainPresentBarrierCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrierEnable = in_ext->presentBarrierEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT32 *in_ext = (const VkImageCompressionControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = (VkImageCompressionFixedRateFlagsEXT *)UlongToPtr(in_ext->pFixedRateFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
        {
            VkSwapchainPresentModesCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentModesCreateInfoEXT32 *in_ext = (const VkSwapchainPresentModesCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = (const VkPresentModeKHR *)UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
        {
            VkSwapchainPresentScalingCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentScalingCreateInfoEXT32 *in_ext = (const VkSwapchainPresentScalingCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->scalingBehavior = in_ext->scalingBehavior;
            out_ext->presentGravityX = in_ext->presentGravityX;
            out_ext->presentGravityY = in_ext->presentGravityY;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV:
        {
            VkSwapchainLatencyCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainLatencyCreateInfoNV32 *in_ext = (const VkSwapchainLatencyCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->latencyModeEnable = in_ext->latencyModeEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkValidationCacheCreateInfoEXT_win32_to_host(const VkValidationCacheCreateInfoEXT32 *in, VkValidationCacheCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->initialDataSize = in->initialDataSize;
    out->pInitialData = (const void *)UlongToPtr(in->pInitialData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkWin32SurfaceCreateInfoKHR_win32_to_host(const VkWin32SurfaceCreateInfoKHR32 *in, VkWin32SurfaceCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->hinstance = (HINSTANCE)UlongToPtr(in->hinstance);
    out->hwnd = (HWND)UlongToPtr(in->hwnd);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline void convert_VkDebugMarkerObjectNameInfoEXT_win64_to_host(const VkDebugMarkerObjectNameInfoEXT *in, VkDebugMarkerObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->pObjectName = in->pObjectName;
}
#endif /* _WIN64 */

static inline void convert_VkDebugMarkerObjectNameInfoEXT_win32_to_host(const VkDebugMarkerObjectNameInfoEXT32 *in, VkDebugMarkerObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->pObjectName = (const char *)UlongToPtr(in->pObjectName);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline void convert_VkDebugMarkerObjectTagInfoEXT_win64_to_host(const VkDebugMarkerObjectTagInfoEXT *in, VkDebugMarkerObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = in->pTag;
}
#endif /* _WIN64 */

static inline void convert_VkDebugMarkerObjectTagInfoEXT_win32_to_host(const VkDebugMarkerObjectTagInfoEXT32 *in, VkDebugMarkerObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = (const void *)UlongToPtr(in->pTag);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPhysicalDevice_array_unwrapped_host_to_win32(const VkPhysicalDevice *in, PTR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        out[i] = PtrToUlong(in[i]);
    }
}

static inline void convert_VkPhysicalDeviceGroupProperties_win32_to_unwrapped_host(const VkPhysicalDeviceGroupProperties32 *in, VkPhysicalDeviceGroupProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPhysicalDeviceGroupProperties_unwrapped_host_to_win32(const VkPhysicalDeviceGroupProperties *in, VkPhysicalDeviceGroupProperties32 *out)
{
    if (!in) return;

    out->physicalDeviceCount = in->physicalDeviceCount;
    convert_VkPhysicalDevice_array_unwrapped_host_to_win32(in->physicalDevices, out->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE);
    out->subsetAllocation = in->subsetAllocation;
}

static inline VkPhysicalDeviceGroupProperties *convert_VkPhysicalDeviceGroupProperties_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPhysicalDeviceGroupProperties32 *in, uint32_t count)
{
    VkPhysicalDeviceGroupProperties *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceGroupProperties_win32_to_unwrapped_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPhysicalDeviceGroupProperties_array_unwrapped_host_to_win32(const VkPhysicalDeviceGroupProperties *in, VkPhysicalDeviceGroupProperties32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceGroupProperties_unwrapped_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPerformanceCounterKHR_win32_to_host(const VkPerformanceCounterKHR32 *in, VkPerformanceCounterKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPerformanceCounterKHR_host_to_win32(const VkPerformanceCounterKHR *in, VkPerformanceCounterKHR32 *out)
{
    if (!in) return;

    out->unit = in->unit;
    out->scope = in->scope;
    out->storage = in->storage;
    memcpy(out->uuid, in->uuid, VK_UUID_SIZE * sizeof(uint8_t));
}

static inline VkPerformanceCounterKHR *convert_VkPerformanceCounterKHR_array_win32_to_host(struct conversion_context *ctx, const VkPerformanceCounterKHR32 *in, uint32_t count)
{
    VkPerformanceCounterKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPerformanceCounterKHR_array_host_to_win32(const VkPerformanceCounterKHR *in, VkPerformanceCounterKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPerformanceCounterDescriptionKHR_win32_to_host(const VkPerformanceCounterDescriptionKHR32 *in, VkPerformanceCounterDescriptionKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPerformanceCounterDescriptionKHR_host_to_win32(const VkPerformanceCounterDescriptionKHR *in, VkPerformanceCounterDescriptionKHR32 *out)
{
    if (!in) return;

    out->flags = in->flags;
    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->category, in->category, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

static inline VkPerformanceCounterDescriptionKHR *convert_VkPerformanceCounterDescriptionKHR_array_win32_to_host(struct conversion_context *ctx, const VkPerformanceCounterDescriptionKHR32 *in, uint32_t count)
{
    VkPerformanceCounterDescriptionKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterDescriptionKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPerformanceCounterDescriptionKHR_array_host_to_win32(const VkPerformanceCounterDescriptionKHR *in, VkPerformanceCounterDescriptionKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterDescriptionKHR_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static inline void convert_VkMappedMemoryRange_win64_to_host(const VkMappedMemoryRange *in, VkMappedMemoryRange *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->offset = in->offset;
    out->size = in->size;
}
#endif /* _WIN64 */

static inline void convert_VkMappedMemoryRange_win32_to_host(const VkMappedMemoryRange32 *in, VkMappedMemoryRange *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->offset = in->offset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline const VkMappedMemoryRange *convert_VkMappedMemoryRange_array_win64_to_host(struct conversion_context *ctx, const VkMappedMemoryRange *in, uint32_t count)
{
    VkMappedMemoryRange *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMappedMemoryRange_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkMappedMemoryRange *convert_VkMappedMemoryRange_array_win32_to_host(struct conversion_context *ctx, const VkMappedMemoryRange32 *in, uint32_t count)
{
    VkMappedMemoryRange *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMappedMemoryRange_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkAccelerationStructureBuildSizesInfoKHR_win32_to_host(const VkAccelerationStructureBuildSizesInfoKHR32 *in, VkAccelerationStructureBuildSizesInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructureSize = in->accelerationStructureSize;
    out->updateScratchSize = in->updateScratchSize;
    out->buildScratchSize = in->buildScratchSize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAccelerationStructureBuildSizesInfoKHR_host_to_win32(const VkAccelerationStructureBuildSizesInfoKHR *in, VkAccelerationStructureBuildSizesInfoKHR32 *out)
{
    if (!in) return;

    out->accelerationStructureSize = in->accelerationStructureSize;
    out->updateScratchSize = in->updateScratchSize;
    out->buildScratchSize = in->buildScratchSize;
}

static inline void convert_VkAccelerationStructureDeviceAddressInfoKHR_win32_to_host(const VkAccelerationStructureDeviceAddressInfoKHR32 *in, VkAccelerationStructureDeviceAddressInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructure = in->accelerationStructure;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkAccelerationStructureMemoryRequirementsInfoNV_win32_to_host(const VkAccelerationStructureMemoryRequirementsInfoNV32 *in, VkAccelerationStructureMemoryRequirementsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->accelerationStructure = in->accelerationStructure;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryRequirements_host_to_win32(const VkMemoryRequirements *in, VkMemoryRequirements32 *out)
{
    if (!in) return;

    out->size = in->size;
    out->alignment = in->alignment;
    out->memoryTypeBits = in->memoryTypeBits;
}

static inline void convert_VkMemoryRequirements2KHR_win32_to_host(const VkMemoryRequirements2KHR32 *in, VkMemoryRequirements2KHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryRequirements2KHR_host_to_win32(const VkMemoryRequirements2KHR *in, VkMemoryRequirements2KHR32 *out)
{
    if (!in) return;

    convert_VkMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);
}

static inline void convert_VkAccelerationStructureCaptureDescriptorDataInfoEXT_win32_to_host(const VkAccelerationStructureCaptureDescriptorDataInfoEXT32 *in, VkAccelerationStructureCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructure = in->accelerationStructure;
    out->accelerationStructureNV = in->accelerationStructureNV;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkBufferDeviceAddressInfo_win32_to_host(const VkBufferDeviceAddressInfo32 *in, VkBufferDeviceAddressInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkBufferMemoryRequirementsInfo2_win32_to_host(const VkBufferMemoryRequirementsInfo232 *in, VkBufferMemoryRequirementsInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryRequirements2_win32_to_host(struct conversion_context *ctx, const VkMemoryRequirements232 *in, VkMemoryRequirements2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            VkMemoryDedicatedRequirements *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkMemoryRequirements2_host_to_win32(const VkMemoryRequirements2 *in, VkMemoryRequirements232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            VkMemoryDedicatedRequirements32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS);
            const VkMemoryDedicatedRequirements *in_ext = (const VkMemoryDedicatedRequirements *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
            out_ext->prefersDedicatedAllocation = in_ext->prefersDedicatedAllocation;
            out_ext->requiresDedicatedAllocation = in_ext->requiresDedicatedAllocation;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkBufferCaptureDescriptorDataInfoEXT_win32_to_host(const VkBufferCaptureDescriptorDataInfoEXT32 *in, VkBufferCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCalibratedTimestampInfoEXT_win32_to_host(const VkCalibratedTimestampInfoEXT32 *in, VkCalibratedTimestampInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->timeDomain = in->timeDomain;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkCalibratedTimestampInfoEXT *convert_VkCalibratedTimestampInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkCalibratedTimestampInfoEXT32 *in, uint32_t count)
{
    VkCalibratedTimestampInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCalibratedTimestampInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDescriptorAddressInfoEXT_win32_to_host(const VkDescriptorAddressInfoEXT32 *in, VkDescriptorAddressInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->address = in->address;
    out->range = in->range;
    out->format = in->format;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkDescriptorAddressInfoEXT *convert_VkDescriptorAddressInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorAddressInfoEXT32 *in, uint32_t count)
{
    VkDescriptorAddressInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorAddressInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDescriptorDataEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorDataEXT32 *in, VkDescriptorDataEXT *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_DESCRIPTOR_TYPE_SAMPLER)
        out->pSampler = (const VkSampler *)UlongToPtr(in->pSampler);
    if (selector == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER)
        out->pCombinedImageSampler = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pCombinedImageSampler), 1);
    if (selector == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT)
        out->pInputAttachmentImage = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pInputAttachmentImage), 1);
    if (selector == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE)
        out->pSampledImage = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pSampledImage), 1);
    if (selector == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE)
        out->pStorageImage = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pStorageImage), 1);
    if (selector == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER)
        out->pUniformTexelBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pUniformTexelBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
        out->pStorageTexelBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pStorageTexelBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER)
        out->pUniformBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pUniformBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER)
        out->pStorageBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pStorageBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR || selector == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV)
        out->accelerationStructure = in->accelerationStructure;
}

static inline void convert_VkDescriptorGetInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorGetInfoEXT32 *in, VkDescriptorGetInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    convert_VkDescriptorDataEXT_win32_to_host(ctx, &in->data, &out->data, in->type);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDescriptorSetBindingReferenceVALVE_win32_to_host(const VkDescriptorSetBindingReferenceVALVE32 *in, VkDescriptorSetBindingReferenceVALVE *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorSetLayout = in->descriptorSetLayout;
    out->binding = in->binding;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDescriptorSetLayoutHostMappingInfoVALVE_win32_to_host(const VkDescriptorSetLayoutHostMappingInfoVALVE32 *in, VkDescriptorSetLayoutHostMappingInfoVALVE *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorOffset = in->descriptorOffset;
    out->descriptorSize = in->descriptorSize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDescriptorSetLayoutHostMappingInfoVALVE_host_to_win32(const VkDescriptorSetLayoutHostMappingInfoVALVE *in, VkDescriptorSetLayoutHostMappingInfoVALVE32 *out)
{
    if (!in) return;

    out->descriptorOffset = in->descriptorOffset;
    out->descriptorSize = in->descriptorSize;
}

static inline void convert_VkDescriptorSetLayoutSupport_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetLayoutSupport32 *in, VkDescriptorSetLayoutSupport *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            VkDescriptorSetVariableDescriptorCountLayoutSupport *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkDescriptorSetLayoutSupport_host_to_win32(const VkDescriptorSetLayoutSupport *in, VkDescriptorSetLayoutSupport32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->supported = in->supported;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            VkDescriptorSetVariableDescriptorCountLayoutSupport32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT);
            const VkDescriptorSetVariableDescriptorCountLayoutSupport *in_ext = (const VkDescriptorSetVariableDescriptorCountLayoutSupport *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
            out_ext->maxVariableDescriptorCount = in_ext->maxVariableDescriptorCount;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkAccelerationStructureVersionInfoKHR_win32_to_host(const VkAccelerationStructureVersionInfoKHR32 *in, VkAccelerationStructureVersionInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pVersionData = (const uint8_t *)UlongToPtr(in->pVersionData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline const VkBufferCreateInfo *convert_VkBufferCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkBufferCreateInfo *in, uint32_t count)
{
    VkBufferCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkBufferCreateInfo *convert_VkBufferCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkBufferCreateInfo32 *in, uint32_t count)
{
    VkBufferCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkDeviceBufferMemoryRequirements_win64_to_host(struct conversion_context *ctx, const VkDeviceBufferMemoryRequirements *in, VkDeviceBufferMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->pCreateInfo = convert_VkBufferCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
}
#endif /* _WIN64 */

static inline void convert_VkDeviceBufferMemoryRequirements_win32_to_host(struct conversion_context *ctx, const VkDeviceBufferMemoryRequirements32 *in, VkDeviceBufferMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkBufferCreateInfo_array_win32_to_host(ctx, (const VkBufferCreateInfo32 *)UlongToPtr(in->pCreateInfo), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDeviceFaultCountsEXT_win32_to_host(const VkDeviceFaultCountsEXT32 *in, VkDeviceFaultCountsEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->addressInfoCount = in->addressInfoCount;
    out->vendorInfoCount = in->vendorInfoCount;
    out->vendorBinarySize = in->vendorBinarySize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDeviceFaultCountsEXT_host_to_win32(const VkDeviceFaultCountsEXT *in, VkDeviceFaultCountsEXT32 *out)
{
    if (!in) return;

    out->addressInfoCount = in->addressInfoCount;
    out->vendorInfoCount = in->vendorInfoCount;
    out->vendorBinarySize = in->vendorBinarySize;
}

static inline void convert_VkDeviceFaultAddressInfoEXT_win32_to_host(const VkDeviceFaultAddressInfoEXT32 *in, VkDeviceFaultAddressInfoEXT *out)
{
    if (!in) return;

    out->addressType = in->addressType;
    out->reportedAddress = in->reportedAddress;
    out->addressPrecision = in->addressPrecision;
}

static inline void convert_VkDeviceFaultAddressInfoEXT_host_to_win32(const VkDeviceFaultAddressInfoEXT *in, VkDeviceFaultAddressInfoEXT32 *out)
{
    if (!in) return;

    out->addressType = in->addressType;
    out->reportedAddress = in->reportedAddress;
    out->addressPrecision = in->addressPrecision;
}

static inline VkDeviceFaultAddressInfoEXT *convert_VkDeviceFaultAddressInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDeviceFaultAddressInfoEXT32 *in, uint32_t count)
{
    VkDeviceFaultAddressInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultAddressInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDeviceFaultAddressInfoEXT_array_host_to_win32(const VkDeviceFaultAddressInfoEXT *in, VkDeviceFaultAddressInfoEXT32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultAddressInfoEXT_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkDeviceFaultVendorInfoEXT_win32_to_host(const VkDeviceFaultVendorInfoEXT32 *in, VkDeviceFaultVendorInfoEXT *out)
{
    if (!in) return;

    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->vendorFaultCode = in->vendorFaultCode;
    out->vendorFaultData = in->vendorFaultData;
}

static inline void convert_VkDeviceFaultVendorInfoEXT_host_to_win32(const VkDeviceFaultVendorInfoEXT *in, VkDeviceFaultVendorInfoEXT32 *out)
{
    if (!in) return;

    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->vendorFaultCode = in->vendorFaultCode;
    out->vendorFaultData = in->vendorFaultData;
}

static inline VkDeviceFaultVendorInfoEXT *convert_VkDeviceFaultVendorInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDeviceFaultVendorInfoEXT32 *in, uint32_t count)
{
    VkDeviceFaultVendorInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultVendorInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkDeviceFaultVendorInfoEXT_array_host_to_win32(const VkDeviceFaultVendorInfoEXT *in, VkDeviceFaultVendorInfoEXT32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultVendorInfoEXT_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkDeviceFaultInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDeviceFaultInfoEXT32 *in, VkDeviceFaultInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->pAddressInfos = convert_VkDeviceFaultAddressInfoEXT_array_win32_to_host(ctx, (VkDeviceFaultAddressInfoEXT32 *)UlongToPtr(in->pAddressInfos), 1);
    out->pVendorInfos = convert_VkDeviceFaultVendorInfoEXT_array_win32_to_host(ctx, (VkDeviceFaultVendorInfoEXT32 *)UlongToPtr(in->pVendorInfos), 1);
    out->pVendorBinaryData = (void *)UlongToPtr(in->pVendorBinaryData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDeviceFaultInfoEXT_host_to_win32(const VkDeviceFaultInfoEXT *in, VkDeviceFaultInfoEXT32 *out)
{
    if (!in) return;

    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    convert_VkDeviceFaultAddressInfoEXT_array_host_to_win32(in->pAddressInfos, (VkDeviceFaultAddressInfoEXT32 *)UlongToPtr(out->pAddressInfos), 1);
    convert_VkDeviceFaultVendorInfoEXT_array_host_to_win32(in->pVendorInfos, (VkDeviceFaultVendorInfoEXT32 *)UlongToPtr(out->pVendorInfos), 1);
    out->pVendorBinaryData = PtrToUlong(in->pVendorBinaryData);
}

static inline void convert_VkDeviceGroupPresentCapabilitiesKHR_win32_to_host(const VkDeviceGroupPresentCapabilitiesKHR32 *in, VkDeviceGroupPresentCapabilitiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDeviceGroupPresentCapabilitiesKHR_host_to_win32(const VkDeviceGroupPresentCapabilitiesKHR *in, VkDeviceGroupPresentCapabilitiesKHR32 *out)
{
    if (!in) return;

    memcpy(out->presentMask, in->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    out->modes = in->modes;
}

#ifdef _WIN64
static inline const VkImageCreateInfo *convert_VkImageCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkImageCreateInfo *in, uint32_t count)
{
    VkImageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkImageCreateInfo *convert_VkImageCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, uint32_t count)
{
    VkImageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkDeviceImageMemoryRequirements_win64_to_host(struct conversion_context *ctx, const VkDeviceImageMemoryRequirements *in, VkDeviceImageMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
    out->planeAspect = in->planeAspect;
}
#endif /* _WIN64 */

static inline void convert_VkDeviceImageMemoryRequirements_win32_to_host(struct conversion_context *ctx, const VkDeviceImageMemoryRequirements32 *in, VkDeviceImageMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(in->pCreateInfo), 1);
    out->planeAspect = in->planeAspect;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSparseImageMemoryRequirements_host_to_win32(const VkSparseImageMemoryRequirements *in, VkSparseImageMemoryRequirements32 *out)
{
    if (!in) return;

    out->formatProperties = in->formatProperties;
    out->imageMipTailFirstLod = in->imageMipTailFirstLod;
    out->imageMipTailSize = in->imageMipTailSize;
    out->imageMipTailOffset = in->imageMipTailOffset;
    out->imageMipTailStride = in->imageMipTailStride;
}

static inline void convert_VkSparseImageMemoryRequirements2_win32_to_host(const VkSparseImageMemoryRequirements232 *in, VkSparseImageMemoryRequirements2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSparseImageMemoryRequirements2_host_to_win32(const VkSparseImageMemoryRequirements2 *in, VkSparseImageMemoryRequirements232 *out)
{
    if (!in) return;

    convert_VkSparseImageMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);
}

static inline VkSparseImageMemoryRequirements2 *convert_VkSparseImageMemoryRequirements2_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryRequirements232 *in, uint32_t count)
{
    VkSparseImageMemoryRequirements2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryRequirements2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSparseImageMemoryRequirements2_array_host_to_win32(const VkSparseImageMemoryRequirements2 *in, VkSparseImageMemoryRequirements232 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryRequirements2_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkImageSubresource2KHR_win32_to_host(const VkImageSubresource2KHR32 *in, VkImageSubresource2KHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageSubresource = in->imageSubresource;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkImageSubresource2KHR *convert_VkImageSubresource2KHR_array_win32_to_host(struct conversion_context *ctx, const VkImageSubresource2KHR32 *in, uint32_t count)
{
    VkImageSubresource2KHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageSubresource2KHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkDeviceImageSubresourceInfoKHR_win64_to_host(struct conversion_context *ctx, const VkDeviceImageSubresourceInfoKHR *in, VkDeviceImageSubresourceInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
    out->pSubresource = in->pSubresource;
}
#endif /* _WIN64 */

static inline void convert_VkDeviceImageSubresourceInfoKHR_win32_to_host(struct conversion_context *ctx, const VkDeviceImageSubresourceInfoKHR32 *in, VkDeviceImageSubresourceInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(in->pCreateInfo), 1);
    out->pSubresource = convert_VkImageSubresource2KHR_array_win32_to_host(ctx, (const VkImageSubresource2KHR32 *)UlongToPtr(in->pSubresource), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSubresourceLayout_win32_to_host(const VkSubresourceLayout32 *in, VkSubresourceLayout *out)
{
    if (!in) return;

    out->offset = in->offset;
    out->size = in->size;
    out->rowPitch = in->rowPitch;
    out->arrayPitch = in->arrayPitch;
    out->depthPitch = in->depthPitch;
}

static inline void convert_VkSubresourceLayout_host_to_win32(const VkSubresourceLayout *in, VkSubresourceLayout32 *out)
{
    if (!in) return;

    out->offset = in->offset;
    out->size = in->size;
    out->rowPitch = in->rowPitch;
    out->arrayPitch = in->arrayPitch;
    out->depthPitch = in->depthPitch;
}

static inline void convert_VkSubresourceLayout2KHR_win32_to_host(struct conversion_context *ctx, const VkSubresourceLayout2KHR32 *in, VkSubresourceLayout2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT:
        {
            VkSubresourceHostMemcpySizeEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSubresourceLayout2KHR_host_to_win32(const VkSubresourceLayout2KHR *in, VkSubresourceLayout2KHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkSubresourceLayout_host_to_win32(&in->subresourceLayout, &out->subresourceLayout);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT:
        {
            VkSubresourceHostMemcpySizeEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT);
            const VkSubresourceHostMemcpySizeEXT *in_ext = (const VkSubresourceHostMemcpySizeEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT;
            out_ext->size = in_ext->size;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT);
            const VkImageCompressionPropertiesEXT *in_ext = (const VkImageCompressionPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->imageCompressionFlags = in_ext->imageCompressionFlags;
            out_ext->imageCompressionFixedRateFlags = in_ext->imageCompressionFixedRateFlags;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win64_to_host(const VkDeviceMemoryOpaqueCaptureAddressInfo *in, VkDeviceMemoryOpaqueCaptureAddressInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
}
#endif /* _WIN64 */

static inline void convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host(const VkDeviceMemoryOpaqueCaptureAddressInfo32 *in, VkDeviceMemoryOpaqueCaptureAddressInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMicromapVersionInfoEXT_win32_to_host(const VkMicromapVersionInfoEXT32 *in, VkMicromapVersionInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pVersionData = (const uint8_t *)UlongToPtr(in->pVersionData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkDeviceQueueInfo2_win32_to_host(const VkDeviceQueueInfo232 *in, VkDeviceQueueInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->queueIndex = in->queueIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkTilePropertiesQCOM_win32_to_host(const VkTilePropertiesQCOM32 *in, VkTilePropertiesQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tileSize = in->tileSize;
    out->apronSize = in->apronSize;
    out->origin = in->origin;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkTilePropertiesQCOM_host_to_win32(const VkTilePropertiesQCOM *in, VkTilePropertiesQCOM32 *out)
{
    if (!in) return;

    out->tileSize = in->tileSize;
    out->apronSize = in->apronSize;
    out->origin = in->origin;
}

static inline VkTilePropertiesQCOM *convert_VkTilePropertiesQCOM_array_win32_to_host(struct conversion_context *ctx, const VkTilePropertiesQCOM32 *in, uint32_t count)
{
    VkTilePropertiesQCOM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkTilePropertiesQCOM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkTilePropertiesQCOM_array_host_to_win32(const VkTilePropertiesQCOM *in, VkTilePropertiesQCOM32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkTilePropertiesQCOM_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkGeneratedCommandsMemoryRequirementsInfoNV_win32_to_host(const VkGeneratedCommandsMemoryRequirementsInfoNV32 *in, VkGeneratedCommandsMemoryRequirementsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipeline = in->pipeline;
    out->indirectCommandsLayout = in->indirectCommandsLayout;
    out->maxSequencesCount = in->maxSequencesCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImageMemoryRequirementsInfo2_win32_to_host(struct conversion_context *ctx, const VkImageMemoryRequirementsInfo232 *in, VkImageMemoryRequirementsInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            VkImagePlaneMemoryRequirementsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImagePlaneMemoryRequirementsInfo32 *in_ext = (const VkImagePlaneMemoryRequirementsInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
            out_ext->pNext = NULL;
            out_ext->planeAspect = in_ext->planeAspect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkImageCaptureDescriptorDataInfoEXT_win32_to_host(const VkImageCaptureDescriptorDataInfoEXT32 *in, VkImageCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSparseImageMemoryRequirements_array_host_to_win32(const VkSparseImageMemoryRequirements *in, VkSparseImageMemoryRequirements32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryRequirements_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host(const VkImageSparseMemoryRequirementsInfo232 *in, VkImageSparseMemoryRequirementsInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImageViewAddressPropertiesNVX_win32_to_host(const VkImageViewAddressPropertiesNVX32 *in, VkImageViewAddressPropertiesNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImageViewAddressPropertiesNVX_host_to_win32(const VkImageViewAddressPropertiesNVX *in, VkImageViewAddressPropertiesNVX32 *out)
{
    if (!in) return;

    out->deviceAddress = in->deviceAddress;
    out->size = in->size;
}

static inline void convert_VkImageViewHandleInfoNVX_win32_to_host(const VkImageViewHandleInfoNVX32 *in, VkImageViewHandleInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageView = in->imageView;
    out->descriptorType = in->descriptorType;
    out->sampler = in->sampler;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImageViewCaptureDescriptorDataInfoEXT_win32_to_host(const VkImageViewCaptureDescriptorDataInfoEXT32 *in, VkImageViewCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageView = in->imageView;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkLatencyTimingsFrameReportNV_win32_to_host(const VkLatencyTimingsFrameReportNV32 *in, VkLatencyTimingsFrameReportNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->presentID = in->presentID;
    out->inputSampleTimeUs = in->inputSampleTimeUs;
    out->simStartTimeUs = in->simStartTimeUs;
    out->simEndTimeUs = in->simEndTimeUs;
    out->renderSubmitStartTimeUs = in->renderSubmitStartTimeUs;
    out->renderSubmitEndTimeUs = in->renderSubmitEndTimeUs;
    out->presentStartTimeUs = in->presentStartTimeUs;
    out->presentEndTimeUs = in->presentEndTimeUs;
    out->driverStartTimeUs = in->driverStartTimeUs;
    out->driverEndTimeUs = in->driverEndTimeUs;
    out->osRenderQueueStartTimeUs = in->osRenderQueueStartTimeUs;
    out->osRenderQueueEndTimeUs = in->osRenderQueueEndTimeUs;
    out->gpuRenderStartTimeUs = in->gpuRenderStartTimeUs;
    out->gpuRenderEndTimeUs = in->gpuRenderEndTimeUs;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkLatencyTimingsFrameReportNV_host_to_win32(const VkLatencyTimingsFrameReportNV *in, VkLatencyTimingsFrameReportNV32 *out)
{
    if (!in) return;

    out->presentID = in->presentID;
    out->inputSampleTimeUs = in->inputSampleTimeUs;
    out->simStartTimeUs = in->simStartTimeUs;
    out->simEndTimeUs = in->simEndTimeUs;
    out->renderSubmitStartTimeUs = in->renderSubmitStartTimeUs;
    out->renderSubmitEndTimeUs = in->renderSubmitEndTimeUs;
    out->presentStartTimeUs = in->presentStartTimeUs;
    out->presentEndTimeUs = in->presentEndTimeUs;
    out->driverStartTimeUs = in->driverStartTimeUs;
    out->driverEndTimeUs = in->driverEndTimeUs;
    out->osRenderQueueStartTimeUs = in->osRenderQueueStartTimeUs;
    out->osRenderQueueEndTimeUs = in->osRenderQueueEndTimeUs;
    out->gpuRenderStartTimeUs = in->gpuRenderStartTimeUs;
    out->gpuRenderEndTimeUs = in->gpuRenderEndTimeUs;
}

static inline VkLatencyTimingsFrameReportNV *convert_VkLatencyTimingsFrameReportNV_array_win32_to_host(struct conversion_context *ctx, const VkLatencyTimingsFrameReportNV32 *in, uint32_t count)
{
    VkLatencyTimingsFrameReportNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkLatencyTimingsFrameReportNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkLatencyTimingsFrameReportNV_array_host_to_win32(const VkLatencyTimingsFrameReportNV *in, VkLatencyTimingsFrameReportNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkLatencyTimingsFrameReportNV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkGetLatencyMarkerInfoNV_win32_to_host(struct conversion_context *ctx, const VkGetLatencyMarkerInfoNV32 *in, VkGetLatencyMarkerInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pTimings = convert_VkLatencyTimingsFrameReportNV_array_win32_to_host(ctx, (VkLatencyTimingsFrameReportNV32 *)UlongToPtr(in->pTimings), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkGetLatencyMarkerInfoNV_host_to_win32(const VkGetLatencyMarkerInfoNV *in, VkGetLatencyMarkerInfoNV32 *out)
{
    if (!in) return;

    convert_VkLatencyTimingsFrameReportNV_array_host_to_win32(in->pTimings, (VkLatencyTimingsFrameReportNV32 *)UlongToPtr(out->pTimings), 1);
}

#ifdef _WIN64
static inline void convert_VkMemoryGetFdInfoKHR_win64_to_host(const VkMemoryGetFdInfoKHR *in, VkMemoryGetFdInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->handleType = in->handleType;
}
#endif /* _WIN64 */

static inline void convert_VkMemoryGetFdInfoKHR_win32_to_host(const VkMemoryGetFdInfoKHR32 *in, VkMemoryGetFdInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->memory : VK_NULL_HANDLE;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryFdPropertiesKHR_win32_to_host(const VkMemoryFdPropertiesKHR32 *in, VkMemoryFdPropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryFdPropertiesKHR_host_to_win32(const VkMemoryFdPropertiesKHR *in, VkMemoryFdPropertiesKHR32 *out)
{
    if (!in) return;

    out->memoryTypeBits = in->memoryTypeBits;
}

static inline void convert_VkMemoryHostPointerPropertiesEXT_win32_to_host(const VkMemoryHostPointerPropertiesEXT32 *in, VkMemoryHostPointerPropertiesEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryHostPointerPropertiesEXT_host_to_win32(const VkMemoryHostPointerPropertiesEXT *in, VkMemoryHostPointerPropertiesEXT32 *out)
{
    if (!in) return;

    out->memoryTypeBits = in->memoryTypeBits;
}

static inline void convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkMemoryGetWin32HandleInfoKHR32 *in, VkMemoryGetWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = in->memory;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host(const VkMemoryWin32HandlePropertiesKHR32 *in, VkMemoryWin32HandlePropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(const VkMemoryWin32HandlePropertiesKHR *in, VkMemoryWin32HandlePropertiesKHR32 *out)
{
    if (!in) return;

    out->memoryTypeBits = in->memoryTypeBits;
}

static inline void convert_VkMicromapBuildSizesInfoEXT_win32_to_host(const VkMicromapBuildSizesInfoEXT32 *in, VkMicromapBuildSizesInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->micromapSize = in->micromapSize;
    out->buildScratchSize = in->buildScratchSize;
    out->discardable = in->discardable;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMicromapBuildSizesInfoEXT_host_to_win32(const VkMicromapBuildSizesInfoEXT *in, VkMicromapBuildSizesInfoEXT32 *out)
{
    if (!in) return;

    out->micromapSize = in->micromapSize;
    out->buildScratchSize = in->buildScratchSize;
    out->discardable = in->discardable;
}

static inline void convert_VkPerformanceValueDataINTEL_win32_to_host(const VkPerformanceValueDataINTEL32 *in, VkPerformanceValueDataINTEL *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL)
        out->value32 = in->value32;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL)
        out->value64 = in->value64;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL)
        out->valueFloat = in->valueFloat;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL)
        out->valueBool = in->valueBool;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL)
        out->valueString = (const char *)UlongToPtr(in->valueString);
}

static inline void convert_VkPerformanceValueDataINTEL_host_to_win32(const VkPerformanceValueDataINTEL *in, VkPerformanceValueDataINTEL32 *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL)
        out->value32 = in->value32;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL)
        out->value64 = in->value64;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL)
        out->valueFloat = in->valueFloat;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL)
        out->valueBool = in->valueBool;
}

static inline void convert_VkPerformanceValueINTEL_host_to_win32(const VkPerformanceValueINTEL *in, VkPerformanceValueINTEL32 *out)
{
    if (!in) return;

    out->type = in->type;
    convert_VkPerformanceValueDataINTEL_host_to_win32(&in->data, &out->data, in->type);
}

static inline void convert_VkCooperativeMatrixPropertiesKHR_win32_to_host(const VkCooperativeMatrixPropertiesKHR32 *in, VkCooperativeMatrixPropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->MSize = in->MSize;
    out->NSize = in->NSize;
    out->KSize = in->KSize;
    out->AType = in->AType;
    out->BType = in->BType;
    out->CType = in->CType;
    out->ResultType = in->ResultType;
    out->saturatingAccumulation = in->saturatingAccumulation;
    out->scope = in->scope;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCooperativeMatrixPropertiesKHR_host_to_win32(const VkCooperativeMatrixPropertiesKHR *in, VkCooperativeMatrixPropertiesKHR32 *out)
{
    if (!in) return;

    out->MSize = in->MSize;
    out->NSize = in->NSize;
    out->KSize = in->KSize;
    out->AType = in->AType;
    out->BType = in->BType;
    out->CType = in->CType;
    out->ResultType = in->ResultType;
    out->saturatingAccumulation = in->saturatingAccumulation;
    out->scope = in->scope;
}

static inline VkCooperativeMatrixPropertiesKHR *convert_VkCooperativeMatrixPropertiesKHR_array_win32_to_host(struct conversion_context *ctx, const VkCooperativeMatrixPropertiesKHR32 *in, uint32_t count)
{
    VkCooperativeMatrixPropertiesKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCooperativeMatrixPropertiesKHR_array_host_to_win32(const VkCooperativeMatrixPropertiesKHR *in, VkCooperativeMatrixPropertiesKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkCooperativeMatrixPropertiesNV_win32_to_host(const VkCooperativeMatrixPropertiesNV32 *in, VkCooperativeMatrixPropertiesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCooperativeMatrixPropertiesNV_host_to_win32(const VkCooperativeMatrixPropertiesNV *in, VkCooperativeMatrixPropertiesNV32 *out)
{
    if (!in) return;

    out->MSize = in->MSize;
    out->NSize = in->NSize;
    out->KSize = in->KSize;
    out->AType = in->AType;
    out->BType = in->BType;
    out->CType = in->CType;
    out->DType = in->DType;
    out->scope = in->scope;
}

static inline VkCooperativeMatrixPropertiesNV *convert_VkCooperativeMatrixPropertiesNV_array_win32_to_host(struct conversion_context *ctx, const VkCooperativeMatrixPropertiesNV32 *in, uint32_t count)
{
    VkCooperativeMatrixPropertiesNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCooperativeMatrixPropertiesNV_array_host_to_win32(const VkCooperativeMatrixPropertiesNV *in, VkCooperativeMatrixPropertiesNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesNV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo32 *in, VkPhysicalDeviceExternalBufferInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->usage = in->usage;
    out->handleType = in->handleType;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
            VkBufferUsageFlags2CreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfoKHR32 *in_ext = (const VkBufferUsageFlags2CreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkExternalBufferProperties_win32_to_host(const VkExternalBufferProperties32 *in, VkExternalBufferProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkExternalBufferProperties_host_to_win32(const VkExternalBufferProperties *in, VkExternalBufferProperties32 *out)
{
    if (!in) return;

    out->externalMemoryProperties = in->externalMemoryProperties;
}

static inline void convert_VkPhysicalDeviceExternalFenceInfo_win32_to_host(const VkPhysicalDeviceExternalFenceInfo32 *in, VkPhysicalDeviceExternalFenceInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkExternalFenceProperties_win32_to_host(const VkExternalFenceProperties32 *in, VkExternalFenceProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkExternalFenceProperties_host_to_win32(const VkExternalFenceProperties *in, VkExternalFenceProperties32 *out)
{
    if (!in) return;

    out->exportFromImportedHandleTypes = in->exportFromImportedHandleTypes;
    out->compatibleHandleTypes = in->compatibleHandleTypes;
    out->externalFenceFeatures = in->externalFenceFeatures;
}

#ifdef _WIN64
static inline void convert_VkPhysicalDeviceExternalSemaphoreInfo_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalSemaphoreInfo *in, VkPhysicalDeviceExternalSemaphoreInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->handleType = in->handleType;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo *in_ext = (const VkSemaphoreTypeCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalSemaphoreInfo32 *in, VkPhysicalDeviceExternalSemaphoreInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->handleType = in->handleType;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo32 *in_ext = (const VkSemaphoreTypeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkExternalSemaphoreProperties_win32_to_host(const VkExternalSemaphoreProperties32 *in, VkExternalSemaphoreProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkExternalSemaphoreProperties_host_to_win32(const VkExternalSemaphoreProperties *in, VkExternalSemaphoreProperties32 *out)
{
    if (!in) return;

    out->exportFromImportedHandleTypes = in->exportFromImportedHandleTypes;
    out->compatibleHandleTypes = in->compatibleHandleTypes;
    out->externalSemaphoreFeatures = in->externalSemaphoreFeatures;
}

static inline void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceFeatures232 *in, VkPhysicalDeviceFeatures2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->features = in->features;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrivateDataFeatures32 *in_ext = (const VkPhysicalDevicePrivateDataFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->pNext = NULL;
            out_ext->privateData = in_ext->privateData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVariablePointersFeatures32 *in_ext = (const VkPhysicalDeviceVariablePointersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewFeatures32 *in_ext = (const VkPhysicalDeviceMultiviewFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->pNext = NULL;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentIdFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId = in_ext->presentId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWaitFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait = in_ext->presentWait;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice16BitStorageFeatures32 *in_ext = (const VkPhysicalDevice16BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProtectedMemoryFeatures32 *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiDrawFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInlineUniformBlockFeatures32 *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->pNext = NULL;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance4Features32 *in_ext = (const VkPhysicalDeviceMaintenance4Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance5FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance5FeaturesKHR32 *in_ext = (const VkPhysicalDeviceMaintenance5FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDrawParametersFeatures32 *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat16Int8Features32 *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostQueryResetFeatures32 *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32 *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorIndexingFeatures32 *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTimelineSemaphoreFeatures32 *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice8BitStorageFeatures32 *in_ext = (const VkPhysicalDevice8BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkanMemoryModelFeatures32 *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicInt64Features32 *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32 *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShadingRateImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesNV32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayQueryFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceScalarBlockLayoutFeatures32 *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeatures32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImagelessFramebufferFeatures32 *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->pNext = NULL;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentBarrierFeaturesNV32 *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderClockFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            VkPhysicalDeviceIndexTypeUint8FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceIndexTypeUint8FeaturesEXT32 *in_ext = (const VkPhysicalDeviceIndexTypeUint8FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubgroupSizeControlFeatures32 *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            VkPhysicalDeviceLineRasterizationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLineRasterizationFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLineRasterizationFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan11Features32 *in_ext = (const VkPhysicalDeviceVulkan11Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan12Features32 *in_ext = (const VkPhysicalDeviceVulkan12Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan13Features32 *in_ext = (const VkPhysicalDeviceVulkan13Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            VkPhysicalDeviceRobustness2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRobustness2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceRobustness2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageRobustnessFeatures32 *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice4444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSynchronization2Features32 *in_ext = (const VkPhysicalDeviceSynchronization2Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
            VkPhysicalDeviceHostImageCopyFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyFeaturesEXT32 *in_ext = (const VkPhysicalDeviceHostImageCopyFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingFeatures32 *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineRobustnessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineRobustnessFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineRobustnessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpticalFlowFeaturesNV32 *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFaultFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32 *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderObjectFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicClampFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysicalDeviceFeatures2 *in, VkPhysicalDeviceFeatures232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->features = in->features;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV);
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV);
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES);
            const VkPhysicalDevicePrivateDataFeatures *in_ext = (const VkPhysicalDevicePrivateDataFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->privateData = in_ext->privateData;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES);
            const VkPhysicalDeviceVariablePointersFeatures *in_ext = (const VkPhysicalDeviceVariablePointersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES);
            const VkPhysicalDeviceMultiviewFeatures *in_ext = (const VkPhysicalDeviceMultiviewFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR);
            const VkPhysicalDevicePresentIdFeaturesKHR *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->presentId = in_ext->presentId;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR);
            const VkPhysicalDevicePresentWaitFeaturesKHR *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->presentWait = in_ext->presentWait;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES);
            const VkPhysicalDevice16BitStorageFeatures *in_ext = (const VkPhysicalDevice16BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES);
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES);
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES);
            const VkPhysicalDeviceProtectedMemoryFeatures *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT);
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT);
            const VkPhysicalDeviceMultiDrawFeaturesEXT *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES);
            const VkPhysicalDeviceInlineUniformBlockFeatures *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES);
            const VkPhysicalDeviceMaintenance4Features *in_ext = (const VkPhysicalDeviceMaintenance4Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance5FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR);
            const VkPhysicalDeviceMaintenance5FeaturesKHR *in_ext = (const VkPhysicalDeviceMaintenance5FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES);
            const VkPhysicalDeviceShaderDrawParametersFeatures *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES);
            const VkPhysicalDeviceShaderFloat16Int8Features *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES);
            const VkPhysicalDeviceHostQueryResetFeatures *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR);
            const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES);
            const VkPhysicalDeviceDescriptorIndexingFeatures *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES);
            const VkPhysicalDeviceTimelineSemaphoreFeatures *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES);
            const VkPhysicalDevice8BitStorageFeatures *in_ext = (const VkPhysicalDevice8BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT);
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES);
            const VkPhysicalDeviceVulkanMemoryModelFeatures *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES);
            const VkPhysicalDeviceShaderAtomicInt64Features *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT);
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT);
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT);
            const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT);
            const VkPhysicalDeviceASTCDecodeFeaturesEXT *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT);
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV);
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV);
            const VkPhysicalDeviceExclusiveScissorFeaturesNV *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV);
            const VkPhysicalDeviceCornerSampledImageFeaturesNV *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV);
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV);
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV);
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV);
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV);
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV);
            const VkPhysicalDeviceShadingRateImageFeaturesNV *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI);
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV);
            const VkPhysicalDeviceMeshShaderFeaturesNV *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT);
            const VkPhysicalDeviceMeshShaderFeaturesEXT *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR);
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR);
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR);
            const VkPhysicalDeviceRayQueryFeaturesKHR *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR);
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT);
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT);
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM);
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES);
            const VkPhysicalDeviceScalarBlockLayoutFeatures *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES);
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT);
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT);
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT);
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES);
            const VkPhysicalDeviceBufferDeviceAddressFeatures *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT);
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES);
            const VkPhysicalDeviceImagelessFramebufferFeatures *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES);
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV);
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT);
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV);
            const VkPhysicalDevicePresentBarrierFeaturesNV *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR);
            const VkPhysicalDevicePerformanceQueryFeaturesKHR *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV);
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL);
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR);
            const VkPhysicalDeviceShaderClockFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            VkPhysicalDeviceIndexTypeUint8FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT);
            const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *in_ext = (const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV);
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT);
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES);
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT);
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR);
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES);
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT);
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES);
            const VkPhysicalDeviceSubgroupSizeControlFeatures *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            VkPhysicalDeviceLineRasterizationFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT);
            const VkPhysicalDeviceLineRasterizationFeaturesEXT *in_ext = (const VkPhysicalDeviceLineRasterizationFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES);
            const VkPhysicalDevicePipelineCreationCacheControlFeatures *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES);
            const VkPhysicalDeviceVulkan11Features *in_ext = (const VkPhysicalDeviceVulkan11Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES);
            const VkPhysicalDeviceVulkan12Features *in_ext = (const VkPhysicalDeviceVulkan12Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES);
            const VkPhysicalDeviceVulkan13Features *in_ext = (const VkPhysicalDeviceVulkan13Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD);
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT);
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT);
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT);
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT);
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT);
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV);
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES);
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR);
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            VkPhysicalDeviceRobustness2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT);
            const VkPhysicalDeviceRobustness2FeaturesEXT *in_ext = (const VkPhysicalDeviceRobustness2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES);
            const VkPhysicalDeviceImageRobustnessFeatures *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR);
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT);
            const VkPhysicalDevice4444FormatsFeaturesEXT *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI);
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI);
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT);
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR);
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES);
            const VkPhysicalDeviceShaderTerminateInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV);
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT);
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT);
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT);
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT);
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceDepthClipControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT);
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT);
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES);
            const VkPhysicalDeviceSynchronization2Features *in_ext = (const VkPhysicalDeviceSynchronization2Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
            VkPhysicalDeviceHostImageCopyFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT);
            const VkPhysicalDeviceHostImageCopyFeaturesEXT *in_ext = (const VkPhysicalDeviceHostImageCopyFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT);
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT);
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT);
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT);
            const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV);
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT);
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT);
            const VkPhysicalDeviceProvokingVertexFeaturesEXT *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT);
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES);
            const VkPhysicalDeviceShaderIntegerDotProductFeatures *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR);
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV);
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT);
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES);
            const VkPhysicalDeviceDynamicRenderingFeatures *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT);
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->minLod = in_ext->minLod;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT);
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV);
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT);
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE);
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT);
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT);
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT);
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT);
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT);
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT);
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD);
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT);
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineRobustnessFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT);
            const VkPhysicalDevicePipelineRobustnessFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineRobustnessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM);
            const VkPhysicalDeviceImageProcessingFeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM);
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT);
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT);
            const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT);
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV);
            const VkPhysicalDeviceOpticalFlowFeaturesNV *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT);
            const VkPhysicalDeviceFaultFeaturesEXT *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT);
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM);
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT);
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT);
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT);
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV);
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV);
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM);
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR);
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM);
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT);
            const VkPhysicalDeviceShaderObjectFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT);
            const VkPhysicalDeviceShaderTileImageFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR);
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM);
            const VkPhysicalDeviceCubicClampFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM);
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM);
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM);
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV);
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_context *ctx, const VkFormatProperties232 *in, VkFormatProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
            VkSubpassResolvePerformanceQueryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
            VkFormatProperties3 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkFormatProperties2_host_to_win32(const VkFormatProperties2 *in, VkFormatProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->formatProperties = in->formatProperties;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
            VkSubpassResolvePerformanceQueryEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT);
            const VkSubpassResolvePerformanceQueryEXT *in_ext = (const VkSubpassResolvePerformanceQueryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
            out_ext->optimal = in_ext->optimal;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
            VkFormatProperties332 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3);
            const VkFormatProperties3 *in_ext = (const VkFormatProperties3 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
            out_ext->linearTilingFeatures = in_ext->linearTilingFeatures;
            out_ext->optimalTilingFeatures = in_ext->optimalTilingFeatures;
            out_ext->bufferFeatures = in_ext->bufferFeatures;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkPhysicalDeviceFragmentShadingRateKHR_win32_to_host(const VkPhysicalDeviceFragmentShadingRateKHR32 *in, VkPhysicalDeviceFragmentShadingRateKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPhysicalDeviceFragmentShadingRateKHR_host_to_win32(const VkPhysicalDeviceFragmentShadingRateKHR *in, VkPhysicalDeviceFragmentShadingRateKHR32 *out)
{
    if (!in) return;

    out->sampleCounts = in->sampleCounts;
    out->fragmentSize = in->fragmentSize;
}

static inline VkPhysicalDeviceFragmentShadingRateKHR *convert_VkPhysicalDeviceFragmentShadingRateKHR_array_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceFragmentShadingRateKHR32 *in, uint32_t count)
{
    VkPhysicalDeviceFragmentShadingRateKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceFragmentShadingRateKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPhysicalDeviceFragmentShadingRateKHR_array_host_to_win32(const VkPhysicalDeviceFragmentShadingRateKHR *in, VkPhysicalDeviceFragmentShadingRateKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceFragmentShadingRateKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkImageFormatProperties_host_to_win32(const VkImageFormatProperties *in, VkImageFormatProperties32 *out)
{
    if (!in) return;

    out->maxExtent = in->maxExtent;
    out->maxMipLevels = in->maxMipLevels;
    out->maxArrayLayers = in->maxArrayLayers;
    out->sampleCounts = in->sampleCounts;
    out->maxResourceSize = in->maxResourceSize;
}

#ifdef _WIN64
static inline void convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceImageFormatInfo2 *in, VkPhysicalDeviceImageFormatInfo2 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->type = in->type;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->flags = in->flags;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            VkPhysicalDeviceExternalImageFormatInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExternalImageFormatInfo *in_ext = (const VkPhysicalDeviceExternalImageFormatInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo *in_ext = (const VkImageFormatListCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = in_ext->pViewFormats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo *in_ext = (const VkImageStencilUsageCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            VkPhysicalDeviceImageViewImageFormatInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewImageFormatInfoEXT *in_ext = (const VkPhysicalDeviceImageViewImageFormatInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->imageViewType = in_ext->imageViewType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT *in_ext = (const VkImageCompressionControlEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = in_ext->pFixedRateFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV *in_ext = (const VkOpticalFlowImageFormatInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceImageFormatInfo232 *in, VkPhysicalDeviceImageFormatInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->type = in->type;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            VkPhysicalDeviceExternalImageFormatInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExternalImageFormatInfo32 *in_ext = (const VkPhysicalDeviceExternalImageFormatInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo32 *in_ext = (const VkImageFormatListCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = (const VkFormat *)UlongToPtr(in_ext->pViewFormats);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo32 *in_ext = (const VkImageStencilUsageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            VkPhysicalDeviceImageViewImageFormatInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewImageFormatInfoEXT32 *in_ext = (const VkPhysicalDeviceImageViewImageFormatInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->imageViewType = in_ext->imageViewType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT32 *in_ext = (const VkImageCompressionControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = (VkImageCompressionFixedRateFlagsEXT *)UlongToPtr(in_ext->pFixedRateFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV32 *in_ext = (const VkOpticalFlowImageFormatInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkImageFormatProperties2_win32_to_host(struct conversion_context *ctx, const VkImageFormatProperties232 *in, VkImageFormatProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            VkExternalImageFormatProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            VkSamplerYcbcrConversionImageFormatProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            VkTextureLODGatherFormatPropertiesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            VkFilterCubicImageViewImageFormatPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
        {
            VkHostImageCopyDevicePerformanceQueryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkImageFormatProperties2_host_to_win32(const VkImageFormatProperties2 *in, VkImageFormatProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkImageFormatProperties_host_to_win32(&in->imageFormatProperties, &out->imageFormatProperties);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            VkExternalImageFormatProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES);
            const VkExternalImageFormatProperties *in_ext = (const VkExternalImageFormatProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
            out_ext->externalMemoryProperties = in_ext->externalMemoryProperties;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            VkSamplerYcbcrConversionImageFormatProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES);
            const VkSamplerYcbcrConversionImageFormatProperties *in_ext = (const VkSamplerYcbcrConversionImageFormatProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
            out_ext->combinedImageSamplerDescriptorCount = in_ext->combinedImageSamplerDescriptorCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            VkTextureLODGatherFormatPropertiesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD);
            const VkTextureLODGatherFormatPropertiesAMD *in_ext = (const VkTextureLODGatherFormatPropertiesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
            out_ext->supportsTextureGatherLODBiasAMD = in_ext->supportsTextureGatherLODBiasAMD;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            VkFilterCubicImageViewImageFormatPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT);
            const VkFilterCubicImageViewImageFormatPropertiesEXT *in_ext = (const VkFilterCubicImageViewImageFormatPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
            out_ext->filterCubic = in_ext->filterCubic;
            out_ext->filterCubicMinmax = in_ext->filterCubicMinmax;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
        {
            VkHostImageCopyDevicePerformanceQueryEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT);
            const VkHostImageCopyDevicePerformanceQueryEXT *in_ext = (const VkHostImageCopyDevicePerformanceQueryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT;
            out_ext->optimalDeviceAccess = in_ext->optimalDeviceAccess;
            out_ext->identicalMemoryLayout = in_ext->identicalMemoryLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT);
            const VkImageCompressionPropertiesEXT *in_ext = (const VkImageCompressionPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->imageCompressionFlags = in_ext->imageCompressionFlags;
            out_ext->imageCompressionFixedRateFlags = in_ext->imageCompressionFixedRateFlags;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkMemoryHeap_host_to_win32(const VkMemoryHeap *in, VkMemoryHeap32 *out)
{
    if (!in) return;

    out->size = in->size;
    out->flags = in->flags;
}

static inline void convert_VkMemoryHeap_array_host_to_win32(const VkMemoryHeap *in, VkMemoryHeap32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkMemoryHeap_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPhysicalDeviceMemoryProperties_host_to_win32(const VkPhysicalDeviceMemoryProperties *in, VkPhysicalDeviceMemoryProperties32 *out)
{
    if (!in) return;

    out->memoryTypeCount = in->memoryTypeCount;
    memcpy(out->memoryTypes, in->memoryTypes, VK_MAX_MEMORY_TYPES * sizeof(VkMemoryType));
    out->memoryHeapCount = in->memoryHeapCount;
    convert_VkMemoryHeap_array_host_to_win32(in->memoryHeaps, out->memoryHeaps, VK_MAX_MEMORY_HEAPS);
}

static inline void convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceMemoryProperties232 *in, VkPhysicalDeviceMemoryProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMemoryBudgetPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkPhysicalDeviceMemoryProperties2_host_to_win32(const VkPhysicalDeviceMemoryProperties2 *in, VkPhysicalDeviceMemoryProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkPhysicalDeviceMemoryProperties_host_to_win32(&in->memoryProperties, &out->memoryProperties);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMemoryBudgetPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT);
            const VkPhysicalDeviceMemoryBudgetPropertiesEXT *in_ext = (const VkPhysicalDeviceMemoryBudgetPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
            memcpy(out_ext->heapBudget, in_ext->heapBudget, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
            memcpy(out_ext->heapUsage, in_ext->heapUsage, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkMultisamplePropertiesEXT_win32_to_host(const VkMultisamplePropertiesEXT32 *in, VkMultisamplePropertiesEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMultisamplePropertiesEXT_host_to_win32(const VkMultisamplePropertiesEXT *in, VkMultisamplePropertiesEXT32 *out)
{
    if (!in) return;

    out->maxSampleLocationGridSize = in->maxSampleLocationGridSize;
}

static inline void convert_VkOpticalFlowImageFormatInfoNV_win32_to_host(const VkOpticalFlowImageFormatInfoNV32 *in, VkOpticalFlowImageFormatInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->usage = in->usage;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkOpticalFlowImageFormatPropertiesNV_win32_to_host(const VkOpticalFlowImageFormatPropertiesNV32 *in, VkOpticalFlowImageFormatPropertiesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkOpticalFlowImageFormatPropertiesNV_host_to_win32(const VkOpticalFlowImageFormatPropertiesNV *in, VkOpticalFlowImageFormatPropertiesNV32 *out)
{
    if (!in) return;

    out->format = in->format;
}

static inline VkOpticalFlowImageFormatPropertiesNV *convert_VkOpticalFlowImageFormatPropertiesNV_array_win32_to_host(struct conversion_context *ctx, const VkOpticalFlowImageFormatPropertiesNV32 *in, uint32_t count)
{
    VkOpticalFlowImageFormatPropertiesNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkOpticalFlowImageFormatPropertiesNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkOpticalFlowImageFormatPropertiesNV_array_host_to_win32(const VkOpticalFlowImageFormatPropertiesNV *in, VkOpticalFlowImageFormatPropertiesNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkOpticalFlowImageFormatPropertiesNV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPhysicalDeviceLimits_host_to_win32(const VkPhysicalDeviceLimits *in, VkPhysicalDeviceLimits32 *out)
{
    if (!in) return;

    out->maxImageDimension1D = in->maxImageDimension1D;
    out->maxImageDimension2D = in->maxImageDimension2D;
    out->maxImageDimension3D = in->maxImageDimension3D;
    out->maxImageDimensionCube = in->maxImageDimensionCube;
    out->maxImageArrayLayers = in->maxImageArrayLayers;
    out->maxTexelBufferElements = in->maxTexelBufferElements;
    out->maxUniformBufferRange = in->maxUniformBufferRange;
    out->maxStorageBufferRange = in->maxStorageBufferRange;
    out->maxPushConstantsSize = in->maxPushConstantsSize;
    out->maxMemoryAllocationCount = in->maxMemoryAllocationCount;
    out->maxSamplerAllocationCount = in->maxSamplerAllocationCount;
    out->bufferImageGranularity = in->bufferImageGranularity;
    out->sparseAddressSpaceSize = in->sparseAddressSpaceSize;
    out->maxBoundDescriptorSets = in->maxBoundDescriptorSets;
    out->maxPerStageDescriptorSamplers = in->maxPerStageDescriptorSamplers;
    out->maxPerStageDescriptorUniformBuffers = in->maxPerStageDescriptorUniformBuffers;
    out->maxPerStageDescriptorStorageBuffers = in->maxPerStageDescriptorStorageBuffers;
    out->maxPerStageDescriptorSampledImages = in->maxPerStageDescriptorSampledImages;
    out->maxPerStageDescriptorStorageImages = in->maxPerStageDescriptorStorageImages;
    out->maxPerStageDescriptorInputAttachments = in->maxPerStageDescriptorInputAttachments;
    out->maxPerStageResources = in->maxPerStageResources;
    out->maxDescriptorSetSamplers = in->maxDescriptorSetSamplers;
    out->maxDescriptorSetUniformBuffers = in->maxDescriptorSetUniformBuffers;
    out->maxDescriptorSetUniformBuffersDynamic = in->maxDescriptorSetUniformBuffersDynamic;
    out->maxDescriptorSetStorageBuffers = in->maxDescriptorSetStorageBuffers;
    out->maxDescriptorSetStorageBuffersDynamic = in->maxDescriptorSetStorageBuffersDynamic;
    out->maxDescriptorSetSampledImages = in->maxDescriptorSetSampledImages;
    out->maxDescriptorSetStorageImages = in->maxDescriptorSetStorageImages;
    out->maxDescriptorSetInputAttachments = in->maxDescriptorSetInputAttachments;
    out->maxVertexInputAttributes = in->maxVertexInputAttributes;
    out->maxVertexInputBindings = in->maxVertexInputBindings;
    out->maxVertexInputAttributeOffset = in->maxVertexInputAttributeOffset;
    out->maxVertexInputBindingStride = in->maxVertexInputBindingStride;
    out->maxVertexOutputComponents = in->maxVertexOutputComponents;
    out->maxTessellationGenerationLevel = in->maxTessellationGenerationLevel;
    out->maxTessellationPatchSize = in->maxTessellationPatchSize;
    out->maxTessellationControlPerVertexInputComponents = in->maxTessellationControlPerVertexInputComponents;
    out->maxTessellationControlPerVertexOutputComponents = in->maxTessellationControlPerVertexOutputComponents;
    out->maxTessellationControlPerPatchOutputComponents = in->maxTessellationControlPerPatchOutputComponents;
    out->maxTessellationControlTotalOutputComponents = in->maxTessellationControlTotalOutputComponents;
    out->maxTessellationEvaluationInputComponents = in->maxTessellationEvaluationInputComponents;
    out->maxTessellationEvaluationOutputComponents = in->maxTessellationEvaluationOutputComponents;
    out->maxGeometryShaderInvocations = in->maxGeometryShaderInvocations;
    out->maxGeometryInputComponents = in->maxGeometryInputComponents;
    out->maxGeometryOutputComponents = in->maxGeometryOutputComponents;
    out->maxGeometryOutputVertices = in->maxGeometryOutputVertices;
    out->maxGeometryTotalOutputComponents = in->maxGeometryTotalOutputComponents;
    out->maxFragmentInputComponents = in->maxFragmentInputComponents;
    out->maxFragmentOutputAttachments = in->maxFragmentOutputAttachments;
    out->maxFragmentDualSrcAttachments = in->maxFragmentDualSrcAttachments;
    out->maxFragmentCombinedOutputResources = in->maxFragmentCombinedOutputResources;
    out->maxComputeSharedMemorySize = in->maxComputeSharedMemorySize;
    memcpy(out->maxComputeWorkGroupCount, in->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    out->maxComputeWorkGroupInvocations = in->maxComputeWorkGroupInvocations;
    memcpy(out->maxComputeWorkGroupSize, in->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    out->subPixelPrecisionBits = in->subPixelPrecisionBits;
    out->subTexelPrecisionBits = in->subTexelPrecisionBits;
    out->mipmapPrecisionBits = in->mipmapPrecisionBits;
    out->maxDrawIndexedIndexValue = in->maxDrawIndexedIndexValue;
    out->maxDrawIndirectCount = in->maxDrawIndirectCount;
    out->maxSamplerLodBias = in->maxSamplerLodBias;
    out->maxSamplerAnisotropy = in->maxSamplerAnisotropy;
    out->maxViewports = in->maxViewports;
    memcpy(out->maxViewportDimensions, in->maxViewportDimensions, 2 * sizeof(uint32_t));
    memcpy(out->viewportBoundsRange, in->viewportBoundsRange, 2 * sizeof(float));
    out->viewportSubPixelBits = in->viewportSubPixelBits;
    out->minMemoryMapAlignment = in->minMemoryMapAlignment;
    out->minTexelBufferOffsetAlignment = in->minTexelBufferOffsetAlignment;
    out->minUniformBufferOffsetAlignment = in->minUniformBufferOffsetAlignment;
    out->minStorageBufferOffsetAlignment = in->minStorageBufferOffsetAlignment;
    out->minTexelOffset = in->minTexelOffset;
    out->maxTexelOffset = in->maxTexelOffset;
    out->minTexelGatherOffset = in->minTexelGatherOffset;
    out->maxTexelGatherOffset = in->maxTexelGatherOffset;
    out->minInterpolationOffset = in->minInterpolationOffset;
    out->maxInterpolationOffset = in->maxInterpolationOffset;
    out->subPixelInterpolationOffsetBits = in->subPixelInterpolationOffsetBits;
    out->maxFramebufferWidth = in->maxFramebufferWidth;
    out->maxFramebufferHeight = in->maxFramebufferHeight;
    out->maxFramebufferLayers = in->maxFramebufferLayers;
    out->framebufferColorSampleCounts = in->framebufferColorSampleCounts;
    out->framebufferDepthSampleCounts = in->framebufferDepthSampleCounts;
    out->framebufferStencilSampleCounts = in->framebufferStencilSampleCounts;
    out->framebufferNoAttachmentsSampleCounts = in->framebufferNoAttachmentsSampleCounts;
    out->maxColorAttachments = in->maxColorAttachments;
    out->sampledImageColorSampleCounts = in->sampledImageColorSampleCounts;
    out->sampledImageIntegerSampleCounts = in->sampledImageIntegerSampleCounts;
    out->sampledImageDepthSampleCounts = in->sampledImageDepthSampleCounts;
    out->sampledImageStencilSampleCounts = in->sampledImageStencilSampleCounts;
    out->storageImageSampleCounts = in->storageImageSampleCounts;
    out->maxSampleMaskWords = in->maxSampleMaskWords;
    out->timestampComputeAndGraphics = in->timestampComputeAndGraphics;
    out->timestampPeriod = in->timestampPeriod;
    out->maxClipDistances = in->maxClipDistances;
    out->maxCullDistances = in->maxCullDistances;
    out->maxCombinedClipAndCullDistances = in->maxCombinedClipAndCullDistances;
    out->discreteQueuePriorities = in->discreteQueuePriorities;
    memcpy(out->pointSizeRange, in->pointSizeRange, 2 * sizeof(float));
    memcpy(out->lineWidthRange, in->lineWidthRange, 2 * sizeof(float));
    out->pointSizeGranularity = in->pointSizeGranularity;
    out->lineWidthGranularity = in->lineWidthGranularity;
    out->strictLines = in->strictLines;
    out->standardSampleLocations = in->standardSampleLocations;
    out->optimalBufferCopyOffsetAlignment = in->optimalBufferCopyOffsetAlignment;
    out->optimalBufferCopyRowPitchAlignment = in->optimalBufferCopyRowPitchAlignment;
    out->nonCoherentAtomSize = in->nonCoherentAtomSize;
}

static inline void convert_VkPhysicalDeviceProperties_host_to_win32(const VkPhysicalDeviceProperties *in, VkPhysicalDeviceProperties32 *out)
{
    if (!in) return;

    out->apiVersion = in->apiVersion;
    out->driverVersion = in->driverVersion;
    out->vendorID = in->vendorID;
    out->deviceID = in->deviceID;
    out->deviceType = in->deviceType;
    memcpy(out->deviceName, in->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    memcpy(out->pipelineCacheUUID, in->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    convert_VkPhysicalDeviceLimits_host_to_win32(&in->limits, &out->limits);
    out->sparseProperties = in->sparseProperties;
}

static inline void convert_VkPhysicalDeviceProperties2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceProperties232 *in, VkPhysicalDeviceProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMultiDrawPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            VkPhysicalDevicePushDescriptorPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            VkPhysicalDeviceDriverProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            VkPhysicalDeviceIDProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            VkPhysicalDeviceMultiviewProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDiscardRectanglePropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            VkPhysicalDevicePointClippingProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            VkPhysicalDeviceProtectedMemoryProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            VkPhysicalDeviceSamplerFilterMinmaxProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            VkPhysicalDeviceSampleLocationsPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
            VkPhysicalDeviceInlineUniformBlockProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance3Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance4Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
        {
            VkPhysicalDeviceMaintenance5PropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            VkPhysicalDeviceFloatControlsProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            VkPhysicalDeviceShaderCorePropertiesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            VkPhysicalDeviceShaderCoreProperties2AMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            VkPhysicalDeviceDescriptorIndexingProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            VkPhysicalDeviceTimelineSemaphoreProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            VkPhysicalDevicePCIBusInfoPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            VkPhysicalDeviceDepthStencilResolveProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            VkPhysicalDeviceShadingRateImagePropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            VkPhysicalDeviceMeshShaderPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMeshShaderPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceAccelerationStructurePropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            VkPhysicalDevicePerformanceQueryPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
            VkPhysicalDeviceTexelBufferAlignmentProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupSizeControlProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            VkPhysicalDeviceLineRasterizationPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            VkPhysicalDeviceVulkan11Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            VkPhysicalDeviceVulkan12Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
            VkPhysicalDeviceVulkan13Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicPrimitiveTopologyUnrestricted = in_ext->dynamicPrimitiveTopologyUnrestricted;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            VkPhysicalDeviceRobustness2PropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_ext->maxFragmentShadingRateInvocationCount = in_ext->maxFragmentShadingRateInvocationCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
        {
            VkPhysicalDeviceHostImageCopyPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyPropertiesEXT32 *in_ext = (const VkPhysicalDeviceHostImageCopyPropertiesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_ext->copySrcLayoutCount = in_ext->copySrcLayoutCount;
            out_ext->pCopySrcLayouts = (VkImageLayout *)UlongToPtr(in_ext->pCopySrcLayouts);
            out_ext->copyDstLayoutCount = in_ext->copyDstLayoutCount;
            out_ext->pCopyDstLayouts = (VkImageLayout *)UlongToPtr(in_ext->pCopyDstLayouts);
            memcpy(out_ext->optimalTilingLayoutUUID, in_ext->optimalTilingLayoutUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->identicalMemoryTypeRequirements = in_ext->identicalMemoryTypeRequirements;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
            VkPhysicalDeviceProvokingVertexPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
            VkPhysicalDeviceShaderIntegerDotProductProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32 *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibraryFastLinking = in_ext->graphicsPipelineLibraryFastLinking;
            out_ext->graphicsPipelineLibraryIndependentInterpolationDecoration = in_ext->graphicsPipelineLibraryIndependentInterpolationDecoration;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferPropertiesEXT32 *in_ext = (const VkPhysicalDeviceNestedCommandBufferPropertiesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_ext->maxCommandBufferNestingLevel = in_ext->maxCommandBufferNestingLevel;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
        {
            VkPhysicalDevicePipelineRobustnessPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessingPropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
            VkPhysicalDeviceOpticalFlowPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCorePropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderObjectPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderTileImagePropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2PropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
            VkPhysicalDeviceLayeredDriverPropertiesMSFT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkPhysicalDeviceProperties2_host_to_win32(const VkPhysicalDeviceProperties2 *in, VkPhysicalDeviceProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkPhysicalDeviceProperties_host_to_win32(&in->properties, &out->properties);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV);
            const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
            out_ext->maxGraphicsShaderGroupCount = in_ext->maxGraphicsShaderGroupCount;
            out_ext->maxIndirectSequenceCount = in_ext->maxIndirectSequenceCount;
            out_ext->maxIndirectCommandsTokenCount = in_ext->maxIndirectCommandsTokenCount;
            out_ext->maxIndirectCommandsStreamCount = in_ext->maxIndirectCommandsStreamCount;
            out_ext->maxIndirectCommandsTokenOffset = in_ext->maxIndirectCommandsTokenOffset;
            out_ext->maxIndirectCommandsStreamStride = in_ext->maxIndirectCommandsStreamStride;
            out_ext->minSequencesCountBufferOffsetAlignment = in_ext->minSequencesCountBufferOffsetAlignment;
            out_ext->minSequencesIndexBufferOffsetAlignment = in_ext->minSequencesIndexBufferOffsetAlignment;
            out_ext->minIndirectCommandsBufferOffsetAlignment = in_ext->minIndirectCommandsBufferOffsetAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMultiDrawPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT);
            const VkPhysicalDeviceMultiDrawPropertiesEXT *in_ext = (const VkPhysicalDeviceMultiDrawPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
            out_ext->maxMultiDrawCount = in_ext->maxMultiDrawCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            VkPhysicalDevicePushDescriptorPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR);
            const VkPhysicalDevicePushDescriptorPropertiesKHR *in_ext = (const VkPhysicalDevicePushDescriptorPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
            out_ext->maxPushDescriptors = in_ext->maxPushDescriptors;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            VkPhysicalDeviceDriverProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES);
            const VkPhysicalDeviceDriverProperties *in_ext = (const VkPhysicalDeviceDriverProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
            out_ext->driverID = in_ext->driverID;
            memcpy(out_ext->driverName, in_ext->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
            memcpy(out_ext->driverInfo, in_ext->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
            out_ext->conformanceVersion = in_ext->conformanceVersion;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            VkPhysicalDeviceIDProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES);
            const VkPhysicalDeviceIDProperties *in_ext = (const VkPhysicalDeviceIDProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
            memcpy(out_ext->deviceUUID, in_ext->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->driverUUID, in_ext->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->deviceLUID, in_ext->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
            out_ext->deviceNodeMask = in_ext->deviceNodeMask;
            out_ext->deviceLUIDValid = in_ext->deviceLUIDValid;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            VkPhysicalDeviceMultiviewProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES);
            const VkPhysicalDeviceMultiviewProperties *in_ext = (const VkPhysicalDeviceMultiviewProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
            out_ext->maxMultiviewViewCount = in_ext->maxMultiviewViewCount;
            out_ext->maxMultiviewInstanceIndex = in_ext->maxMultiviewInstanceIndex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDiscardRectanglePropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT);
            const VkPhysicalDeviceDiscardRectanglePropertiesEXT *in_ext = (const VkPhysicalDeviceDiscardRectanglePropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
            out_ext->maxDiscardRectangles = in_ext->maxDiscardRectangles;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES);
            const VkPhysicalDeviceSubgroupProperties *in_ext = (const VkPhysicalDeviceSubgroupProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
            out_ext->subgroupSize = in_ext->subgroupSize;
            out_ext->supportedStages = in_ext->supportedStages;
            out_ext->supportedOperations = in_ext->supportedOperations;
            out_ext->quadOperationsInAllStages = in_ext->quadOperationsInAllStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            VkPhysicalDevicePointClippingProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES);
            const VkPhysicalDevicePointClippingProperties *in_ext = (const VkPhysicalDevicePointClippingProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
            out_ext->pointClippingBehavior = in_ext->pointClippingBehavior;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            VkPhysicalDeviceProtectedMemoryProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES);
            const VkPhysicalDeviceProtectedMemoryProperties *in_ext = (const VkPhysicalDeviceProtectedMemoryProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
            out_ext->protectedNoFault = in_ext->protectedNoFault;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            VkPhysicalDeviceSamplerFilterMinmaxProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES);
            const VkPhysicalDeviceSamplerFilterMinmaxProperties *in_ext = (const VkPhysicalDeviceSamplerFilterMinmaxProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
            out_ext->filterMinmaxSingleComponentFormats = in_ext->filterMinmaxSingleComponentFormats;
            out_ext->filterMinmaxImageComponentMapping = in_ext->filterMinmaxImageComponentMapping;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            VkPhysicalDeviceSampleLocationsPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT);
            const VkPhysicalDeviceSampleLocationsPropertiesEXT *in_ext = (const VkPhysicalDeviceSampleLocationsPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
            out_ext->sampleLocationSampleCounts = in_ext->sampleLocationSampleCounts;
            out_ext->maxSampleLocationGridSize = in_ext->maxSampleLocationGridSize;
            memcpy(out_ext->sampleLocationCoordinateRange, in_ext->sampleLocationCoordinateRange, 2 * sizeof(float));
            out_ext->sampleLocationSubPixelBits = in_ext->sampleLocationSubPixelBits;
            out_ext->variableSampleLocations = in_ext->variableSampleLocations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT);
            const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
            out_ext->advancedBlendMaxColorAttachments = in_ext->advancedBlendMaxColorAttachments;
            out_ext->advancedBlendIndependentBlend = in_ext->advancedBlendIndependentBlend;
            out_ext->advancedBlendNonPremultipliedSrcColor = in_ext->advancedBlendNonPremultipliedSrcColor;
            out_ext->advancedBlendNonPremultipliedDstColor = in_ext->advancedBlendNonPremultipliedDstColor;
            out_ext->advancedBlendCorrelatedOverlap = in_ext->advancedBlendCorrelatedOverlap;
            out_ext->advancedBlendAllOperations = in_ext->advancedBlendAllOperations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
            VkPhysicalDeviceInlineUniformBlockProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES);
            const VkPhysicalDeviceInlineUniformBlockProperties *in_ext = (const VkPhysicalDeviceInlineUniformBlockProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
            out_ext->maxInlineUniformBlockSize = in_ext->maxInlineUniformBlockSize;
            out_ext->maxPerStageDescriptorInlineUniformBlocks = in_ext->maxPerStageDescriptorInlineUniformBlocks;
            out_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = in_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
            out_ext->maxDescriptorSetInlineUniformBlocks = in_ext->maxDescriptorSetInlineUniformBlocks;
            out_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = in_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance3Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES);
            const VkPhysicalDeviceMaintenance3Properties *in_ext = (const VkPhysicalDeviceMaintenance3Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
            out_ext->maxPerSetDescriptors = in_ext->maxPerSetDescriptors;
            out_ext->maxMemoryAllocationSize = in_ext->maxMemoryAllocationSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance4Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES);
            const VkPhysicalDeviceMaintenance4Properties *in_ext = (const VkPhysicalDeviceMaintenance4Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
            out_ext->maxBufferSize = in_ext->maxBufferSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
        {
            VkPhysicalDeviceMaintenance5PropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR);
            const VkPhysicalDeviceMaintenance5PropertiesKHR *in_ext = (const VkPhysicalDeviceMaintenance5PropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR;
            out_ext->earlyFragmentMultisampleCoverageAfterSampleCounting = in_ext->earlyFragmentMultisampleCoverageAfterSampleCounting;
            out_ext->earlyFragmentSampleMaskTestBeforeSampleCounting = in_ext->earlyFragmentSampleMaskTestBeforeSampleCounting;
            out_ext->depthStencilSwizzleOneSupport = in_ext->depthStencilSwizzleOneSupport;
            out_ext->polygonModePointSize = in_ext->polygonModePointSize;
            out_ext->nonStrictSinglePixelWideLinesUseParallelogram = in_ext->nonStrictSinglePixelWideLinesUseParallelogram;
            out_ext->nonStrictWideLinesUseParallelogram = in_ext->nonStrictWideLinesUseParallelogram;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            VkPhysicalDeviceFloatControlsProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES);
            const VkPhysicalDeviceFloatControlsProperties *in_ext = (const VkPhysicalDeviceFloatControlsProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
            out_ext->denormBehaviorIndependence = in_ext->denormBehaviorIndependence;
            out_ext->roundingModeIndependence = in_ext->roundingModeIndependence;
            out_ext->shaderSignedZeroInfNanPreserveFloat16 = in_ext->shaderSignedZeroInfNanPreserveFloat16;
            out_ext->shaderSignedZeroInfNanPreserveFloat32 = in_ext->shaderSignedZeroInfNanPreserveFloat32;
            out_ext->shaderSignedZeroInfNanPreserveFloat64 = in_ext->shaderSignedZeroInfNanPreserveFloat64;
            out_ext->shaderDenormPreserveFloat16 = in_ext->shaderDenormPreserveFloat16;
            out_ext->shaderDenormPreserveFloat32 = in_ext->shaderDenormPreserveFloat32;
            out_ext->shaderDenormPreserveFloat64 = in_ext->shaderDenormPreserveFloat64;
            out_ext->shaderDenormFlushToZeroFloat16 = in_ext->shaderDenormFlushToZeroFloat16;
            out_ext->shaderDenormFlushToZeroFloat32 = in_ext->shaderDenormFlushToZeroFloat32;
            out_ext->shaderDenormFlushToZeroFloat64 = in_ext->shaderDenormFlushToZeroFloat64;
            out_ext->shaderRoundingModeRTEFloat16 = in_ext->shaderRoundingModeRTEFloat16;
            out_ext->shaderRoundingModeRTEFloat32 = in_ext->shaderRoundingModeRTEFloat32;
            out_ext->shaderRoundingModeRTEFloat64 = in_ext->shaderRoundingModeRTEFloat64;
            out_ext->shaderRoundingModeRTZFloat16 = in_ext->shaderRoundingModeRTZFloat16;
            out_ext->shaderRoundingModeRTZFloat32 = in_ext->shaderRoundingModeRTZFloat32;
            out_ext->shaderRoundingModeRTZFloat64 = in_ext->shaderRoundingModeRTZFloat64;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT);
            const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *in_ext = (const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
            out_ext->minImportedHostPointerAlignment = in_ext->minImportedHostPointerAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT);
            const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *in_ext = (const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
            out_ext->primitiveOverestimationSize = in_ext->primitiveOverestimationSize;
            out_ext->maxExtraPrimitiveOverestimationSize = in_ext->maxExtraPrimitiveOverestimationSize;
            out_ext->extraPrimitiveOverestimationSizeGranularity = in_ext->extraPrimitiveOverestimationSizeGranularity;
            out_ext->primitiveUnderestimation = in_ext->primitiveUnderestimation;
            out_ext->conservativePointAndLineRasterization = in_ext->conservativePointAndLineRasterization;
            out_ext->degenerateTrianglesRasterized = in_ext->degenerateTrianglesRasterized;
            out_ext->degenerateLinesRasterized = in_ext->degenerateLinesRasterized;
            out_ext->fullyCoveredFragmentShaderInputVariable = in_ext->fullyCoveredFragmentShaderInputVariable;
            out_ext->conservativeRasterizationPostDepthCoverage = in_ext->conservativeRasterizationPostDepthCoverage;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            VkPhysicalDeviceShaderCorePropertiesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD);
            const VkPhysicalDeviceShaderCorePropertiesAMD *in_ext = (const VkPhysicalDeviceShaderCorePropertiesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
            out_ext->shaderEngineCount = in_ext->shaderEngineCount;
            out_ext->shaderArraysPerEngineCount = in_ext->shaderArraysPerEngineCount;
            out_ext->computeUnitsPerShaderArray = in_ext->computeUnitsPerShaderArray;
            out_ext->simdPerComputeUnit = in_ext->simdPerComputeUnit;
            out_ext->wavefrontsPerSimd = in_ext->wavefrontsPerSimd;
            out_ext->wavefrontSize = in_ext->wavefrontSize;
            out_ext->sgprsPerSimd = in_ext->sgprsPerSimd;
            out_ext->minSgprAllocation = in_ext->minSgprAllocation;
            out_ext->maxSgprAllocation = in_ext->maxSgprAllocation;
            out_ext->sgprAllocationGranularity = in_ext->sgprAllocationGranularity;
            out_ext->vgprsPerSimd = in_ext->vgprsPerSimd;
            out_ext->minVgprAllocation = in_ext->minVgprAllocation;
            out_ext->maxVgprAllocation = in_ext->maxVgprAllocation;
            out_ext->vgprAllocationGranularity = in_ext->vgprAllocationGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            VkPhysicalDeviceShaderCoreProperties2AMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD);
            const VkPhysicalDeviceShaderCoreProperties2AMD *in_ext = (const VkPhysicalDeviceShaderCoreProperties2AMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
            out_ext->shaderCoreFeatures = in_ext->shaderCoreFeatures;
            out_ext->activeComputeUnitCount = in_ext->activeComputeUnitCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            VkPhysicalDeviceDescriptorIndexingProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES);
            const VkPhysicalDeviceDescriptorIndexingProperties *in_ext = (const VkPhysicalDeviceDescriptorIndexingProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
            out_ext->maxUpdateAfterBindDescriptorsInAllPools = in_ext->maxUpdateAfterBindDescriptorsInAllPools;
            out_ext->shaderUniformBufferArrayNonUniformIndexingNative = in_ext->shaderUniformBufferArrayNonUniformIndexingNative;
            out_ext->shaderSampledImageArrayNonUniformIndexingNative = in_ext->shaderSampledImageArrayNonUniformIndexingNative;
            out_ext->shaderStorageBufferArrayNonUniformIndexingNative = in_ext->shaderStorageBufferArrayNonUniformIndexingNative;
            out_ext->shaderStorageImageArrayNonUniformIndexingNative = in_ext->shaderStorageImageArrayNonUniformIndexingNative;
            out_ext->shaderInputAttachmentArrayNonUniformIndexingNative = in_ext->shaderInputAttachmentArrayNonUniformIndexingNative;
            out_ext->robustBufferAccessUpdateAfterBind = in_ext->robustBufferAccessUpdateAfterBind;
            out_ext->quadDivergentImplicitLod = in_ext->quadDivergentImplicitLod;
            out_ext->maxPerStageDescriptorUpdateAfterBindSamplers = in_ext->maxPerStageDescriptorUpdateAfterBindSamplers;
            out_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindSampledImages = in_ext->maxPerStageDescriptorUpdateAfterBindSampledImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageImages = in_ext->maxPerStageDescriptorUpdateAfterBindStorageImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments = in_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments;
            out_ext->maxPerStageUpdateAfterBindResources = in_ext->maxPerStageUpdateAfterBindResources;
            out_ext->maxDescriptorSetUpdateAfterBindSamplers = in_ext->maxDescriptorSetUpdateAfterBindSamplers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffers = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffers = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindSampledImages = in_ext->maxDescriptorSetUpdateAfterBindSampledImages;
            out_ext->maxDescriptorSetUpdateAfterBindStorageImages = in_ext->maxDescriptorSetUpdateAfterBindStorageImages;
            out_ext->maxDescriptorSetUpdateAfterBindInputAttachments = in_ext->maxDescriptorSetUpdateAfterBindInputAttachments;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            VkPhysicalDeviceTimelineSemaphoreProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES);
            const VkPhysicalDeviceTimelineSemaphoreProperties *in_ext = (const VkPhysicalDeviceTimelineSemaphoreProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
            out_ext->maxTimelineSemaphoreValueDifference = in_ext->maxTimelineSemaphoreValueDifference;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT);
            const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
            out_ext->maxVertexAttribDivisor = in_ext->maxVertexAttribDivisor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            VkPhysicalDevicePCIBusInfoPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT);
            const VkPhysicalDevicePCIBusInfoPropertiesEXT *in_ext = (const VkPhysicalDevicePCIBusInfoPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
            out_ext->pciDomain = in_ext->pciDomain;
            out_ext->pciBus = in_ext->pciBus;
            out_ext->pciDevice = in_ext->pciDevice;
            out_ext->pciFunction = in_ext->pciFunction;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            VkPhysicalDeviceDepthStencilResolveProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES);
            const VkPhysicalDeviceDepthStencilResolveProperties *in_ext = (const VkPhysicalDeviceDepthStencilResolveProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
            out_ext->supportedDepthResolveModes = in_ext->supportedDepthResolveModes;
            out_ext->supportedStencilResolveModes = in_ext->supportedStencilResolveModes;
            out_ext->independentResolveNone = in_ext->independentResolveNone;
            out_ext->independentResolve = in_ext->independentResolve;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT);
            const VkPhysicalDeviceTransformFeedbackPropertiesEXT *in_ext = (const VkPhysicalDeviceTransformFeedbackPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
            out_ext->maxTransformFeedbackStreams = in_ext->maxTransformFeedbackStreams;
            out_ext->maxTransformFeedbackBuffers = in_ext->maxTransformFeedbackBuffers;
            out_ext->maxTransformFeedbackBufferSize = in_ext->maxTransformFeedbackBufferSize;
            out_ext->maxTransformFeedbackStreamDataSize = in_ext->maxTransformFeedbackStreamDataSize;
            out_ext->maxTransformFeedbackBufferDataSize = in_ext->maxTransformFeedbackBufferDataSize;
            out_ext->maxTransformFeedbackBufferDataStride = in_ext->maxTransformFeedbackBufferDataStride;
            out_ext->transformFeedbackQueries = in_ext->transformFeedbackQueries;
            out_ext->transformFeedbackStreamsLinesTriangles = in_ext->transformFeedbackStreamsLinesTriangles;
            out_ext->transformFeedbackRasterizationStreamSelect = in_ext->transformFeedbackRasterizationStreamSelect;
            out_ext->transformFeedbackDraw = in_ext->transformFeedbackDraw;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV);
            const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
            out_ext->supportedQueues = in_ext->supportedQueues;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV);
            const VkPhysicalDeviceMemoryDecompressionPropertiesNV *in_ext = (const VkPhysicalDeviceMemoryDecompressionPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
            out_ext->decompressionMethods = in_ext->decompressionMethods;
            out_ext->maxDecompressionIndirectCount = in_ext->maxDecompressionIndirectCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            VkPhysicalDeviceShadingRateImagePropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV);
            const VkPhysicalDeviceShadingRateImagePropertiesNV *in_ext = (const VkPhysicalDeviceShadingRateImagePropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
            out_ext->shadingRateTexelSize = in_ext->shadingRateTexelSize;
            out_ext->shadingRatePaletteSize = in_ext->shadingRatePaletteSize;
            out_ext->shadingRateMaxCoarseSamples = in_ext->shadingRateMaxCoarseSamples;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            VkPhysicalDeviceMeshShaderPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV);
            const VkPhysicalDeviceMeshShaderPropertiesNV *in_ext = (const VkPhysicalDeviceMeshShaderPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
            out_ext->maxDrawMeshTasksCount = in_ext->maxDrawMeshTasksCount;
            out_ext->maxTaskWorkGroupInvocations = in_ext->maxTaskWorkGroupInvocations;
            memcpy(out_ext->maxTaskWorkGroupSize, in_ext->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxTaskTotalMemorySize = in_ext->maxTaskTotalMemorySize;
            out_ext->maxTaskOutputCount = in_ext->maxTaskOutputCount;
            out_ext->maxMeshWorkGroupInvocations = in_ext->maxMeshWorkGroupInvocations;
            memcpy(out_ext->maxMeshWorkGroupSize, in_ext->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxMeshTotalMemorySize = in_ext->maxMeshTotalMemorySize;
            out_ext->maxMeshOutputVertices = in_ext->maxMeshOutputVertices;
            out_ext->maxMeshOutputPrimitives = in_ext->maxMeshOutputPrimitives;
            out_ext->maxMeshMultiviewViewCount = in_ext->maxMeshMultiviewViewCount;
            out_ext->meshOutputPerVertexGranularity = in_ext->meshOutputPerVertexGranularity;
            out_ext->meshOutputPerPrimitiveGranularity = in_ext->meshOutputPerPrimitiveGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMeshShaderPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT);
            const VkPhysicalDeviceMeshShaderPropertiesEXT *in_ext = (const VkPhysicalDeviceMeshShaderPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
            out_ext->maxTaskWorkGroupTotalCount = in_ext->maxTaskWorkGroupTotalCount;
            memcpy(out_ext->maxTaskWorkGroupCount, in_ext->maxTaskWorkGroupCount, 3 * sizeof(uint32_t));
            out_ext->maxTaskWorkGroupInvocations = in_ext->maxTaskWorkGroupInvocations;
            memcpy(out_ext->maxTaskWorkGroupSize, in_ext->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxTaskPayloadSize = in_ext->maxTaskPayloadSize;
            out_ext->maxTaskSharedMemorySize = in_ext->maxTaskSharedMemorySize;
            out_ext->maxTaskPayloadAndSharedMemorySize = in_ext->maxTaskPayloadAndSharedMemorySize;
            out_ext->maxMeshWorkGroupTotalCount = in_ext->maxMeshWorkGroupTotalCount;
            memcpy(out_ext->maxMeshWorkGroupCount, in_ext->maxMeshWorkGroupCount, 3 * sizeof(uint32_t));
            out_ext->maxMeshWorkGroupInvocations = in_ext->maxMeshWorkGroupInvocations;
            memcpy(out_ext->maxMeshWorkGroupSize, in_ext->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxMeshSharedMemorySize = in_ext->maxMeshSharedMemorySize;
            out_ext->maxMeshPayloadAndSharedMemorySize = in_ext->maxMeshPayloadAndSharedMemorySize;
            out_ext->maxMeshOutputMemorySize = in_ext->maxMeshOutputMemorySize;
            out_ext->maxMeshPayloadAndOutputMemorySize = in_ext->maxMeshPayloadAndOutputMemorySize;
            out_ext->maxMeshOutputComponents = in_ext->maxMeshOutputComponents;
            out_ext->maxMeshOutputVertices = in_ext->maxMeshOutputVertices;
            out_ext->maxMeshOutputPrimitives = in_ext->maxMeshOutputPrimitives;
            out_ext->maxMeshOutputLayers = in_ext->maxMeshOutputLayers;
            out_ext->maxMeshMultiviewViewCount = in_ext->maxMeshMultiviewViewCount;
            out_ext->meshOutputPerVertexGranularity = in_ext->meshOutputPerVertexGranularity;
            out_ext->meshOutputPerPrimitiveGranularity = in_ext->meshOutputPerPrimitiveGranularity;
            out_ext->maxPreferredTaskWorkGroupInvocations = in_ext->maxPreferredTaskWorkGroupInvocations;
            out_ext->maxPreferredMeshWorkGroupInvocations = in_ext->maxPreferredMeshWorkGroupInvocations;
            out_ext->prefersLocalInvocationVertexOutput = in_ext->prefersLocalInvocationVertexOutput;
            out_ext->prefersLocalInvocationPrimitiveOutput = in_ext->prefersLocalInvocationPrimitiveOutput;
            out_ext->prefersCompactVertexOutput = in_ext->prefersCompactVertexOutput;
            out_ext->prefersCompactPrimitiveOutput = in_ext->prefersCompactPrimitiveOutput;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceAccelerationStructurePropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR);
            const VkPhysicalDeviceAccelerationStructurePropertiesKHR *in_ext = (const VkPhysicalDeviceAccelerationStructurePropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
            out_ext->maxGeometryCount = in_ext->maxGeometryCount;
            out_ext->maxInstanceCount = in_ext->maxInstanceCount;
            out_ext->maxPrimitiveCount = in_ext->maxPrimitiveCount;
            out_ext->maxPerStageDescriptorAccelerationStructures = in_ext->maxPerStageDescriptorAccelerationStructures;
            out_ext->maxPerStageDescriptorUpdateAfterBindAccelerationStructures = in_ext->maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
            out_ext->maxDescriptorSetAccelerationStructures = in_ext->maxDescriptorSetAccelerationStructures;
            out_ext->maxDescriptorSetUpdateAfterBindAccelerationStructures = in_ext->maxDescriptorSetUpdateAfterBindAccelerationStructures;
            out_ext->minAccelerationStructureScratchOffsetAlignment = in_ext->minAccelerationStructureScratchOffsetAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR);
            const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *in_ext = (const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
            out_ext->shaderGroupHandleSize = in_ext->shaderGroupHandleSize;
            out_ext->maxRayRecursionDepth = in_ext->maxRayRecursionDepth;
            out_ext->maxShaderGroupStride = in_ext->maxShaderGroupStride;
            out_ext->shaderGroupBaseAlignment = in_ext->shaderGroupBaseAlignment;
            out_ext->shaderGroupHandleCaptureReplaySize = in_ext->shaderGroupHandleCaptureReplaySize;
            out_ext->maxRayDispatchInvocationCount = in_ext->maxRayDispatchInvocationCount;
            out_ext->shaderGroupHandleAlignment = in_ext->shaderGroupHandleAlignment;
            out_ext->maxRayHitAttributeSize = in_ext->maxRayHitAttributeSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV);
            const VkPhysicalDeviceRayTracingPropertiesNV *in_ext = (const VkPhysicalDeviceRayTracingPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
            out_ext->shaderGroupHandleSize = in_ext->shaderGroupHandleSize;
            out_ext->maxRecursionDepth = in_ext->maxRecursionDepth;
            out_ext->maxShaderGroupStride = in_ext->maxShaderGroupStride;
            out_ext->shaderGroupBaseAlignment = in_ext->shaderGroupBaseAlignment;
            out_ext->maxGeometryCount = in_ext->maxGeometryCount;
            out_ext->maxInstanceCount = in_ext->maxInstanceCount;
            out_ext->maxTriangleCount = in_ext->maxTriangleCount;
            out_ext->maxDescriptorSetAccelerationStructures = in_ext->maxDescriptorSetAccelerationStructures;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT);
            const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->minFragmentDensityTexelSize = in_ext->minFragmentDensityTexelSize;
            out_ext->maxFragmentDensityTexelSize = in_ext->maxFragmentDensityTexelSize;
            out_ext->fragmentDensityInvocations = in_ext->fragmentDensityInvocations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT);
            const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
            out_ext->subsampledLoads = in_ext->subsampledLoads;
            out_ext->subsampledCoarseReconstructionEarlyAccess = in_ext->subsampledCoarseReconstructionEarlyAccess;
            out_ext->maxSubsampledArrayLayers = in_ext->maxSubsampledArrayLayers;
            out_ext->maxDescriptorSetSubsampledSamplers = in_ext->maxDescriptorSetSubsampledSamplers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM);
            const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
            out_ext->fragmentDensityOffsetGranularity = in_ext->fragmentDensityOffsetGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV);
            const VkPhysicalDeviceCooperativeMatrixPropertiesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrixPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
            out_ext->cooperativeMatrixSupportedStages = in_ext->cooperativeMatrixSupportedStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            VkPhysicalDevicePerformanceQueryPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR);
            const VkPhysicalDevicePerformanceQueryPropertiesKHR *in_ext = (const VkPhysicalDevicePerformanceQueryPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
            out_ext->allowCommandBufferQueryCopies = in_ext->allowCommandBufferQueryCopies;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV);
            const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
            out_ext->shaderSMCount = in_ext->shaderSMCount;
            out_ext->shaderWarpsPerSM = in_ext->shaderWarpsPerSM;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
            VkPhysicalDeviceTexelBufferAlignmentProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES);
            const VkPhysicalDeviceTexelBufferAlignmentProperties *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
            out_ext->storageTexelBufferOffsetAlignmentBytes = in_ext->storageTexelBufferOffsetAlignmentBytes;
            out_ext->storageTexelBufferOffsetSingleTexelAlignment = in_ext->storageTexelBufferOffsetSingleTexelAlignment;
            out_ext->uniformTexelBufferOffsetAlignmentBytes = in_ext->uniformTexelBufferOffsetAlignmentBytes;
            out_ext->uniformTexelBufferOffsetSingleTexelAlignment = in_ext->uniformTexelBufferOffsetSingleTexelAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupSizeControlProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES);
            const VkPhysicalDeviceSubgroupSizeControlProperties *in_ext = (const VkPhysicalDeviceSubgroupSizeControlProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
            out_ext->minSubgroupSize = in_ext->minSubgroupSize;
            out_ext->maxSubgroupSize = in_ext->maxSubgroupSize;
            out_ext->maxComputeWorkgroupSubgroups = in_ext->maxComputeWorkgroupSubgroups;
            out_ext->requiredSubgroupSizeStages = in_ext->requiredSubgroupSizeStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI);
            const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *in_ext = (const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
            out_ext->maxSubpassShadingWorkgroupSizeAspectRatio = in_ext->maxSubpassShadingWorkgroupSizeAspectRatio;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI);
            const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
            memcpy(out_ext->maxWorkGroupCount, in_ext->maxWorkGroupCount, 3 * sizeof(uint32_t));
            memcpy(out_ext->maxWorkGroupSize, in_ext->maxWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxOutputClusterCount = in_ext->maxOutputClusterCount;
            out_ext->indirectBufferOffsetAlignment = in_ext->indirectBufferOffsetAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            VkPhysicalDeviceLineRasterizationPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT);
            const VkPhysicalDeviceLineRasterizationPropertiesEXT *in_ext = (const VkPhysicalDeviceLineRasterizationPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
            out_ext->lineSubPixelPrecisionBits = in_ext->lineSubPixelPrecisionBits;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            VkPhysicalDeviceVulkan11Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES);
            const VkPhysicalDeviceVulkan11Properties *in_ext = (const VkPhysicalDeviceVulkan11Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
            memcpy(out_ext->deviceUUID, in_ext->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->driverUUID, in_ext->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->deviceLUID, in_ext->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
            out_ext->deviceNodeMask = in_ext->deviceNodeMask;
            out_ext->deviceLUIDValid = in_ext->deviceLUIDValid;
            out_ext->subgroupSize = in_ext->subgroupSize;
            out_ext->subgroupSupportedStages = in_ext->subgroupSupportedStages;
            out_ext->subgroupSupportedOperations = in_ext->subgroupSupportedOperations;
            out_ext->subgroupQuadOperationsInAllStages = in_ext->subgroupQuadOperationsInAllStages;
            out_ext->pointClippingBehavior = in_ext->pointClippingBehavior;
            out_ext->maxMultiviewViewCount = in_ext->maxMultiviewViewCount;
            out_ext->maxMultiviewInstanceIndex = in_ext->maxMultiviewInstanceIndex;
            out_ext->protectedNoFault = in_ext->protectedNoFault;
            out_ext->maxPerSetDescriptors = in_ext->maxPerSetDescriptors;
            out_ext->maxMemoryAllocationSize = in_ext->maxMemoryAllocationSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            VkPhysicalDeviceVulkan12Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES);
            const VkPhysicalDeviceVulkan12Properties *in_ext = (const VkPhysicalDeviceVulkan12Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
            out_ext->driverID = in_ext->driverID;
            memcpy(out_ext->driverName, in_ext->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
            memcpy(out_ext->driverInfo, in_ext->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
            out_ext->conformanceVersion = in_ext->conformanceVersion;
            out_ext->denormBehaviorIndependence = in_ext->denormBehaviorIndependence;
            out_ext->roundingModeIndependence = in_ext->roundingModeIndependence;
            out_ext->shaderSignedZeroInfNanPreserveFloat16 = in_ext->shaderSignedZeroInfNanPreserveFloat16;
            out_ext->shaderSignedZeroInfNanPreserveFloat32 = in_ext->shaderSignedZeroInfNanPreserveFloat32;
            out_ext->shaderSignedZeroInfNanPreserveFloat64 = in_ext->shaderSignedZeroInfNanPreserveFloat64;
            out_ext->shaderDenormPreserveFloat16 = in_ext->shaderDenormPreserveFloat16;
            out_ext->shaderDenormPreserveFloat32 = in_ext->shaderDenormPreserveFloat32;
            out_ext->shaderDenormPreserveFloat64 = in_ext->shaderDenormPreserveFloat64;
            out_ext->shaderDenormFlushToZeroFloat16 = in_ext->shaderDenormFlushToZeroFloat16;
            out_ext->shaderDenormFlushToZeroFloat32 = in_ext->shaderDenormFlushToZeroFloat32;
            out_ext->shaderDenormFlushToZeroFloat64 = in_ext->shaderDenormFlushToZeroFloat64;
            out_ext->shaderRoundingModeRTEFloat16 = in_ext->shaderRoundingModeRTEFloat16;
            out_ext->shaderRoundingModeRTEFloat32 = in_ext->shaderRoundingModeRTEFloat32;
            out_ext->shaderRoundingModeRTEFloat64 = in_ext->shaderRoundingModeRTEFloat64;
            out_ext->shaderRoundingModeRTZFloat16 = in_ext->shaderRoundingModeRTZFloat16;
            out_ext->shaderRoundingModeRTZFloat32 = in_ext->shaderRoundingModeRTZFloat32;
            out_ext->shaderRoundingModeRTZFloat64 = in_ext->shaderRoundingModeRTZFloat64;
            out_ext->maxUpdateAfterBindDescriptorsInAllPools = in_ext->maxUpdateAfterBindDescriptorsInAllPools;
            out_ext->shaderUniformBufferArrayNonUniformIndexingNative = in_ext->shaderUniformBufferArrayNonUniformIndexingNative;
            out_ext->shaderSampledImageArrayNonUniformIndexingNative = in_ext->shaderSampledImageArrayNonUniformIndexingNative;
            out_ext->shaderStorageBufferArrayNonUniformIndexingNative = in_ext->shaderStorageBufferArrayNonUniformIndexingNative;
            out_ext->shaderStorageImageArrayNonUniformIndexingNative = in_ext->shaderStorageImageArrayNonUniformIndexingNative;
            out_ext->shaderInputAttachmentArrayNonUniformIndexingNative = in_ext->shaderInputAttachmentArrayNonUniformIndexingNative;
            out_ext->robustBufferAccessUpdateAfterBind = in_ext->robustBufferAccessUpdateAfterBind;
            out_ext->quadDivergentImplicitLod = in_ext->quadDivergentImplicitLod;
            out_ext->maxPerStageDescriptorUpdateAfterBindSamplers = in_ext->maxPerStageDescriptorUpdateAfterBindSamplers;
            out_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindSampledImages = in_ext->maxPerStageDescriptorUpdateAfterBindSampledImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageImages = in_ext->maxPerStageDescriptorUpdateAfterBindStorageImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments = in_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments;
            out_ext->maxPerStageUpdateAfterBindResources = in_ext->maxPerStageUpdateAfterBindResources;
            out_ext->maxDescriptorSetUpdateAfterBindSamplers = in_ext->maxDescriptorSetUpdateAfterBindSamplers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffers = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffers = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindSampledImages = in_ext->maxDescriptorSetUpdateAfterBindSampledImages;
            out_ext->maxDescriptorSetUpdateAfterBindStorageImages = in_ext->maxDescriptorSetUpdateAfterBindStorageImages;
            out_ext->maxDescriptorSetUpdateAfterBindInputAttachments = in_ext->maxDescriptorSetUpdateAfterBindInputAttachments;
            out_ext->supportedDepthResolveModes = in_ext->supportedDepthResolveModes;
            out_ext->supportedStencilResolveModes = in_ext->supportedStencilResolveModes;
            out_ext->independentResolveNone = in_ext->independentResolveNone;
            out_ext->independentResolve = in_ext->independentResolve;
            out_ext->filterMinmaxSingleComponentFormats = in_ext->filterMinmaxSingleComponentFormats;
            out_ext->filterMinmaxImageComponentMapping = in_ext->filterMinmaxImageComponentMapping;
            out_ext->maxTimelineSemaphoreValueDifference = in_ext->maxTimelineSemaphoreValueDifference;
            out_ext->framebufferIntegerColorSampleCounts = in_ext->framebufferIntegerColorSampleCounts;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
            VkPhysicalDeviceVulkan13Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES);
            const VkPhysicalDeviceVulkan13Properties *in_ext = (const VkPhysicalDeviceVulkan13Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
            out_ext->minSubgroupSize = in_ext->minSubgroupSize;
            out_ext->maxSubgroupSize = in_ext->maxSubgroupSize;
            out_ext->maxComputeWorkgroupSubgroups = in_ext->maxComputeWorkgroupSubgroups;
            out_ext->requiredSubgroupSizeStages = in_ext->requiredSubgroupSizeStages;
            out_ext->maxInlineUniformBlockSize = in_ext->maxInlineUniformBlockSize;
            out_ext->maxPerStageDescriptorInlineUniformBlocks = in_ext->maxPerStageDescriptorInlineUniformBlocks;
            out_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = in_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
            out_ext->maxDescriptorSetInlineUniformBlocks = in_ext->maxDescriptorSetInlineUniformBlocks;
            out_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = in_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
            out_ext->maxInlineUniformTotalSize = in_ext->maxInlineUniformTotalSize;
            out_ext->integerDotProduct8BitUnsignedAccelerated = in_ext->integerDotProduct8BitUnsignedAccelerated;
            out_ext->integerDotProduct8BitSignedAccelerated = in_ext->integerDotProduct8BitSignedAccelerated;
            out_ext->integerDotProduct8BitMixedSignednessAccelerated = in_ext->integerDotProduct8BitMixedSignednessAccelerated;
            out_ext->integerDotProduct4x8BitPackedUnsignedAccelerated = in_ext->integerDotProduct4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedSignedAccelerated = in_ext->integerDotProduct4x8BitPackedSignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProduct16BitUnsignedAccelerated = in_ext->integerDotProduct16BitUnsignedAccelerated;
            out_ext->integerDotProduct16BitSignedAccelerated = in_ext->integerDotProduct16BitSignedAccelerated;
            out_ext->integerDotProduct16BitMixedSignednessAccelerated = in_ext->integerDotProduct16BitMixedSignednessAccelerated;
            out_ext->integerDotProduct32BitUnsignedAccelerated = in_ext->integerDotProduct32BitUnsignedAccelerated;
            out_ext->integerDotProduct32BitSignedAccelerated = in_ext->integerDotProduct32BitSignedAccelerated;
            out_ext->integerDotProduct32BitMixedSignednessAccelerated = in_ext->integerDotProduct32BitMixedSignednessAccelerated;
            out_ext->integerDotProduct64BitUnsignedAccelerated = in_ext->integerDotProduct64BitUnsignedAccelerated;
            out_ext->integerDotProduct64BitSignedAccelerated = in_ext->integerDotProduct64BitSignedAccelerated;
            out_ext->integerDotProduct64BitMixedSignednessAccelerated = in_ext->integerDotProduct64BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
            out_ext->storageTexelBufferOffsetAlignmentBytes = in_ext->storageTexelBufferOffsetAlignmentBytes;
            out_ext->storageTexelBufferOffsetSingleTexelAlignment = in_ext->storageTexelBufferOffsetSingleTexelAlignment;
            out_ext->uniformTexelBufferOffsetAlignmentBytes = in_ext->uniformTexelBufferOffsetAlignmentBytes;
            out_ext->uniformTexelBufferOffsetSingleTexelAlignment = in_ext->uniformTexelBufferOffsetSingleTexelAlignment;
            out_ext->maxBufferSize = in_ext->maxBufferSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT);
            const VkPhysicalDeviceCustomBorderColorPropertiesEXT *in_ext = (const VkPhysicalDeviceCustomBorderColorPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
            out_ext->maxCustomBorderColorSamplers = in_ext->maxCustomBorderColorSamplers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT);
            const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
            out_ext->dynamicPrimitiveTopologyUnrestricted = in_ext->dynamicPrimitiveTopologyUnrestricted;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            VkPhysicalDeviceRobustness2PropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT);
            const VkPhysicalDeviceRobustness2PropertiesEXT *in_ext = (const VkPhysicalDeviceRobustness2PropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
            out_ext->robustStorageBufferAccessSizeAlignment = in_ext->robustStorageBufferAccessSizeAlignment;
            out_ext->robustUniformBufferAccessSizeAlignment = in_ext->robustUniformBufferAccessSizeAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR);
            const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *in_ext = (const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
            out_ext->minFragmentShadingRateAttachmentTexelSize = in_ext->minFragmentShadingRateAttachmentTexelSize;
            out_ext->maxFragmentShadingRateAttachmentTexelSize = in_ext->maxFragmentShadingRateAttachmentTexelSize;
            out_ext->maxFragmentShadingRateAttachmentTexelSizeAspectRatio = in_ext->maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
            out_ext->primitiveFragmentShadingRateWithMultipleViewports = in_ext->primitiveFragmentShadingRateWithMultipleViewports;
            out_ext->layeredShadingRateAttachments = in_ext->layeredShadingRateAttachments;
            out_ext->fragmentShadingRateNonTrivialCombinerOps = in_ext->fragmentShadingRateNonTrivialCombinerOps;
            out_ext->maxFragmentSize = in_ext->maxFragmentSize;
            out_ext->maxFragmentSizeAspectRatio = in_ext->maxFragmentSizeAspectRatio;
            out_ext->maxFragmentShadingRateCoverageSamples = in_ext->maxFragmentShadingRateCoverageSamples;
            out_ext->maxFragmentShadingRateRasterizationSamples = in_ext->maxFragmentShadingRateRasterizationSamples;
            out_ext->fragmentShadingRateWithShaderDepthStencilWrites = in_ext->fragmentShadingRateWithShaderDepthStencilWrites;
            out_ext->fragmentShadingRateWithSampleMask = in_ext->fragmentShadingRateWithSampleMask;
            out_ext->fragmentShadingRateWithShaderSampleMask = in_ext->fragmentShadingRateWithShaderSampleMask;
            out_ext->fragmentShadingRateWithConservativeRasterization = in_ext->fragmentShadingRateWithConservativeRasterization;
            out_ext->fragmentShadingRateWithFragmentShaderInterlock = in_ext->fragmentShadingRateWithFragmentShaderInterlock;
            out_ext->fragmentShadingRateWithCustomSampleLocations = in_ext->fragmentShadingRateWithCustomSampleLocations;
            out_ext->fragmentShadingRateStrictMultiplyCombiner = in_ext->fragmentShadingRateStrictMultiplyCombiner;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV);
            const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
            out_ext->maxFragmentShadingRateInvocationCount = in_ext->maxFragmentShadingRateInvocationCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
        {
            VkPhysicalDeviceHostImageCopyPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT);
            const VkPhysicalDeviceHostImageCopyPropertiesEXT *in_ext = (const VkPhysicalDeviceHostImageCopyPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT;
            out_ext->copySrcLayoutCount = in_ext->copySrcLayoutCount;
            out_ext->pCopySrcLayouts = PtrToUlong(in_ext->pCopySrcLayouts);
            out_ext->copyDstLayoutCount = in_ext->copyDstLayoutCount;
            out_ext->pCopyDstLayouts = PtrToUlong(in_ext->pCopyDstLayouts);
            memcpy(out_ext->optimalTilingLayoutUUID, in_ext->optimalTilingLayoutUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->identicalMemoryTypeRequirements = in_ext->identicalMemoryTypeRequirements;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
            VkPhysicalDeviceProvokingVertexPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT);
            const VkPhysicalDeviceProvokingVertexPropertiesEXT *in_ext = (const VkPhysicalDeviceProvokingVertexPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
            out_ext->provokingVertexModePerPipeline = in_ext->provokingVertexModePerPipeline;
            out_ext->transformFeedbackPreservesTriangleFanProvokingVertex = in_ext->transformFeedbackPreservesTriangleFanProvokingVertex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT);
            const VkPhysicalDeviceDescriptorBufferPropertiesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
            out_ext->combinedImageSamplerDescriptorSingleArray = in_ext->combinedImageSamplerDescriptorSingleArray;
            out_ext->bufferlessPushDescriptors = in_ext->bufferlessPushDescriptors;
            out_ext->allowSamplerImageViewPostSubmitCreation = in_ext->allowSamplerImageViewPostSubmitCreation;
            out_ext->descriptorBufferOffsetAlignment = in_ext->descriptorBufferOffsetAlignment;
            out_ext->maxDescriptorBufferBindings = in_ext->maxDescriptorBufferBindings;
            out_ext->maxResourceDescriptorBufferBindings = in_ext->maxResourceDescriptorBufferBindings;
            out_ext->maxSamplerDescriptorBufferBindings = in_ext->maxSamplerDescriptorBufferBindings;
            out_ext->maxEmbeddedImmutableSamplerBindings = in_ext->maxEmbeddedImmutableSamplerBindings;
            out_ext->maxEmbeddedImmutableSamplers = in_ext->maxEmbeddedImmutableSamplers;
            out_ext->bufferCaptureReplayDescriptorDataSize = in_ext->bufferCaptureReplayDescriptorDataSize;
            out_ext->imageCaptureReplayDescriptorDataSize = in_ext->imageCaptureReplayDescriptorDataSize;
            out_ext->imageViewCaptureReplayDescriptorDataSize = in_ext->imageViewCaptureReplayDescriptorDataSize;
            out_ext->samplerCaptureReplayDescriptorDataSize = in_ext->samplerCaptureReplayDescriptorDataSize;
            out_ext->accelerationStructureCaptureReplayDescriptorDataSize = in_ext->accelerationStructureCaptureReplayDescriptorDataSize;
            out_ext->samplerDescriptorSize = in_ext->samplerDescriptorSize;
            out_ext->combinedImageSamplerDescriptorSize = in_ext->combinedImageSamplerDescriptorSize;
            out_ext->sampledImageDescriptorSize = in_ext->sampledImageDescriptorSize;
            out_ext->storageImageDescriptorSize = in_ext->storageImageDescriptorSize;
            out_ext->uniformTexelBufferDescriptorSize = in_ext->uniformTexelBufferDescriptorSize;
            out_ext->robustUniformTexelBufferDescriptorSize = in_ext->robustUniformTexelBufferDescriptorSize;
            out_ext->storageTexelBufferDescriptorSize = in_ext->storageTexelBufferDescriptorSize;
            out_ext->robustStorageTexelBufferDescriptorSize = in_ext->robustStorageTexelBufferDescriptorSize;
            out_ext->uniformBufferDescriptorSize = in_ext->uniformBufferDescriptorSize;
            out_ext->robustUniformBufferDescriptorSize = in_ext->robustUniformBufferDescriptorSize;
            out_ext->storageBufferDescriptorSize = in_ext->storageBufferDescriptorSize;
            out_ext->robustStorageBufferDescriptorSize = in_ext->robustStorageBufferDescriptorSize;
            out_ext->inputAttachmentDescriptorSize = in_ext->inputAttachmentDescriptorSize;
            out_ext->accelerationStructureDescriptorSize = in_ext->accelerationStructureDescriptorSize;
            out_ext->maxSamplerDescriptorBufferRange = in_ext->maxSamplerDescriptorBufferRange;
            out_ext->maxResourceDescriptorBufferRange = in_ext->maxResourceDescriptorBufferRange;
            out_ext->samplerDescriptorBufferAddressSpaceSize = in_ext->samplerDescriptorBufferAddressSpaceSize;
            out_ext->resourceDescriptorBufferAddressSpaceSize = in_ext->resourceDescriptorBufferAddressSpaceSize;
            out_ext->descriptorBufferAddressSpaceSize = in_ext->descriptorBufferAddressSpaceSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT);
            const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->combinedImageSamplerDensityMapDescriptorSize = in_ext->combinedImageSamplerDensityMapDescriptorSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
            VkPhysicalDeviceShaderIntegerDotProductProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES);
            const VkPhysicalDeviceShaderIntegerDotProductProperties *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
            out_ext->integerDotProduct8BitUnsignedAccelerated = in_ext->integerDotProduct8BitUnsignedAccelerated;
            out_ext->integerDotProduct8BitSignedAccelerated = in_ext->integerDotProduct8BitSignedAccelerated;
            out_ext->integerDotProduct8BitMixedSignednessAccelerated = in_ext->integerDotProduct8BitMixedSignednessAccelerated;
            out_ext->integerDotProduct4x8BitPackedUnsignedAccelerated = in_ext->integerDotProduct4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedSignedAccelerated = in_ext->integerDotProduct4x8BitPackedSignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProduct16BitUnsignedAccelerated = in_ext->integerDotProduct16BitUnsignedAccelerated;
            out_ext->integerDotProduct16BitSignedAccelerated = in_ext->integerDotProduct16BitSignedAccelerated;
            out_ext->integerDotProduct16BitMixedSignednessAccelerated = in_ext->integerDotProduct16BitMixedSignednessAccelerated;
            out_ext->integerDotProduct32BitUnsignedAccelerated = in_ext->integerDotProduct32BitUnsignedAccelerated;
            out_ext->integerDotProduct32BitSignedAccelerated = in_ext->integerDotProduct32BitSignedAccelerated;
            out_ext->integerDotProduct32BitMixedSignednessAccelerated = in_ext->integerDotProduct32BitMixedSignednessAccelerated;
            out_ext->integerDotProduct64BitUnsignedAccelerated = in_ext->integerDotProduct64BitUnsignedAccelerated;
            out_ext->integerDotProduct64BitSignedAccelerated = in_ext->integerDotProduct64BitSignedAccelerated;
            out_ext->integerDotProduct64BitMixedSignednessAccelerated = in_ext->integerDotProduct64BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR);
            const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
            out_ext->triStripVertexOrderIndependentOfProvokingVertex = in_ext->triStripVertexOrderIndependentOfProvokingVertex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT);
            const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
            out_ext->graphicsPipelineLibraryFastLinking = in_ext->graphicsPipelineLibraryFastLinking;
            out_ext->graphicsPipelineLibraryIndependentInterpolationDecoration = in_ext->graphicsPipelineLibraryIndependentInterpolationDecoration;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT);
            const VkPhysicalDeviceNestedCommandBufferPropertiesEXT *in_ext = (const VkPhysicalDeviceNestedCommandBufferPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT;
            out_ext->maxCommandBufferNestingLevel = in_ext->maxCommandBufferNestingLevel;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT);
            const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
            memcpy(out_ext->shaderModuleIdentifierAlgorithmUUID, in_ext->shaderModuleIdentifierAlgorithmUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT);
            const VkPhysicalDeviceOpacityMicromapPropertiesEXT *in_ext = (const VkPhysicalDeviceOpacityMicromapPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
            out_ext->maxOpacity2StateSubdivisionLevel = in_ext->maxOpacity2StateSubdivisionLevel;
            out_ext->maxOpacity4StateSubdivisionLevel = in_ext->maxOpacity4StateSubdivisionLevel;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
        {
            VkPhysicalDevicePipelineRobustnessPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT);
            const VkPhysicalDevicePipelineRobustnessPropertiesEXT *in_ext = (const VkPhysicalDevicePipelineRobustnessPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT;
            out_ext->defaultRobustnessStorageBuffers = in_ext->defaultRobustnessStorageBuffers;
            out_ext->defaultRobustnessUniformBuffers = in_ext->defaultRobustnessUniformBuffers;
            out_ext->defaultRobustnessVertexInputs = in_ext->defaultRobustnessVertexInputs;
            out_ext->defaultRobustnessImages = in_ext->defaultRobustnessImages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessingPropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM);
            const VkPhysicalDeviceImageProcessingPropertiesQCOM *in_ext = (const VkPhysicalDeviceImageProcessingPropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
            out_ext->maxWeightFilterPhases = in_ext->maxWeightFilterPhases;
            out_ext->maxWeightFilterDimension = in_ext->maxWeightFilterDimension;
            out_ext->maxBlockMatchRegion = in_ext->maxBlockMatchRegion;
            out_ext->maxBoxFilterBlockSize = in_ext->maxBoxFilterBlockSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
            VkPhysicalDeviceOpticalFlowPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV);
            const VkPhysicalDeviceOpticalFlowPropertiesNV *in_ext = (const VkPhysicalDeviceOpticalFlowPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
            out_ext->supportedOutputGridSizes = in_ext->supportedOutputGridSizes;
            out_ext->supportedHintGridSizes = in_ext->supportedHintGridSizes;
            out_ext->hintSupported = in_ext->hintSupported;
            out_ext->costSupported = in_ext->costSupported;
            out_ext->bidirectionalFlowSupported = in_ext->bidirectionalFlowSupported;
            out_ext->globalFlowSupported = in_ext->globalFlowSupported;
            out_ext->minWidth = in_ext->minWidth;
            out_ext->minHeight = in_ext->minHeight;
            out_ext->maxWidth = in_ext->maxWidth;
            out_ext->maxHeight = in_ext->maxHeight;
            out_ext->maxNumRegionsOfInterest = in_ext->maxNumRegionsOfInterest;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM);
            const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
            out_ext->shaderCoreMask = in_ext->shaderCoreMask;
            out_ext->shaderCoreCount = in_ext->shaderCoreCount;
            out_ext->shaderWarpsPerCore = in_ext->shaderWarpsPerCore;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV);
            const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
            out_ext->rayTracingInvocationReorderReorderingHint = in_ext->rayTracingInvocationReorderReorderingHint;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV);
            const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV;
            out_ext->extendedSparseAddressSpaceSize = in_ext->extendedSparseAddressSpaceSize;
            out_ext->extendedSparseImageUsageFlags = in_ext->extendedSparseImageUsageFlags;
            out_ext->extendedSparseBufferUsageFlags = in_ext->extendedSparseBufferUsageFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCorePropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM);
            const VkPhysicalDeviceShaderCorePropertiesARM *in_ext = (const VkPhysicalDeviceShaderCorePropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
            out_ext->pixelRate = in_ext->pixelRate;
            out_ext->texelRate = in_ext->texelRate;
            out_ext->fmaRate = in_ext->fmaRate;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderObjectPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT);
            const VkPhysicalDeviceShaderObjectPropertiesEXT *in_ext = (const VkPhysicalDeviceShaderObjectPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
            memcpy(out_ext->shaderBinaryUUID, in_ext->shaderBinaryUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->shaderBinaryVersion = in_ext->shaderBinaryVersion;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderTileImagePropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT);
            const VkPhysicalDeviceShaderTileImagePropertiesEXT *in_ext = (const VkPhysicalDeviceShaderTileImagePropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
            out_ext->shaderTileImageCoherentReadAccelerated = in_ext->shaderTileImageCoherentReadAccelerated;
            out_ext->shaderTileImageReadSampleFromPixelRateInvocation = in_ext->shaderTileImageReadSampleFromPixelRateInvocation;
            out_ext->shaderTileImageReadFromHelperInvocation = in_ext->shaderTileImageReadFromHelperInvocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR);
            const VkPhysicalDeviceCooperativeMatrixPropertiesKHR *in_ext = (const VkPhysicalDeviceCooperativeMatrixPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
            out_ext->cooperativeMatrixSupportedStages = in_ext->cooperativeMatrixSupportedStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2PropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM);
            const VkPhysicalDeviceImageProcessing2PropertiesQCOM *in_ext = (const VkPhysicalDeviceImageProcessing2PropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM;
            out_ext->maxBlockMatchWindow = in_ext->maxBlockMatchWindow;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
            VkPhysicalDeviceLayeredDriverPropertiesMSFT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT);
            const VkPhysicalDeviceLayeredDriverPropertiesMSFT *in_ext = (const VkPhysicalDeviceLayeredDriverPropertiesMSFT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT;
            out_ext->underlyingAPI = in_ext->underlyingAPI;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline void convert_VkQueryPoolPerformanceCreateInfoKHR_win32_to_host(const VkQueryPoolPerformanceCreateInfoKHR32 *in, VkQueryPoolPerformanceCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->counterIndexCount = in->counterIndexCount;
    out->pCounterIndices = (const uint32_t *)UlongToPtr(in->pCounterIndices);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkQueueFamilyProperties2_win32_to_host(struct conversion_context *ctx, const VkQueueFamilyProperties232 *in, VkQueueFamilyProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
        {
            VkQueueFamilyGlobalPriorityPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueueFamilyGlobalPriorityPropertiesKHR32 *in_ext = (const VkQueueFamilyGlobalPriorityPropertiesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_ext->priorityCount = in_ext->priorityCount;
            memcpy(out_ext->priorities, in_ext->priorities, VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            VkQueueFamilyCheckpointPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
            VkQueueFamilyCheckpointProperties2NV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkQueueFamilyProperties2_host_to_win32(const VkQueueFamilyProperties2 *in, VkQueueFamilyProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->queueFamilyProperties = in->queueFamilyProperties;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
        {
            VkQueueFamilyGlobalPriorityPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR);
            const VkQueueFamilyGlobalPriorityPropertiesKHR *in_ext = (const VkQueueFamilyGlobalPriorityPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
            out_ext->priorityCount = in_ext->priorityCount;
            memcpy(out_ext->priorities, in_ext->priorities, VK_MAX_GLOBAL_PRIORITY_SIZE_KHR * sizeof(VkQueueGlobalPriorityKHR));
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            VkQueueFamilyCheckpointPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV);
            const VkQueueFamilyCheckpointPropertiesNV *in_ext = (const VkQueueFamilyCheckpointPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
            out_ext->checkpointExecutionStageMask = in_ext->checkpointExecutionStageMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
            VkQueueFamilyCheckpointProperties2NV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV);
            const VkQueueFamilyCheckpointProperties2NV *in_ext = (const VkQueueFamilyCheckpointProperties2NV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
            out_ext->checkpointExecutionStageMask = in_ext->checkpointExecutionStageMask;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline VkQueueFamilyProperties2 *convert_VkQueueFamilyProperties2_array_win32_to_host(struct conversion_context *ctx, const VkQueueFamilyProperties232 *in, uint32_t count)
{
    VkQueueFamilyProperties2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkQueueFamilyProperties2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkQueueFamilyProperties2_array_host_to_win32(const VkQueueFamilyProperties2 *in, VkQueueFamilyProperties232 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkQueueFamilyProperties2_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPhysicalDeviceSparseImageFormatInfo2_win32_to_host(const VkPhysicalDeviceSparseImageFormatInfo232 *in, VkPhysicalDeviceSparseImageFormatInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->type = in->type;
    out->samples = in->samples;
    out->usage = in->usage;
    out->tiling = in->tiling;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSparseImageFormatProperties2_win32_to_host(const VkSparseImageFormatProperties232 *in, VkSparseImageFormatProperties2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSparseImageFormatProperties2_host_to_win32(const VkSparseImageFormatProperties2 *in, VkSparseImageFormatProperties232 *out)
{
    if (!in) return;

    out->properties = in->properties;
}

static inline VkSparseImageFormatProperties2 *convert_VkSparseImageFormatProperties2_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageFormatProperties232 *in, uint32_t count)
{
    VkSparseImageFormatProperties2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageFormatProperties2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSparseImageFormatProperties2_array_host_to_win32(const VkSparseImageFormatProperties2 *in, VkSparseImageFormatProperties232 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageFormatProperties2_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkFramebufferMixedSamplesCombinationNV_win32_to_host(const VkFramebufferMixedSamplesCombinationNV32 *in, VkFramebufferMixedSamplesCombinationNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkFramebufferMixedSamplesCombinationNV_host_to_win32(const VkFramebufferMixedSamplesCombinationNV *in, VkFramebufferMixedSamplesCombinationNV32 *out)
{
    if (!in) return;

    out->coverageReductionMode = in->coverageReductionMode;
    out->rasterizationSamples = in->rasterizationSamples;
    out->depthStencilSamples = in->depthStencilSamples;
    out->colorSamples = in->colorSamples;
}

static inline VkFramebufferMixedSamplesCombinationNV *convert_VkFramebufferMixedSamplesCombinationNV_array_win32_to_host(struct conversion_context *ctx, const VkFramebufferMixedSamplesCombinationNV32 *in, uint32_t count)
{
    VkFramebufferMixedSamplesCombinationNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkFramebufferMixedSamplesCombinationNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkFramebufferMixedSamplesCombinationNV_array_host_to_win32(const VkFramebufferMixedSamplesCombinationNV *in, VkFramebufferMixedSamplesCombinationNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkFramebufferMixedSamplesCombinationNV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPhysicalDeviceSurfaceInfo2KHR32 *in, VkPhysicalDeviceSurfaceInfo2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->surface = in->surface;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
        {
            VkSurfacePresentModeEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentModeEXT32 *in_ext = (const VkSurfacePresentModeEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT;
            out_ext->pNext = NULL;
            out_ext->presentMode = in_ext->presentMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSurfaceCapabilities2KHR_win32_to_host(struct conversion_context *ctx, const VkSurfaceCapabilities2KHR32 *in, VkSurfaceCapabilities2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
            VkSurfaceCapabilitiesPresentBarrierNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
        {
            VkSurfacePresentScalingCapabilitiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentScalingCapabilitiesEXT32 *in_ext = (const VkSurfacePresentScalingCapabilitiesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT;
            out_ext->pNext = NULL;
            out_ext->supportedPresentScaling = in_ext->supportedPresentScaling;
            out_ext->supportedPresentGravityX = in_ext->supportedPresentGravityX;
            out_ext->supportedPresentGravityY = in_ext->supportedPresentGravityY;
            out_ext->minScaledImageExtent = in_ext->minScaledImageExtent;
            out_ext->maxScaledImageExtent = in_ext->maxScaledImageExtent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
        {
            VkSurfacePresentModeCompatibilityEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentModeCompatibilityEXT32 *in_ext = (const VkSurfacePresentModeCompatibilityEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT;
            out_ext->pNext = NULL;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = (VkPresentModeKHR *)UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
        {
            VkLatencySurfaceCapabilitiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySurfaceCapabilitiesNV32 *in_ext = (const VkLatencySurfaceCapabilitiesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV;
            out_ext->pNext = NULL;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = (VkPresentModeKHR *)UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSurfaceCapabilities2KHR_host_to_win32(const VkSurfaceCapabilities2KHR *in, VkSurfaceCapabilities2KHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->surfaceCapabilities = in->surfaceCapabilities;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
            VkSurfaceCapabilitiesPresentBarrierNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV);
            const VkSurfaceCapabilitiesPresentBarrierNV *in_ext = (const VkSurfaceCapabilitiesPresentBarrierNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
            out_ext->presentBarrierSupported = in_ext->presentBarrierSupported;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
        {
            VkSurfacePresentScalingCapabilitiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT);
            const VkSurfacePresentScalingCapabilitiesEXT *in_ext = (const VkSurfacePresentScalingCapabilitiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT;
            out_ext->supportedPresentScaling = in_ext->supportedPresentScaling;
            out_ext->supportedPresentGravityX = in_ext->supportedPresentGravityX;
            out_ext->supportedPresentGravityY = in_ext->supportedPresentGravityY;
            out_ext->minScaledImageExtent = in_ext->minScaledImageExtent;
            out_ext->maxScaledImageExtent = in_ext->maxScaledImageExtent;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
        {
            VkSurfacePresentModeCompatibilityEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT);
            const VkSurfacePresentModeCompatibilityEXT *in_ext = (const VkSurfacePresentModeCompatibilityEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = PtrToUlong(in_ext->pPresentModes);
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
        {
            VkLatencySurfaceCapabilitiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV);
            const VkLatencySurfaceCapabilitiesNV *in_ext = (const VkLatencySurfaceCapabilitiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = PtrToUlong(in_ext->pPresentModes);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static inline void convert_VkPhysicalDeviceSurfaceInfo2KHR_win64_to_host(const VkPhysicalDeviceSurfaceInfo2KHR *in, VkPhysicalDeviceSurfaceInfo2KHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->surface = in->surface ? wine_surface_from_handle(in->surface)->driver_surface : 0;
}
#endif /* _WIN64 */

static inline void convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceSurfaceInfo2KHR32 *in, VkPhysicalDeviceSurfaceInfo2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->surface = in->surface ? wine_surface_from_handle(in->surface)->driver_surface : 0;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
        {
            VkSurfacePresentModeEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentModeEXT32 *in_ext = (const VkSurfacePresentModeEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT;
            out_ext->pNext = NULL;
            out_ext->presentMode = in_ext->presentMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSurfaceFormat2KHR_win32_to_host(struct conversion_context *ctx, const VkSurfaceFormat2KHR32 *in, VkSurfaceFormat2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkSurfaceFormat2KHR_host_to_win32(const VkSurfaceFormat2KHR *in, VkSurfaceFormat2KHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->surfaceFormat = in->surfaceFormat;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT);
            const VkImageCompressionPropertiesEXT *in_ext = (const VkImageCompressionPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->imageCompressionFlags = in_ext->imageCompressionFlags;
            out_ext->imageCompressionFixedRateFlags = in_ext->imageCompressionFixedRateFlags;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static inline VkSurfaceFormat2KHR *convert_VkSurfaceFormat2KHR_array_win32_to_host(struct conversion_context *ctx, const VkSurfaceFormat2KHR32 *in, uint32_t count)
{
    VkSurfaceFormat2KHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSurfaceFormat2KHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSurfaceFormat2KHR_array_host_to_win32(const VkSurfaceFormat2KHR *in, VkSurfaceFormat2KHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSurfaceFormat2KHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPhysicalDeviceToolProperties_win32_to_host(const VkPhysicalDeviceToolProperties32 *in, VkPhysicalDeviceToolProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPhysicalDeviceToolProperties_host_to_win32(const VkPhysicalDeviceToolProperties *in, VkPhysicalDeviceToolProperties32 *out)
{
    if (!in) return;

    memcpy(out->name, in->name, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    memcpy(out->version, in->version, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    out->purposes = in->purposes;
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->layer, in->layer, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
}

static inline VkPhysicalDeviceToolProperties *convert_VkPhysicalDeviceToolProperties_array_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceToolProperties32 *in, uint32_t count)
{
    VkPhysicalDeviceToolProperties *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceToolProperties_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPhysicalDeviceToolProperties_array_host_to_win32(const VkPhysicalDeviceToolProperties *in, VkPhysicalDeviceToolProperties32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceToolProperties_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPipelineExecutableInfoKHR_win32_to_host(const VkPipelineExecutableInfoKHR32 *in, VkPipelineExecutableInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    out->executableIndex = in->executableIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineExecutableInternalRepresentationKHR_win32_to_host(const VkPipelineExecutableInternalRepresentationKHR32 *in, VkPipelineExecutableInternalRepresentationKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineExecutableInternalRepresentationKHR_host_to_win32(const VkPipelineExecutableInternalRepresentationKHR *in, VkPipelineExecutableInternalRepresentationKHR32 *out)
{
    if (!in) return;

    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->isText = in->isText;
    out->dataSize = in->dataSize;
    out->pData = PtrToUlong(in->pData);
}

static inline VkPipelineExecutableInternalRepresentationKHR *convert_VkPipelineExecutableInternalRepresentationKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineExecutableInternalRepresentationKHR32 *in, uint32_t count)
{
    VkPipelineExecutableInternalRepresentationKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableInternalRepresentationKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineExecutableInternalRepresentationKHR_array_host_to_win32(const VkPipelineExecutableInternalRepresentationKHR *in, VkPipelineExecutableInternalRepresentationKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableInternalRepresentationKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPipelineInfoKHR_win32_to_host(const VkPipelineInfoKHR32 *in, VkPipelineInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineExecutablePropertiesKHR_win32_to_host(const VkPipelineExecutablePropertiesKHR32 *in, VkPipelineExecutablePropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineExecutablePropertiesKHR_host_to_win32(const VkPipelineExecutablePropertiesKHR *in, VkPipelineExecutablePropertiesKHR32 *out)
{
    if (!in) return;

    out->stages = in->stages;
    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->subgroupSize = in->subgroupSize;
}

static inline VkPipelineExecutablePropertiesKHR *convert_VkPipelineExecutablePropertiesKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineExecutablePropertiesKHR32 *in, uint32_t count)
{
    VkPipelineExecutablePropertiesKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutablePropertiesKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineExecutablePropertiesKHR_array_host_to_win32(const VkPipelineExecutablePropertiesKHR *in, VkPipelineExecutablePropertiesKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutablePropertiesKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPipelineExecutableStatisticValueKHR_host_to_win32(const VkPipelineExecutableStatisticValueKHR *in, VkPipelineExecutableStatisticValueKHR32 *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR)
        out->b32 = in->b32;
    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR)
        out->i64 = in->i64;
    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR)
        out->u64 = in->u64;
    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR)
        out->f64 = in->f64;
}

static inline void convert_VkPipelineExecutableStatisticKHR_win32_to_host(const VkPipelineExecutableStatisticKHR32 *in, VkPipelineExecutableStatisticKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineExecutableStatisticKHR_host_to_win32(const VkPipelineExecutableStatisticKHR *in, VkPipelineExecutableStatisticKHR32 *out)
{
    if (!in) return;

    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->format = in->format;
    convert_VkPipelineExecutableStatisticValueKHR_host_to_win32(&in->value, &out->value, in->format);
}

static inline VkPipelineExecutableStatisticKHR *convert_VkPipelineExecutableStatisticKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineExecutableStatisticKHR32 *in, uint32_t count)
{
    VkPipelineExecutableStatisticKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableStatisticKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPipelineExecutableStatisticKHR_array_host_to_win32(const VkPipelineExecutableStatisticKHR *in, VkPipelineExecutableStatisticKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableStatisticKHR_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkPipelineIndirectDeviceAddressInfoNV_win32_to_host(const VkPipelineIndirectDeviceAddressInfoNV32 *in, VkPipelineIndirectDeviceAddressInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPipelineInfoEXT_win32_to_host(const VkPipelineInfoEXT32 *in, VkPipelineInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCheckpointData2NV_win32_to_host(const VkCheckpointData2NV32 *in, VkCheckpointData2NV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCheckpointData2NV_host_to_win32(const VkCheckpointData2NV *in, VkCheckpointData2NV32 *out)
{
    if (!in) return;

    out->stage = in->stage;
    out->pCheckpointMarker = PtrToUlong(in->pCheckpointMarker);
}

static inline VkCheckpointData2NV *convert_VkCheckpointData2NV_array_win32_to_host(struct conversion_context *ctx, const VkCheckpointData2NV32 *in, uint32_t count)
{
    VkCheckpointData2NV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointData2NV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCheckpointData2NV_array_host_to_win32(const VkCheckpointData2NV *in, VkCheckpointData2NV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointData2NV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkCheckpointDataNV_win32_to_host(const VkCheckpointDataNV32 *in, VkCheckpointDataNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCheckpointDataNV_host_to_win32(const VkCheckpointDataNV *in, VkCheckpointDataNV32 *out)
{
    if (!in) return;

    out->stage = in->stage;
    out->pCheckpointMarker = PtrToUlong(in->pCheckpointMarker);
}

static inline VkCheckpointDataNV *convert_VkCheckpointDataNV_array_win32_to_host(struct conversion_context *ctx, const VkCheckpointDataNV32 *in, uint32_t count)
{
    VkCheckpointDataNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointDataNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCheckpointDataNV_array_host_to_win32(const VkCheckpointDataNV *in, VkCheckpointDataNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointDataNV_host_to_win32(&in[i], &out[i]);
    }
}

static inline void convert_VkRenderingAreaInfoKHR_win32_to_host(const VkRenderingAreaInfoKHR32 *in, VkRenderingAreaInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->viewMask = in->viewMask;
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachmentFormats = (const VkFormat *)UlongToPtr(in->pColorAttachmentFormats);
    out->depthAttachmentFormat = in->depthAttachmentFormat;
    out->stencilAttachmentFormat = in->stencilAttachmentFormat;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSamplerCaptureDescriptorDataInfoEXT_win32_to_host(const VkSamplerCaptureDescriptorDataInfoEXT32 *in, VkSamplerCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->sampler = in->sampler;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline void convert_VkSemaphoreGetFdInfoKHR_win64_to_host(const VkSemaphoreGetFdInfoKHR *in, VkSemaphoreGetFdInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->semaphore = in->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->semaphore) ) : VK_NULL_HANDLE;
    out->handleType = in->handleType;
}
#endif /* _WIN64 */

static inline void convert_VkSemaphoreGetFdInfoKHR_win32_to_host(const VkSemaphoreGetFdInfoKHR32 *in, VkSemaphoreGetFdInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->semaphore) ) : VK_NULL_HANDLE;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkSemaphoreGetWin32HandleInfoKHR32 *in, VkSemaphoreGetWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkShaderModuleIdentifierEXT_win32_to_host(const VkShaderModuleIdentifierEXT32 *in, VkShaderModuleIdentifierEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkShaderModuleIdentifierEXT_host_to_win32(const VkShaderModuleIdentifierEXT *in, VkShaderModuleIdentifierEXT32 *out)
{
    if (!in) return;

    out->identifierSize = in->identifierSize;
    memcpy(out->identifier, in->identifier, VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT * sizeof(uint8_t));
}

#ifdef _WIN64
static inline void convert_VkImportSemaphoreFdInfoKHR_win64_to_host(const VkImportSemaphoreFdInfoKHR *in, VkImportSemaphoreFdInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->semaphore = in->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->semaphore) ) : VK_NULL_HANDLE;
    out->flags = in->flags;
    out->handleType = in->handleType;
    out->fd = in->fd;
}
#endif /* _WIN64 */

static inline void convert_VkImportSemaphoreFdInfoKHR_win32_to_host(const VkImportSemaphoreFdInfoKHR32 *in, VkImportSemaphoreFdInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->semaphore) ) : VK_NULL_HANDLE;
    out->flags = in->flags;
    out->handleType = in->handleType;
    out->fd = in->fd;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host(const VkImportSemaphoreWin32HandleInfoKHR32 *in, VkImportSemaphoreWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->flags = in->flags;
    out->handleType = in->handleType;
    out->handle = in->handle;
    out->name = in->name;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkInitializePerformanceApiInfoINTEL_win32_to_host(const VkInitializePerformanceApiInfoINTEL32 *in, VkInitializePerformanceApiInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pUserData = (void *)UlongToPtr(in->pUserData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline void convert_VkLatencySleepInfoNV_win64_to_host(const VkLatencySleepInfoNV *in, VkLatencySleepInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->signalSemaphore = in->signalSemaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->signalSemaphore) ) : VK_NULL_HANDLE;
    out->value = in->value;
}
#endif /* _WIN64 */

static inline void convert_VkLatencySleepInfoNV_win32_to_host(const VkLatencySleepInfoNV32 *in, VkLatencySleepInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->signalSemaphore = in->signalSemaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(in->signalSemaphore) ) : VK_NULL_HANDLE;
    out->value = in->value;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkMemoryMapInfoKHR_win32_to_unwrapped_host(const VkMemoryMapInfoKHR32 *in, VkMemoryMapInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->memory = in->memory;
    out->offset = in->offset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSparseMemoryBind_win32_to_unwrapped_host(const VkSparseMemoryBind32 *in, VkSparseMemoryBind *out)
{
    if (!in) return;

    out->resourceOffset = in->resourceOffset;
    out->size = in->size;
    out->memory = in->memory;
    out->memoryOffset = in->memoryOffset;
    out->flags = in->flags;
}

static inline const VkSparseMemoryBind *convert_VkSparseMemoryBind_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseMemoryBind32 *in, uint32_t count)
{
    VkSparseMemoryBind *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseMemoryBind_win32_to_unwrapped_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSparseBufferMemoryBindInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, VkSparseBufferMemoryBindInfo *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_unwrapped_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
}

static inline const VkSparseBufferMemoryBindInfo *convert_VkSparseBufferMemoryBindInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, uint32_t count)
{
    VkSparseBufferMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseBufferMemoryBindInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, VkSparseImageOpaqueMemoryBindInfo *out)
{
    if (!in) return;

    out->image = in->image;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_unwrapped_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
}

static inline const VkSparseImageOpaqueMemoryBindInfo *convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, uint32_t count)
{
    VkSparseImageOpaqueMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSparseImageMemoryBind_win32_to_unwrapped_host(const VkSparseImageMemoryBind32 *in, VkSparseImageMemoryBind *out)
{
    if (!in) return;

    out->subresource = in->subresource;
    out->offset = in->offset;
    out->extent = in->extent;
    out->memory = in->memory;
    out->memoryOffset = in->memoryOffset;
    out->flags = in->flags;
}

static inline const VkSparseImageMemoryBind *convert_VkSparseImageMemoryBind_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageMemoryBind32 *in, uint32_t count)
{
    VkSparseImageMemoryBind *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryBind_win32_to_unwrapped_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSparseImageMemoryBindInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, VkSparseImageMemoryBindInfo *out)
{
    if (!in) return;

    out->image = in->image;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseImageMemoryBind_array_win32_to_unwrapped_host(ctx, (const VkSparseImageMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
}

static inline const VkSparseImageMemoryBindInfo *convert_VkSparseImageMemoryBindInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, uint32_t count)
{
    VkSparseImageMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryBindInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkBindSparseInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo *in, VkBindSparseInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = in->pWaitSemaphores;
    out->bufferBindCount = in->bufferBindCount;
    out->pBufferBinds = in->pBufferBinds;
    out->imageOpaqueBindCount = in->imageOpaqueBindCount;
    out->pImageOpaqueBinds = in->pImageOpaqueBinds;
    out->imageBindCount = in->imageBindCount;
    out->pImageBinds = in->pImageBinds;
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = in->pSignalSemaphores;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            VkDeviceGroupBindSparseInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupBindSparseInfo *in_ext = (const VkDeviceGroupBindSparseInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
            out_ext->pNext = NULL;
            out_ext->resourceDeviceIndex = in_ext->resourceDeviceIndex;
            out_ext->memoryDeviceIndex = in_ext->memoryDeviceIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo *in_ext = (const VkTimelineSemaphoreSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = in_ext->pImages;
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = in_ext->pBuffers;
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = in_ext->pTag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkBindSparseInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, VkBindSparseInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores);
    out->bufferBindCount = in->bufferBindCount;
    out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win32_to_unwrapped_host(ctx, (const VkSparseBufferMemoryBindInfo32 *)UlongToPtr(in->pBufferBinds), in->bufferBindCount);
    out->imageOpaqueBindCount = in->imageOpaqueBindCount;
    out->pImageOpaqueBinds = convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_unwrapped_host(ctx, (const VkSparseImageOpaqueMemoryBindInfo32 *)UlongToPtr(in->pImageOpaqueBinds), in->imageOpaqueBindCount);
    out->imageBindCount = in->imageBindCount;
    out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win32_to_unwrapped_host(ctx, (const VkSparseImageMemoryBindInfo32 *)UlongToPtr(in->pImageBinds), in->imageBindCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            VkDeviceGroupBindSparseInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupBindSparseInfo32 *in_ext = (const VkDeviceGroupBindSparseInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
            out_ext->pNext = NULL;
            out_ext->resourceDeviceIndex = in_ext->resourceDeviceIndex;
            out_ext->memoryDeviceIndex = in_ext->memoryDeviceIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo32 *in_ext = (const VkTimelineSemaphoreSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = (const uint64_t *)UlongToPtr(in_ext->pWaitSemaphoreValues);
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = (const uint64_t *)UlongToPtr(in_ext->pSignalSemaphoreValues);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = (const VkImage *)UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = (const VkBuffer *)UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = (const void *)UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkBindSparseInfo *convert_VkBindSparseInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo *in, uint32_t count)
{
    VkBindSparseInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindSparseInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkBindSparseInfo *convert_VkBindSparseInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, uint32_t count)
{
    VkBindSparseInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindSparseInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkOutOfBandQueueTypeInfoNV_win32_to_host(const VkOutOfBandQueueTypeInfoNV32 *in, VkOutOfBandQueueTypeInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->queueType = in->queueType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkPresentRegionKHR_win32_to_host(const VkPresentRegionKHR32 *in, VkPresentRegionKHR *out)
{
    if (!in) return;

    out->rectangleCount = in->rectangleCount;
    out->pRectangles = (const VkRectLayerKHR *)UlongToPtr(in->pRectangles);
}

static inline const VkPresentRegionKHR *convert_VkPresentRegionKHR_array_win32_to_host(struct conversion_context *ctx, const VkPresentRegionKHR32 *in, uint32_t count)
{
    VkPresentRegionKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPresentRegionKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR32 *in, VkPresentInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores);
    out->swapchainCount = in->swapchainCount;
    out->pSwapchains = (const VkSwapchainKHR *)UlongToPtr(in->pSwapchains);
    out->pImageIndices = (const uint32_t *)UlongToPtr(in->pImageIndices);
    out->pResults = (VkResult *)UlongToPtr(in->pResults);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            VkPresentRegionsKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentRegionsKHR32 *in_ext = (const VkPresentRegionsKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pRegions = convert_VkPresentRegionKHR_array_win32_to_host(ctx, (const VkPresentRegionKHR32 *)UlongToPtr(in_ext->pRegions), in_ext->swapchainCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            VkDeviceGroupPresentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupPresentInfoKHR32 *in_ext = (const VkDeviceGroupPresentInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pDeviceMasks = (const uint32_t *)UlongToPtr(in_ext->pDeviceMasks);
            out_ext->mode = in_ext->mode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
            VkPresentIdKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentIdKHR32 *in_ext = (const VkPresentIdKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentIds = (const uint64_t *)UlongToPtr(in_ext->pPresentIds);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = (const VkImage *)UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = (const VkBuffer *)UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = (const void *)UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
        {
            VkSwapchainPresentFenceInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentFenceInfoEXT32 *in_ext = (const VkSwapchainPresentFenceInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pFences = (const VkFence *)UlongToPtr(in_ext->pFences);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
        {
            VkSwapchainPresentModeInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentModeInfoEXT32 *in_ext = (const VkSwapchainPresentModeInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentModes = (const VkPresentModeKHR *)UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkDeviceMemory *convert_VkDeviceMemory_array_win64_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
{
    VkDeviceMemory *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_device_memory_from_handle(in[i])->memory;
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkDeviceMemory *convert_VkDeviceMemory_array_win32_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
{
    VkDeviceMemory *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_device_memory_from_handle(in[i])->memory;
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo *in, VkSubmitInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = in->pWaitSemaphores;
    out->pWaitDstStageMask = in->pWaitDstStageMask;
    out->commandBufferCount = in->commandBufferCount;
    out->pCommandBuffers = in->pCommandBuffers;
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = in->pSignalSemaphores;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSubmitInfo *in_ext = (const VkDeviceGroupSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreCount = in_ext->waitSemaphoreCount;
            out_ext->pWaitSemaphoreDeviceIndices = in_ext->pWaitSemaphoreDeviceIndices;
            out_ext->commandBufferCount = in_ext->commandBufferCount;
            out_ext->pCommandBufferDeviceMasks = in_ext->pCommandBufferDeviceMasks;
            out_ext->signalSemaphoreCount = in_ext->signalSemaphoreCount;
            out_ext->pSignalSemaphoreDeviceIndices = in_ext->pSignalSemaphoreDeviceIndices;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            VkProtectedSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkProtectedSubmitInfo *in_ext = (const VkProtectedSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->protectedSubmit = in_ext->protectedSubmit;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo *in_ext = (const VkTimelineSemaphoreSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = in_ext->pImages;
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = in_ext->pBuffers;
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = in_ext->pTag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, VkSubmitInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores);
    out->pWaitDstStageMask = (const VkPipelineStageFlags *)UlongToPtr(in->pWaitDstStageMask);
    out->commandBufferCount = in->commandBufferCount;
    out->pCommandBuffers = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(in->pCommandBuffers), in->commandBufferCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSubmitInfo32 *in_ext = (const VkDeviceGroupSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreCount = in_ext->waitSemaphoreCount;
            out_ext->pWaitSemaphoreDeviceIndices = (const uint32_t *)UlongToPtr(in_ext->pWaitSemaphoreDeviceIndices);
            out_ext->commandBufferCount = in_ext->commandBufferCount;
            out_ext->pCommandBufferDeviceMasks = (const uint32_t *)UlongToPtr(in_ext->pCommandBufferDeviceMasks);
            out_ext->signalSemaphoreCount = in_ext->signalSemaphoreCount;
            out_ext->pSignalSemaphoreDeviceIndices = (const uint32_t *)UlongToPtr(in_ext->pSignalSemaphoreDeviceIndices);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            VkProtectedSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkProtectedSubmitInfo32 *in_ext = (const VkProtectedSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->protectedSubmit = in_ext->protectedSubmit;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo32 *in_ext = (const VkTimelineSemaphoreSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = (const uint64_t *)UlongToPtr(in_ext->pWaitSemaphoreValues);
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = (const uint64_t *)UlongToPtr(in_ext->pSignalSemaphoreValues);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR32 *in_ext = (const VkPerformanceQuerySubmitInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = (const VkImage *)UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = (const VkBuffer *)UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = (const void *)UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV32 *in_ext = (const VkLatencySubmissionPresentIdNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

void copy_VkSubmitInfo(struct conversion_context *ctx, const VkSubmitInfo *in, VkSubmitInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    MEMDUP(ctx, out->pWaitSemaphores, in->pWaitSemaphores, in->waitSemaphoreCount);
    MEMDUP(ctx, out->pWaitDstStageMask, in->pWaitDstStageMask, in->waitSemaphoreCount);
    out->commandBufferCount = in->commandBufferCount;
    MEMDUP(ctx, out->pCommandBuffers, in->pCommandBuffers, in->commandBufferCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    MEMDUP(ctx, out->pSignalSemaphores, in->pSignalSemaphores, in->signalSemaphoreCount);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSubmitInfo *in_ext = (const VkDeviceGroupSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreCount = in_ext->waitSemaphoreCount;
            MEMDUP(ctx, out_ext->pWaitSemaphoreDeviceIndices, in_ext->pWaitSemaphoreDeviceIndices, in_ext->waitSemaphoreCount);
            out_ext->commandBufferCount = in_ext->commandBufferCount;
            MEMDUP(ctx, out_ext->pCommandBufferDeviceMasks, in_ext->pCommandBufferDeviceMasks, in_ext->commandBufferCount);
            out_ext->signalSemaphoreCount = in_ext->signalSemaphoreCount;
            MEMDUP(ctx, out_ext->pSignalSemaphoreDeviceIndices, in_ext->pSignalSemaphoreDeviceIndices, in_ext->signalSemaphoreCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            VkProtectedSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkProtectedSubmitInfo *in_ext = (const VkProtectedSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->protectedSubmit = in_ext->protectedSubmit;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo *in_ext = (const VkTimelineSemaphoreSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            MEMDUP(ctx, out_ext->pWaitSemaphoreValues, in_ext->pWaitSemaphoreValues, in_ext->waitSemaphoreValueCount);
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            MEMDUP(ctx, out_ext->pSignalSemaphoreValues, in_ext->pSignalSemaphoreValues, in_ext->signalSemaphoreValueCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            MEMDUP(ctx, out_ext->pImages, in_ext->pImages, in_ext->imageCount);
            out_ext->bufferCount = in_ext->bufferCount;
            MEMDUP(ctx, out_ext->pBuffers, in_ext->pBuffers, in_ext->bufferCount);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            MEMDUP(ctx, out_ext->pTag, in_ext->pTag, in_ext->tagSize);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkSubmitInfo *convert_VkSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo *in, uint32_t count)
{
    VkSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkSubmitInfo *convert_VkSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, uint32_t count)
{
    VkSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->value = in->value;
    out->stageMask = in->stageMask;
    out->deviceIndex = in->deviceIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, uint32_t count)
{
    VkSemaphoreSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(const VkCommandBufferSubmitInfo32 *in, VkCommandBufferSubmitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->commandBuffer = (VkCommandBuffer)UlongToPtr(in->commandBuffer);
    out->deviceMask = in->deviceMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, uint32_t count)
{
    VkCommandBufferSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkSubmitInfo2_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, VkSubmitInfo2 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
    out->pWaitSemaphoreInfos = in->pWaitSemaphoreInfos;
    out->commandBufferInfoCount = in->commandBufferInfoCount;
    out->pCommandBufferInfos = in->pCommandBufferInfos;
    out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
    out->pSignalSemaphoreInfos = in->pSignalSemaphoreInfos;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = in_ext->pImages;
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = in_ext->pBuffers;
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = in_ext->pTag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}
#endif /* _WIN64 */

static inline void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, VkSubmitInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pWaitSemaphoreInfos), in->waitSemaphoreInfoCount);
    out->commandBufferInfoCount = in->commandBufferInfoCount;
    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkCommandBufferSubmitInfo32 *)UlongToPtr(in->pCommandBufferInfos), in->commandBufferInfoCount);
    out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pSignalSemaphoreInfos), in->signalSemaphoreInfoCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR32 *in_ext = (const VkPerformanceQuerySubmitInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = (const VkImage *)UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = (const VkBuffer *)UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = (const void *)UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV32 *in_ext = (const VkLatencySubmissionPresentIdNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

void copy_VkSubmitInfo2(struct conversion_context *ctx, const VkSubmitInfo2 *in, VkSubmitInfo2 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
    MEMDUP(ctx, out->pWaitSemaphoreInfos, in->pWaitSemaphoreInfos, in->waitSemaphoreInfoCount);
    out->commandBufferInfoCount = in->commandBufferInfoCount;
    MEMDUP(ctx, out->pCommandBufferInfos, in->pCommandBufferInfos, in->commandBufferInfoCount);
    out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
    MEMDUP(ctx, out->pSignalSemaphoreInfos, in->pSignalSemaphoreInfos, in->signalSemaphoreInfoCount);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            break;
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            MEMDUP(ctx, out_ext->pImages, in_ext->pImages, in_ext->imageCount);
            out_ext->bufferCount = in_ext->bufferCount;
            MEMDUP(ctx, out_ext->pBuffers, in_ext->pBuffers, in_ext->bufferCount);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            MEMDUP(ctx, out_ext->pTag, in_ext->pTag, in_ext->tagSize);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

#ifdef _WIN64
static inline const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, uint32_t count)
{
    VkSubmitInfo2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo2_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, uint32_t count)
{
    VkSubmitInfo2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo2_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkReleaseSwapchainImagesInfoEXT_win64_to_host(const VkReleaseSwapchainImagesInfoEXT *in, VkReleaseSwapchainImagesInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->swapchain = in->swapchain ? wine_swapchain_from_handle(in->swapchain)->swapchain : VK_NULL_HANDLE;
    out->imageIndexCount = in->imageIndexCount;
    out->pImageIndices = in->pImageIndices;
}
#endif /* _WIN64 */

static inline void convert_VkReleaseSwapchainImagesInfoEXT_win32_to_host(const VkReleaseSwapchainImagesInfoEXT32 *in, VkReleaseSwapchainImagesInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->swapchain = in->swapchain ? wine_swapchain_from_handle(in->swapchain)->swapchain : VK_NULL_HANDLE;
    out->imageIndexCount = in->imageIndexCount;
    out->pImageIndices = (const uint32_t *)UlongToPtr(in->pImageIndices);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline void convert_VkDebugUtilsObjectNameInfoEXT_win64_to_host(const VkDebugUtilsObjectNameInfoEXT *in, VkDebugUtilsObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->pObjectName = in->pObjectName;
}
#endif /* _WIN64 */

static inline void convert_VkDebugUtilsObjectNameInfoEXT_win32_to_host(const VkDebugUtilsObjectNameInfoEXT32 *in, VkDebugUtilsObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->pObjectName = (const char *)UlongToPtr(in->pObjectName);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline void convert_VkDebugUtilsObjectTagInfoEXT_win64_to_host(const VkDebugUtilsObjectTagInfoEXT *in, VkDebugUtilsObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = in->pTag;
}
#endif /* _WIN64 */

static inline void convert_VkDebugUtilsObjectTagInfoEXT_win32_to_host(const VkDebugUtilsObjectTagInfoEXT32 *in, VkDebugUtilsObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = (const void *)UlongToPtr(in->pTag);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static inline const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
{
    VkSwapchainKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_swapchain_from_handle(in[i])->swapchain;
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkSwapchainKHR *convert_VkSwapchainKHR_array_win32_to_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
{
    VkSwapchainKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = wine_swapchain_from_handle(in[i])->swapchain;
    }

    return out;
}

static inline void convert_VkHdrMetadataEXT_win32_to_host(const VkHdrMetadataEXT32 *in, VkHdrMetadataEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->displayPrimaryRed = in->displayPrimaryRed;
    out->displayPrimaryGreen = in->displayPrimaryGreen;
    out->displayPrimaryBlue = in->displayPrimaryBlue;
    out->whitePoint = in->whitePoint;
    out->maxLuminance = in->maxLuminance;
    out->minLuminance = in->minLuminance;
    out->maxContentLightLevel = in->maxContentLightLevel;
    out->maxFrameAverageLightLevel = in->maxFrameAverageLightLevel;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkHdrMetadataEXT *convert_VkHdrMetadataEXT_array_win32_to_host(struct conversion_context *ctx, const VkHdrMetadataEXT32 *in, uint32_t count)
{
    VkHdrMetadataEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkHdrMetadataEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSetLatencyMarkerInfoNV_win32_to_host(const VkSetLatencyMarkerInfoNV32 *in, VkSetLatencyMarkerInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->presentID = in->presentID;
    out->marker = in->marker;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkLatencySleepModeInfoNV_win32_to_host(const VkLatencySleepModeInfoNV32 *in, VkLatencySleepModeInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->lowLatencyMode = in->lowLatencyMode;
    out->lowLatencyBoost = in->lowLatencyBoost;
    out->minimumIntervalUs = in->minimumIntervalUs;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkSemaphoreSignalInfo_win32_to_unwrapped_host(const VkSemaphoreSignalInfo32 *in, VkSemaphoreSignalInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->value = in->value;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkDebugUtilsLabelEXT *convert_VkDebugUtilsLabelEXT_array_win32_to_host(struct conversion_context *ctx, const VkDebugUtilsLabelEXT32 *in, uint32_t count)
{
    VkDebugUtilsLabelEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDebugUtilsLabelEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline const VkDebugUtilsObjectNameInfoEXT *convert_VkDebugUtilsObjectNameInfoEXT_array_win64_to_host(struct conversion_context *ctx, const VkDebugUtilsObjectNameInfoEXT *in, uint32_t count)
{
    VkDebugUtilsObjectNameInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDebugUtilsObjectNameInfoEXT_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static inline const VkDebugUtilsObjectNameInfoEXT *convert_VkDebugUtilsObjectNameInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDebugUtilsObjectNameInfoEXT32 *in, uint32_t count)
{
    VkDebugUtilsObjectNameInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDebugUtilsObjectNameInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static inline void convert_VkDebugUtilsMessengerCallbackDataEXT_win64_to_host(struct conversion_context *ctx, const VkDebugUtilsMessengerCallbackDataEXT *in, VkDebugUtilsMessengerCallbackDataEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->pMessageIdName = in->pMessageIdName;
    out->messageIdNumber = in->messageIdNumber;
    out->pMessage = in->pMessage;
    out->queueLabelCount = in->queueLabelCount;
    out->pQueueLabels = in->pQueueLabels;
    out->cmdBufLabelCount = in->cmdBufLabelCount;
    out->pCmdBufLabels = in->pCmdBufLabels;
    out->objectCount = in->objectCount;
    out->pObjects = convert_VkDebugUtilsObjectNameInfoEXT_array_win64_to_host(ctx, in->pObjects, in->objectCount);
}
#endif /* _WIN64 */

static inline void convert_VkDebugUtilsMessengerCallbackDataEXT_win32_to_host(struct conversion_context *ctx, const VkDebugUtilsMessengerCallbackDataEXT32 *in, VkDebugUtilsMessengerCallbackDataEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pMessageIdName = (const char *)UlongToPtr(in->pMessageIdName);
    out->messageIdNumber = in->messageIdNumber;
    out->pMessage = (const char *)UlongToPtr(in->pMessage);
    out->queueLabelCount = in->queueLabelCount;
    out->pQueueLabels = convert_VkDebugUtilsLabelEXT_array_win32_to_host(ctx, (const VkDebugUtilsLabelEXT32 *)UlongToPtr(in->pQueueLabels), in->queueLabelCount);
    out->cmdBufLabelCount = in->cmdBufLabelCount;
    out->pCmdBufLabels = convert_VkDebugUtilsLabelEXT_array_win32_to_host(ctx, (const VkDebugUtilsLabelEXT32 *)UlongToPtr(in->pCmdBufLabels), in->cmdBufLabelCount);
    out->objectCount = in->objectCount;
    out->pObjects = convert_VkDebugUtilsObjectNameInfoEXT_array_win32_to_host(ctx, (const VkDebugUtilsObjectNameInfoEXT32 *)UlongToPtr(in->pObjects), in->objectCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
        {
            VkDeviceAddressBindingCallbackDataEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceAddressBindingCallbackDataEXT32 *in_ext = (const VkDeviceAddressBindingCallbackDataEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->baseAddress = in_ext->baseAddress;
            out_ext->size = in_ext->size;
            out_ext->bindingType = in_ext->bindingType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            if ((in_header->sType >> 16) == 0x7ead)
            {
                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
                memcpy(out_ext, in_header, 32);
                out_ext->pNext = NULL;
                out_header->pNext = (void *)out_ext;
                out_header = (void *)out_ext;
            }
            else
            {
                FIXME("Unhandled sType %u.\n", in_header->sType);
            }
            break;
        }
    }
}

static inline void convert_VkHostImageLayoutTransitionInfoEXT_win32_to_host(const VkHostImageLayoutTransitionInfoEXT32 *in, VkHostImageLayoutTransitionInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    out->oldLayout = in->oldLayout;
    out->newLayout = in->newLayout;
    out->subresourceRange = in->subresourceRange;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkHostImageLayoutTransitionInfoEXT *convert_VkHostImageLayoutTransitionInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkHostImageLayoutTransitionInfoEXT32 *in, uint32_t count)
{
    VkHostImageLayoutTransitionInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkHostImageLayoutTransitionInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkMemoryUnmapInfoKHR_win32_to_unwrapped_host(const VkMemoryUnmapInfoKHR32 *in, VkMemoryUnmapInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->memory = in->memory;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline void convert_VkCopyDescriptorSet_win32_to_host(const VkCopyDescriptorSet32 *in, VkCopyDescriptorSet *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSet = in->srcSet;
    out->srcBinding = in->srcBinding;
    out->srcArrayElement = in->srcArrayElement;
    out->dstSet = in->dstSet;
    out->dstBinding = in->dstBinding;
    out->dstArrayElement = in->dstArrayElement;
    out->descriptorCount = in->descriptorCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static inline const VkCopyDescriptorSet *convert_VkCopyDescriptorSet_array_win32_to_host(struct conversion_context *ctx, const VkCopyDescriptorSet32 *in, uint32_t count)
{
    VkCopyDescriptorSet *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCopyDescriptorSet_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static inline void convert_VkSemaphoreWaitInfo_win32_to_unwrapped_host(const VkSemaphoreWaitInfo32 *in, VkSemaphoreWaitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->semaphoreCount = in->semaphoreCount;
    out->pSemaphores = (const VkSemaphore *)UlongToPtr(in->pSemaphores);
    out->pValues = (const uint64_t *)UlongToPtr(in->pValues);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquireNextImage2KHR(void *args)
{
    struct vkAcquireNextImage2KHR_params *params = args;
    VkAcquireNextImageInfoKHR pAcquireInfo_host;

    TRACE("%p, %p, %p\n", params->device, params->pAcquireInfo, params->pImageIndex);

    convert_VkAcquireNextImageInfoKHR_win64_to_host(params->pAcquireInfo, &pAcquireInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkAcquireNextImage2KHR(wine_device_from_handle(params->device)->device, &pAcquireInfo_host, params->pImageIndex);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquireNextImage2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAcquireInfo;
        PTR32 pImageIndex;
        VkResult result;
    } *params = args;
    VkAcquireNextImageInfoKHR pAcquireInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAcquireInfo, params->pImageIndex);

    convert_VkAcquireNextImageInfoKHR_win32_to_host((const VkAcquireNextImageInfoKHR32 *)UlongToPtr(params->pAcquireInfo), &pAcquireInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkAcquireNextImage2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pAcquireInfo_host, (uint32_t *)UlongToPtr(params->pImageIndex));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquireNextImageKHR(void *args)
{
    struct vkAcquireNextImageKHR_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->timeout), wine_dbgstr_longlong(params->semaphore), wine_dbgstr_longlong(params->fence), params->pImageIndex);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkAcquireNextImageKHR(wine_device_from_handle(params->device)->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->timeout, params->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(params->semaphore) ) : 0, params->fence, params->pImageIndex);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquireNextImageKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        VkFence DECLSPEC_ALIGN(8) fence;
        PTR32 pImageIndex;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->timeout), wine_dbgstr_longlong(params->semaphore), wine_dbgstr_longlong(params->fence), params->pImageIndex);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkAcquireNextImageKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->timeout, params->semaphore ? wine_semaphore_host_handle( wine_semaphore_from_handle(params->semaphore) ) : 0, params->fence, (uint32_t *)UlongToPtr(params->pImageIndex));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquirePerformanceConfigurationINTEL(void *args)
{
    struct vkAcquirePerformanceConfigurationINTEL_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAcquireInfo, params->pConfiguration);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkAcquirePerformanceConfigurationINTEL(wine_device_from_handle(params->device)->device, params->pAcquireInfo, params->pConfiguration);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquirePerformanceConfigurationINTEL(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAcquireInfo;
        PTR32 pConfiguration;
        VkResult result;
    } *params = args;
    VkPerformanceConfigurationAcquireInfoINTEL pAcquireInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAcquireInfo, params->pConfiguration);

    convert_VkPerformanceConfigurationAcquireInfoINTEL_win32_to_host((const VkPerformanceConfigurationAcquireInfoINTEL32 *)UlongToPtr(params->pAcquireInfo), &pAcquireInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkAcquirePerformanceConfigurationINTEL(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pAcquireInfo_host, (VkPerformanceConfigurationINTEL *)UlongToPtr(params->pConfiguration));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquireProfilingLockKHR(void *args)
{
    struct vkAcquireProfilingLockKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkAcquireProfilingLockKHR(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquireProfilingLockKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkAcquireProfilingLockInfoKHR pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkAcquireProfilingLockInfoKHR_win32_to_host((const VkAcquireProfilingLockInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkAcquireProfilingLockKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAllocateCommandBuffers(void *args)
{
    struct vkAllocateCommandBuffers_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAllocateInfo, params->pCommandBuffers);

    params->result = wine_vkAllocateCommandBuffers(params->device, params->pAllocateInfo, params->pCommandBuffers);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAllocateCommandBuffers(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocateInfo;
        PTR32 pCommandBuffers;
        VkResult result;
    } *params = args;
    VkCommandBufferAllocateInfo pAllocateInfo_host;
    VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAllocateInfo, params->pCommandBuffers);

    init_conversion_context(ctx);
    convert_VkCommandBufferAllocateInfo_win32_to_unwrapped_host((const VkCommandBufferAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (PTR32 *)UlongToPtr(params->pCommandBuffers), ((const VkCommandBufferAllocateInfo32 *)UlongToPtr(params->pAllocateInfo))->commandBufferCount);
    params->result = wine_vkAllocateCommandBuffers((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, pCommandBuffers_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAllocateDescriptorSets(void *args)
{
    struct vkAllocateDescriptorSets_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAllocateInfo, params->pDescriptorSets);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkAllocateDescriptorSets(wine_device_from_handle(params->device)->device, params->pAllocateInfo, params->pDescriptorSets);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAllocateDescriptorSets(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocateInfo;
        PTR32 pDescriptorSets;
        VkResult result;
    } *params = args;
    VkDescriptorSetAllocateInfo pAllocateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAllocateInfo, params->pDescriptorSets);

    init_conversion_context(ctx);
    convert_VkDescriptorSetAllocateInfo_win32_to_host(ctx, (const VkDescriptorSetAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkAllocateDescriptorSets(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pAllocateInfo_host, (VkDescriptorSet *)UlongToPtr(params->pDescriptorSets));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAllocateMemory(void *args)
{
    struct vkAllocateMemory_params *params = args;
    VkMemoryAllocateInfo pAllocateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);

    init_conversion_context(ctx);
    convert_VkMemoryAllocateInfo_win64_to_host(ctx, params->pAllocateInfo, &pAllocateInfo_host);
    params->result = wine_vkAllocateMemory(params->device, &pAllocateInfo_host, params->pAllocator, params->pMemory, (void *)params->pAllocateInfo);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAllocateMemory(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocateInfo;
        PTR32 pAllocator;
        PTR32 pMemory;
        VkResult result;
    } *params = args;
    VkMemoryAllocateInfo pAllocateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);

    init_conversion_context(ctx);
    convert_VkMemoryAllocateInfo_win32_to_host(ctx, (const VkMemoryAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
    params->result = wine_vkAllocateMemory((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeviceMemory *)UlongToPtr(params->pMemory), UlongToPtr(params->pAllocateInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBeginCommandBuffer(void *args)
{
    struct vkBeginCommandBuffer_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pBeginInfo);

    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkBeginCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pBeginInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBeginCommandBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBeginInfo;
        VkResult result;
    } *params = args;
    VkCommandBufferBeginInfo pBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pBeginInfo);

    init_conversion_context(ctx);
    convert_VkCommandBufferBeginInfo_win32_to_host(ctx, (const VkCommandBufferBeginInfo32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkBeginCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pBeginInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindAccelerationStructureMemoryNV(void *args)
{
    struct vkBindAccelerationStructureMemoryNV_params *params = args;
    const VkBindAccelerationStructureMemoryInfoNV *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindAccelerationStructureMemoryInfoNV_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindAccelerationStructureMemoryNV(wine_device_from_handle(params->device)->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindAccelerationStructureMemoryNV(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindAccelerationStructureMemoryInfoNV *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindAccelerationStructureMemoryInfoNV_array_win32_to_host(ctx, (const VkBindAccelerationStructureMemoryInfoNV32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindAccelerationStructureMemoryNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindBufferMemory(void *args)
{
    struct vkBindBufferMemory_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindBufferMemory(wine_device_from_handle(params->device)->device, params->buffer, wine_device_memory_from_handle(params->memory)->memory, params->memoryOffset);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindBufferMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindBufferMemory(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->buffer, wine_device_memory_from_handle(params->memory)->memory, params->memoryOffset);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindBufferMemory2(void *args)
{
    struct vkBindBufferMemory2_params *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindBufferMemory2(wine_device_from_handle(params->device)->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindBufferMemory2(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win32_to_host(ctx, (const VkBindBufferMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindBufferMemory2(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindBufferMemory2KHR(void *args)
{
    struct vkBindBufferMemory2KHR_params *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindBufferMemory2KHR(wine_device_from_handle(params->device)->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindBufferMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win32_to_host(ctx, (const VkBindBufferMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindBufferMemory2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindImageMemory(void *args)
{
    struct vkBindImageMemory_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindImageMemory(wine_device_from_handle(params->device)->device, params->image, wine_device_memory_from_handle(params->memory)->memory, params->memoryOffset);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindImageMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindImageMemory(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, wine_device_memory_from_handle(params->memory)->memory, params->memoryOffset);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindImageMemory2(void *args)
{
    struct vkBindImageMemory2_params *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindImageMemory2(wine_device_from_handle(params->device)->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindImageMemory2(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win32_to_host(ctx, (const VkBindImageMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindImageMemory2(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindImageMemory2KHR(void *args)
{
    struct vkBindImageMemory2KHR_params *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindImageMemory2KHR(wine_device_from_handle(params->device)->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindImageMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win32_to_host(ctx, (const VkBindImageMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindImageMemory2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindOpticalFlowSessionImageNV(void *args)
{
    struct vkBindOpticalFlowSessionImageNV_params *params = args;

    TRACE("%p, 0x%s, %#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->bindingPoint, wine_dbgstr_longlong(params->view), params->layout);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkBindOpticalFlowSessionImageNV(wine_device_from_handle(params->device)->device, params->session, params->bindingPoint, params->view, params->layout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindOpticalFlowSessionImageNV(void *args)
{
    struct
    {
        PTR32 device;
        VkOpticalFlowSessionNV DECLSPEC_ALIGN(8) session;
        VkOpticalFlowSessionBindingPointNV bindingPoint;
        VkImageView DECLSPEC_ALIGN(8) view;
        VkImageLayout layout;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->bindingPoint, wine_dbgstr_longlong(params->view), params->layout);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBindOpticalFlowSessionImageNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->session, params->bindingPoint, params->view, params->layout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBuildAccelerationStructuresKHR(void *args)
{
    struct vkBuildAccelerationStructuresKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %p, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos, params->ppBuildRangeInfos);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkBuildAccelerationStructuresKHR(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBuildAccelerationStructuresKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        uint32_t infoCount;
        PTR32 pInfos;
        PTR32 ppBuildRangeInfos;
        VkResult result;
    } *params = args;
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos, params->ppBuildRangeInfos);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBuildAccelerationStructuresKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->infoCount, pInfos_host, (const VkAccelerationStructureBuildRangeInfoKHR * const*)UlongToPtr(params->ppBuildRangeInfos));
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBuildMicromapsEXT(void *args)
{
    struct vkBuildMicromapsEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkBuildMicromapsEXT(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->infoCount, params->pInfos);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBuildMicromapsEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        uint32_t infoCount;
        PTR32 pInfos;
        VkResult result;
    } *params = args;
    const VkMicromapBuildInfoEXT *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pInfos_host = convert_VkMicromapBuildInfoEXT_array_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pInfos), params->infoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkBuildMicromapsEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->infoCount, pInfos_host);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkCmdBeginConditionalRenderingEXT(void *args)
{
    struct vkCmdBeginConditionalRenderingEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginConditionalRenderingEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pConditionalRenderingBegin);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginConditionalRenderingEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pConditionalRenderingBegin;
    } *params = args;
    VkConditionalRenderingBeginInfoEXT pConditionalRenderingBegin_host;

    convert_VkConditionalRenderingBeginInfoEXT_win32_to_host((const VkConditionalRenderingBeginInfoEXT32 *)UlongToPtr(params->pConditionalRenderingBegin), &pConditionalRenderingBegin_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginConditionalRenderingEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pConditionalRenderingBegin_host);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginDebugUtilsLabelEXT(void *args)
{
    struct vkCmdBeginDebugUtilsLabelEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pLabelInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pLabelInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginQuery(void *args)
{
    struct vkCmdBeginQuery_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginQuery(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->queryPool, params->query, params->flags);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginQuery(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
        VkQueryControlFlags flags;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginQuery(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->queryPool, params->query, params->flags);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginQueryIndexedEXT(void *args)
{
    struct vkCmdBeginQueryIndexedEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginQueryIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->queryPool, params->query, params->flags, params->index);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginQueryIndexedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
        VkQueryControlFlags flags;
        uint32_t index;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginQueryIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->queryPool, params->query, params->flags, params->index);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderPass(void *args)
{
    struct vkCmdBeginRenderPass_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginRenderPass(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRenderPassBegin, params->contents);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderPass(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderPassBegin;
        VkSubpassContents contents;
    } *params = args;
    VkRenderPassBeginInfo pRenderPassBegin_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginRenderPass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRenderPassBegin_host, params->contents);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderPass2(void *args)
{
    struct vkCmdBeginRenderPass2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginRenderPass2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderPass2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderPassBegin;
        PTR32 pSubpassBeginInfo;
    } *params = args;
    VkRenderPassBeginInfo pRenderPassBegin_host;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginRenderPass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderPass2KHR(void *args)
{
    struct vkCmdBeginRenderPass2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginRenderPass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderPass2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderPassBegin;
        PTR32 pSubpassBeginInfo;
    } *params = args;
    VkRenderPassBeginInfo pRenderPassBegin_host;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginRenderPass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRendering(void *args)
{
    struct vkCmdBeginRendering_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginRendering(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRenderingInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRendering(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderingInfo;
    } *params = args;
    VkRenderingInfo pRenderingInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginRendering(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRenderingInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderingKHR(void *args)
{
    struct vkCmdBeginRenderingKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginRenderingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRenderingInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderingInfo;
    } *params = args;
    VkRenderingInfo pRenderingInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginRenderingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRenderingInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginTransformFeedbackEXT(void *args)
{
    struct vkCmdBeginTransformFeedbackEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBeginTransformFeedbackEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginTransformFeedbackEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstCounterBuffer;
        uint32_t counterBufferCount;
        PTR32 pCounterBuffers;
        PTR32 pCounterBufferOffsets;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBeginTransformFeedbackEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(void *args)
{
    struct vkCmdBindDescriptorBufferEmbeddedSamplersEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->layout, params->set);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->layout, params->set);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorBuffersEXT(void *args)
{
    struct vkCmdBindDescriptorBuffersEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindDescriptorBuffersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->bufferCount, params->pBindingInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorBuffersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t bufferCount;
        PTR32 pBindingInfos;
    } *params = args;
    const VkDescriptorBufferBindingInfoEXT *pBindingInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pBindingInfos_host = convert_VkDescriptorBufferBindingInfoEXT_array_win32_to_host(ctx, (const VkDescriptorBufferBindingInfoEXT32 *)UlongToPtr(params->pBindingInfos), params->bufferCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindDescriptorBuffersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->bufferCount, pBindingInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorSets(void *args)
{
    struct vkCmdBindDescriptorSets_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindDescriptorSets(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, params->pDescriptorSets, params->dynamicOffsetCount, params->pDynamicOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorSets(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t firstSet;
        uint32_t descriptorSetCount;
        PTR32 pDescriptorSets;
        uint32_t dynamicOffsetCount;
        PTR32 pDynamicOffsets;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindDescriptorSets(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets), params->dynamicOffsetCount, (const uint32_t *)UlongToPtr(params->pDynamicOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdBindIndexBuffer(void *args)
{
    struct vkCmdBindIndexBuffer_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindIndexBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->indexType);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindIndexBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkIndexType indexType;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindIndexBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->indexType);
}

#ifdef _WIN64
static void thunk64_vkCmdBindIndexBuffer2KHR(void *args)
{
    struct vkCmdBindIndexBuffer2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindIndexBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->size, params->indexType);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindIndexBuffer2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        VkIndexType indexType;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindIndexBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->size, params->indexType);
}

#ifdef _WIN64
static void thunk64_vkCmdBindInvocationMaskHUAWEI(void *args)
{
    struct vkCmdBindInvocationMaskHUAWEI_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindInvocationMaskHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->imageView, params->imageLayout);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindInvocationMaskHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        VkImageLayout imageLayout;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindInvocationMaskHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->imageView, params->imageLayout);
}

#ifdef _WIN64
static void thunk64_vkCmdBindPipeline(void *args)
{
    struct vkCmdBindPipeline_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindPipeline(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->pipeline);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindPipeline(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindPipeline(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->pipeline);
}

#ifdef _WIN64
static void thunk64_vkCmdBindPipelineShaderGroupNV(void *args)
{
    struct vkCmdBindPipelineShaderGroupNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindPipelineShaderGroupNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindPipelineShaderGroupNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t groupIndex;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindPipelineShaderGroupNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
}

#ifdef _WIN64
static void thunk64_vkCmdBindShadersEXT(void *args)
{
    struct vkCmdBindShadersEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindShadersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stageCount, params->pStages, params->pShaders);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindShadersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t stageCount;
        PTR32 pStages;
        PTR32 pShaders;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindShadersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stageCount, (const VkShaderStageFlagBits *)UlongToPtr(params->pStages), (const VkShaderEXT *)UlongToPtr(params->pShaders));
}

#ifdef _WIN64
static void thunk64_vkCmdBindShadingRateImageNV(void *args)
{
    struct vkCmdBindShadingRateImageNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindShadingRateImageNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->imageView, params->imageLayout);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindShadingRateImageNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        VkImageLayout imageLayout;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindShadingRateImageNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->imageView, params->imageLayout);
}

#ifdef _WIN64
static void thunk64_vkCmdBindTransformFeedbackBuffersEXT(void *args)
{
    struct vkCmdBindTransformFeedbackBuffersEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindTransformFeedbackBuffersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindTransformFeedbackBuffersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
        PTR32 pSizes;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindTransformFeedbackBuffersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes));
}

#ifdef _WIN64
static void thunk64_vkCmdBindVertexBuffers(void *args)
{
    struct vkCmdBindVertexBuffers_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindVertexBuffers(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindVertexBuffers(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindVertexBuffers(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdBindVertexBuffers2(void *args)
{
    struct vkCmdBindVertexBuffers2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindVertexBuffers2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindVertexBuffers2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
        PTR32 pSizes;
        PTR32 pStrides;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindVertexBuffers2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
}

#ifdef _WIN64
static void thunk64_vkCmdBindVertexBuffers2EXT(void *args)
{
    struct vkCmdBindVertexBuffers2EXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBindVertexBuffers2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindVertexBuffers2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
        PTR32 pSizes;
        PTR32 pStrides;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBindVertexBuffers2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
}

#ifdef _WIN64
static void thunk64_vkCmdBlitImage(void *args)
{
    struct vkCmdBlitImage_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBlitImage(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions, params->filter);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBlitImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
        VkFilter filter;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBlitImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageBlit *)UlongToPtr(params->pRegions), params->filter);
}

#ifdef _WIN64
static void thunk64_vkCmdBlitImage2(void *args)
{
    struct vkCmdBlitImage2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBlitImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pBlitImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBlitImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBlitImageInfo;
    } *params = args;
    VkBlitImageInfo2 pBlitImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBlitImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pBlitImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBlitImage2KHR(void *args)
{
    struct vkCmdBlitImage2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBlitImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pBlitImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBlitImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBlitImageInfo;
    } *params = args;
    VkBlitImageInfo2 pBlitImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBlitImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pBlitImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildAccelerationStructureNV(void *args)
{
    struct vkCmdBuildAccelerationStructureNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBuildAccelerationStructureNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
        VkBuffer DECLSPEC_ALIGN(8) instanceData;
        VkDeviceSize DECLSPEC_ALIGN(8) instanceOffset;
        VkBool32 update;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) dst;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) src;
        VkBuffer DECLSPEC_ALIGN(8) scratch;
        VkDeviceSize DECLSPEC_ALIGN(8) scratchOffset;
    } *params = args;
    VkAccelerationStructureInfoNV pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkAccelerationStructureInfoNV_win32_to_host(ctx, (const VkAccelerationStructureInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBuildAccelerationStructureNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildAccelerationStructuresIndirectKHR(void *args)
{
    struct vkCmdBuildAccelerationStructuresIndirectKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBuildAccelerationStructuresIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->infoCount, params->pInfos, params->pIndirectDeviceAddresses, params->pIndirectStrides, params->ppMaxPrimitiveCounts);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildAccelerationStructuresIndirectKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
        PTR32 pIndirectDeviceAddresses;
        PTR32 pIndirectStrides;
        PTR32 ppMaxPrimitiveCounts;
    } *params = args;
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBuildAccelerationStructuresIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->infoCount, pInfos_host, (const VkDeviceAddress *)UlongToPtr(params->pIndirectDeviceAddresses), (const uint32_t *)UlongToPtr(params->pIndirectStrides), (const uint32_t * const*)UlongToPtr(params->ppMaxPrimitiveCounts));
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildAccelerationStructuresKHR(void *args)
{
    struct vkCmdBuildAccelerationStructuresKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBuildAccelerationStructuresKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildAccelerationStructuresKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
        PTR32 ppBuildRangeInfos;
    } *params = args;
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBuildAccelerationStructuresKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->infoCount, pInfos_host, (const VkAccelerationStructureBuildRangeInfoKHR * const*)UlongToPtr(params->ppBuildRangeInfos));
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildMicromapsEXT(void *args)
{
    struct vkCmdBuildMicromapsEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdBuildMicromapsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->infoCount, params->pInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildMicromapsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
    } *params = args;
    const VkMicromapBuildInfoEXT *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkMicromapBuildInfoEXT_array_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pInfos), params->infoCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdBuildMicromapsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->infoCount, pInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdClearAttachments(void *args)
{
    struct vkCmdClearAttachments_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdClearAttachments(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->attachmentCount, params->pAttachments, params->rectCount, params->pRects);
}
#endif /* _WIN64 */

static void thunk32_vkCmdClearAttachments(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t attachmentCount;
        PTR32 pAttachments;
        uint32_t rectCount;
        PTR32 pRects;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdClearAttachments(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->attachmentCount, (const VkClearAttachment *)UlongToPtr(params->pAttachments), params->rectCount, (const VkClearRect *)UlongToPtr(params->pRects));
}

#ifdef _WIN64
static void thunk64_vkCmdClearColorImage(void *args)
{
    struct vkCmdClearColorImage_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdClearColorImage(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->image, params->imageLayout, params->pColor, params->rangeCount, params->pRanges);
}
#endif /* _WIN64 */

static void thunk32_vkCmdClearColorImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) image;
        VkImageLayout imageLayout;
        PTR32 pColor;
        uint32_t rangeCount;
        PTR32 pRanges;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdClearColorImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->image, params->imageLayout, (const VkClearColorValue *)UlongToPtr(params->pColor), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
}

#ifdef _WIN64
static void thunk64_vkCmdClearDepthStencilImage(void *args)
{
    struct vkCmdClearDepthStencilImage_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdClearDepthStencilImage(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->image, params->imageLayout, params->pDepthStencil, params->rangeCount, params->pRanges);
}
#endif /* _WIN64 */

static void thunk32_vkCmdClearDepthStencilImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) image;
        VkImageLayout imageLayout;
        PTR32 pDepthStencil;
        uint32_t rangeCount;
        PTR32 pRanges;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdClearDepthStencilImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->image, params->imageLayout, (const VkClearDepthStencilValue *)UlongToPtr(params->pDepthStencil), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
}

#ifdef _WIN64
static void thunk64_vkCmdCopyAccelerationStructureKHR(void *args)
{
    struct vkCmdCopyAccelerationStructureKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyAccelerationStructureKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyAccelerationStructureInfoKHR pInfo_host;

    convert_VkCopyAccelerationStructureInfoKHR_win32_to_host((const VkCopyAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyAccelerationStructureKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyAccelerationStructureNV(void *args)
{
    struct vkCmdCopyAccelerationStructureNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyAccelerationStructureNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->dst, params->src, params->mode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) dst;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) src;
        VkCopyAccelerationStructureModeKHR mode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyAccelerationStructureNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->dst, params->src, params->mode);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct vkCmdCopyAccelerationStructureToMemoryKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyAccelerationStructureToMemoryKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyAccelerationStructureToMemoryInfoKHR pInfo_host;

    convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host((const VkCopyAccelerationStructureToMemoryInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyAccelerationStructureToMemoryKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBuffer(void *args)
{
    struct vkCmdCopyBuffer_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;
    const VkBufferCopy *pRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pRegions_host = convert_VkBufferCopy_array_win32_to_host(ctx, (const VkBufferCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, pRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBuffer2(void *args)
{
    struct vkCmdCopyBuffer2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBuffer2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferInfo;
    } *params = args;
    VkCopyBufferInfo2 pCopyBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBuffer2KHR(void *args)
{
    struct vkCmdCopyBuffer2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBuffer2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferInfo;
    } *params = args;
    VkCopyBufferInfo2 pCopyBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBufferToImage(void *args)
{
    struct vkCmdCopyBufferToImage_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyBufferToImage(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBufferToImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;
    const VkBufferImageCopy *pRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyBufferToImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, pRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBufferToImage2(void *args)
{
    struct vkCmdCopyBufferToImage2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyBufferToImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyBufferToImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBufferToImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferToImageInfo;
    } *params = args;
    VkCopyBufferToImageInfo2 pCopyBufferToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyBufferToImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyBufferToImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBufferToImage2KHR(void *args)
{
    struct vkCmdCopyBufferToImage2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyBufferToImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyBufferToImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBufferToImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferToImageInfo;
    } *params = args;
    VkCopyBufferToImageInfo2 pCopyBufferToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyBufferToImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyBufferToImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImage(void *args)
{
    struct vkCmdCopyImage_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyImage(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageCopy *)UlongToPtr(params->pRegions));
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImage2(void *args)
{
    struct vkCmdCopyImage2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageInfo;
    } *params = args;
    VkCopyImageInfo2 pCopyImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImage2KHR(void *args)
{
    struct vkCmdCopyImage2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageInfo;
    } *params = args;
    VkCopyImageInfo2 pCopyImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImageToBuffer(void *args)
{
    struct vkCmdCopyImageToBuffer_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyImageToBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImageToBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;
    const VkBufferImageCopy *pRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyImageToBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, pRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImageToBuffer2(void *args)
{
    struct vkCmdCopyImageToBuffer2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyImageToBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyImageToBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImageToBuffer2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageToBufferInfo;
    } *params = args;
    VkCopyImageToBufferInfo2 pCopyImageToBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyImageToBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyImageToBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImageToBuffer2KHR(void *args)
{
    struct vkCmdCopyImageToBuffer2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyImageToBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCopyImageToBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImageToBuffer2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageToBufferInfo;
    } *params = args;
    VkCopyImageToBufferInfo2 pCopyImageToBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyImageToBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pCopyImageToBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryIndirectNV(void *args)
{
    struct vkCmdCopyMemoryIndirectNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyMemoryIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) copyBufferAddress;
        uint32_t copyCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyMemoryIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct vkCmdCopyMemoryToAccelerationStructureKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyMemoryToAccelerationStructureKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMemoryToAccelerationStructureInfoKHR pInfo_host;

    convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host((const VkCopyMemoryToAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyMemoryToAccelerationStructureKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryToImageIndirectNV(void *args)
{
    struct vkCmdCopyMemoryToImageIndirectNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyMemoryToImageIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, params->pImageSubresources);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryToImageIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) copyBufferAddress;
        uint32_t copyCount;
        uint32_t stride;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        PTR32 pImageSubresources;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyMemoryToImageIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, (const VkImageSubresourceLayers *)UlongToPtr(params->pImageSubresources));
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryToMicromapEXT(void *args)
{
    struct vkCmdCopyMemoryToMicromapEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyMemoryToMicromapEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryToMicromapEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMemoryToMicromapInfoEXT pInfo_host;

    convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host((const VkCopyMemoryToMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyMemoryToMicromapEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMicromapEXT(void *args)
{
    struct vkCmdCopyMicromapEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyMicromapEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMicromapEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMicromapInfoEXT pInfo_host;

    convert_VkCopyMicromapInfoEXT_win32_to_host((const VkCopyMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyMicromapEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMicromapToMemoryEXT(void *args)
{
    struct vkCmdCopyMicromapToMemoryEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyMicromapToMemoryEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMicromapToMemoryEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMicromapToMemoryInfoEXT pInfo_host;

    convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host((const VkCopyMicromapToMemoryInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyMicromapToMemoryEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyQueryPoolResults(void *args)
{
    struct vkCmdCopyQueryPoolResults_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCopyQueryPoolResults(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyQueryPoolResults(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) stride;
        VkQueryResultFlags flags;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCopyQueryPoolResults(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
}

#ifdef _WIN64
static void thunk64_vkCmdCuLaunchKernelNVX(void *args)
{
    struct vkCmdCuLaunchKernelNVX_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdCuLaunchKernelNVX(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pLaunchInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCuLaunchKernelNVX(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLaunchInfo;
    } *params = args;
    VkCuLaunchInfoNVX pLaunchInfo_host;

    convert_VkCuLaunchInfoNVX_win32_to_host((const VkCuLaunchInfoNVX32 *)UlongToPtr(params->pLaunchInfo), &pLaunchInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdCuLaunchKernelNVX(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pLaunchInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDebugMarkerBeginEXT(void *args)
{
    struct vkCmdDebugMarkerBeginEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDebugMarkerBeginEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pMarkerInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDebugMarkerBeginEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
    } *params = args;
    VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;

    convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDebugMarkerBeginEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pMarkerInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDebugMarkerEndEXT(void *args)
{
    struct vkCmdDebugMarkerEndEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDebugMarkerEndEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDebugMarkerEndEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDebugMarkerEndEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdDebugMarkerInsertEXT(void *args)
{
    struct vkCmdDebugMarkerInsertEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDebugMarkerInsertEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pMarkerInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDebugMarkerInsertEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
    } *params = args;
    VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;

    convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDebugMarkerInsertEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pMarkerInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDecompressMemoryIndirectCountNV(void *args)
{
    struct vkCmdDecompressMemoryIndirectCountNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDecompressMemoryIndirectCountNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDecompressMemoryIndirectCountNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectCommandsAddress;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectCommandsCountAddress;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDecompressMemoryIndirectCountNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDecompressMemoryNV(void *args)
{
    struct vkCmdDecompressMemoryNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDecompressMemoryNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->decompressRegionCount, params->pDecompressMemoryRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDecompressMemoryNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t decompressRegionCount;
        PTR32 pDecompressMemoryRegions;
    } *params = args;
    const VkDecompressMemoryRegionNV *pDecompressMemoryRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDecompressMemoryRegions_host = convert_VkDecompressMemoryRegionNV_array_win32_to_host(ctx, (const VkDecompressMemoryRegionNV32 *)UlongToPtr(params->pDecompressMemoryRegions), params->decompressRegionCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDecompressMemoryNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->decompressRegionCount, pDecompressMemoryRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatch(void *args)
{
    struct vkCmdDispatch_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDispatch(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatch(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDispatch(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchBase(void *args)
{
    struct vkCmdDispatchBase_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDispatchBase(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchBase(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t baseGroupX;
        uint32_t baseGroupY;
        uint32_t baseGroupZ;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDispatchBase(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchBaseKHR(void *args)
{
    struct vkCmdDispatchBaseKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDispatchBaseKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchBaseKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t baseGroupX;
        uint32_t baseGroupY;
        uint32_t baseGroupZ;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDispatchBaseKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchIndirect(void *args)
{
    struct vkCmdDispatchIndirect_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDispatchIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchIndirect(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDispatchIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset);
}

#ifdef _WIN64
static void thunk64_vkCmdDraw(void *args)
{
    struct vkCmdDraw_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDraw(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDraw(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t vertexCount;
        uint32_t instanceCount;
        uint32_t firstVertex;
        uint32_t firstInstance;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDraw(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawClusterHUAWEI(void *args)
{
    struct vkCmdDrawClusterHUAWEI_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawClusterHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawClusterIndirectHUAWEI(void *args)
{
    struct vkCmdDrawClusterIndirectHUAWEI_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawClusterIndirectHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexed(void *args)
{
    struct vkCmdDrawIndexed_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndexed(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexed(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t indexCount;
        uint32_t instanceCount;
        uint32_t firstIndex;
        int32_t vertexOffset;
        uint32_t firstInstance;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndexed(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirect(void *args)
{
    struct vkCmdDrawIndexedIndirect_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndexedIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirect(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndexedIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirectCount(void *args)
{
    struct vkCmdDrawIndexedIndirectCount_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndexedIndirectCount(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirectCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndexedIndirectCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirectCountAMD(void *args)
{
    struct vkCmdDrawIndexedIndirectCountAMD_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndexedIndirectCountAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirectCountAMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndexedIndirectCountAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirectCountKHR(void *args)
{
    struct vkCmdDrawIndexedIndirectCountKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndexedIndirectCountKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirectCountKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndexedIndirectCountKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirect(void *args)
{
    struct vkCmdDrawIndirect_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirect(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectByteCountEXT(void *args)
{
    struct vkCmdDrawIndirectByteCountEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndirectByteCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectByteCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t instanceCount;
        uint32_t firstInstance;
        VkBuffer DECLSPEC_ALIGN(8) counterBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) counterBufferOffset;
        uint32_t counterOffset;
        uint32_t vertexStride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndirectByteCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectCount(void *args)
{
    struct vkCmdDrawIndirectCount_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndirectCount(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndirectCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectCountAMD(void *args)
{
    struct vkCmdDrawIndirectCountAMD_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndirectCountAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectCountAMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndirectCountAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectCountKHR(void *args)
{
    struct vkCmdDrawIndirectCountKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawIndirectCountKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectCountKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawIndirectCountKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksEXT(void *args)
{
    struct vkCmdDrawMeshTasksEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMeshTasksEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMeshTasksEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectCountEXT(void *args)
{
    struct vkCmdDrawMeshTasksIndirectCountEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMeshTasksIndirectCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMeshTasksIndirectCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectCountNV(void *args)
{
    struct vkCmdDrawMeshTasksIndirectCountNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMeshTasksIndirectCountNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectCountNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMeshTasksIndirectCountNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectEXT(void *args)
{
    struct vkCmdDrawMeshTasksIndirectEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMeshTasksIndirectEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMeshTasksIndirectEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectNV(void *args)
{
    struct vkCmdDrawMeshTasksIndirectNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMeshTasksIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMeshTasksIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksNV(void *args)
{
    struct vkCmdDrawMeshTasksNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMeshTasksNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->taskCount, params->firstTask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t taskCount;
        uint32_t firstTask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMeshTasksNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->taskCount, params->firstTask);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMultiEXT(void *args)
{
    struct vkCmdDrawMultiEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMultiEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->drawCount, params->pVertexInfo, params->instanceCount, params->firstInstance, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMultiEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t drawCount;
        PTR32 pVertexInfo;
        uint32_t instanceCount;
        uint32_t firstInstance;
        uint32_t stride;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMultiEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->drawCount, (const VkMultiDrawInfoEXT *)UlongToPtr(params->pVertexInfo), params->instanceCount, params->firstInstance, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMultiIndexedEXT(void *args)
{
    struct vkCmdDrawMultiIndexedEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawMultiIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->drawCount, params->pIndexInfo, params->instanceCount, params->firstInstance, params->stride, params->pVertexOffset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMultiIndexedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t drawCount;
        PTR32 pIndexInfo;
        uint32_t instanceCount;
        uint32_t firstInstance;
        uint32_t stride;
        PTR32 pVertexOffset;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawMultiIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->drawCount, (const VkMultiDrawIndexedInfoEXT *)UlongToPtr(params->pIndexInfo), params->instanceCount, params->firstInstance, params->stride, (const int32_t *)UlongToPtr(params->pVertexOffset));
}

#ifdef _WIN64
static void thunk64_vkCmdEndConditionalRenderingEXT(void *args)
{
    struct vkCmdEndConditionalRenderingEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndConditionalRenderingEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndConditionalRenderingEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndConditionalRenderingEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndDebugUtilsLabelEXT(void *args)
{
    struct vkCmdEndDebugUtilsLabelEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndQuery(void *args)
{
    struct vkCmdEndQuery_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndQuery(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndQuery(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndQuery(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->queryPool, params->query);
}

#ifdef _WIN64
static void thunk64_vkCmdEndQueryIndexedEXT(void *args)
{
    struct vkCmdEndQueryIndexedEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndQueryIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->queryPool, params->query, params->index);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndQueryIndexedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
        uint32_t index;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndQueryIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->queryPool, params->query, params->index);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderPass(void *args)
{
    struct vkCmdEndRenderPass_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndRenderPass(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderPass(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndRenderPass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderPass2(void *args)
{
    struct vkCmdEndRenderPass2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndRenderPass2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderPass2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndRenderPass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderPass2KHR(void *args)
{
    struct vkCmdEndRenderPass2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndRenderPass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderPass2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndRenderPass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRendering(void *args)
{
    struct vkCmdEndRendering_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndRendering(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRendering(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndRendering(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderingKHR(void *args)
{
    struct vkCmdEndRenderingKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndRenderingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndRenderingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndTransformFeedbackEXT(void *args)
{
    struct vkCmdEndTransformFeedbackEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdEndTransformFeedbackEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndTransformFeedbackEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstCounterBuffer;
        uint32_t counterBufferCount;
        PTR32 pCounterBuffers;
        PTR32 pCounterBufferOffsets;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdEndTransformFeedbackEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdExecuteCommands(void *args)
{
    struct vkCmdExecuteCommands_params *params = args;
    const VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win64_to_host(ctx, params->pCommandBuffers, params->commandBufferCount);
    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdExecuteCommands(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->commandBufferCount, pCommandBuffers_host);
    free_conversion_context(ctx);
}
#endif /* _WIN64 */

static void thunk32_vkCmdExecuteCommands(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t commandBufferCount;
        PTR32 pCommandBuffers;
    } *params = args;
    const VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->pCommandBuffers), params->commandBufferCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdExecuteCommands(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->commandBufferCount, pCommandBuffers_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdExecuteGeneratedCommandsNV(void *args)
{
    struct vkCmdExecuteGeneratedCommandsNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdExecuteGeneratedCommandsNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdExecuteGeneratedCommandsNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 isPreprocessed;
        PTR32 pGeneratedCommandsInfo;
    } *params = args;
    VkGeneratedCommandsInfoNV pGeneratedCommandsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdExecuteGeneratedCommandsNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdFillBuffer(void *args)
{
    struct vkCmdFillBuffer_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdFillBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
}
#endif /* _WIN64 */

static void thunk32_vkCmdFillBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        uint32_t data;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdFillBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
}

#ifdef _WIN64
static void thunk64_vkCmdInsertDebugUtilsLabelEXT(void *args)
{
    struct vkCmdInsertDebugUtilsLabelEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdInsertDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pLabelInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdInsertDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdInsertDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pLabelInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdNextSubpass(void *args)
{
    struct vkCmdNextSubpass_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdNextSubpass(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->contents);
}
#endif /* _WIN64 */

static void thunk32_vkCmdNextSubpass(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkSubpassContents contents;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdNextSubpass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->contents);
}

#ifdef _WIN64
static void thunk64_vkCmdNextSubpass2(void *args)
{
    struct vkCmdNextSubpass2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdNextSubpass2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdNextSubpass2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassBeginInfo;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdNextSubpass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdNextSubpass2KHR(void *args)
{
    struct vkCmdNextSubpass2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdNextSubpass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdNextSubpass2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassBeginInfo;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdNextSubpass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdOpticalFlowExecuteNV(void *args)
{
    struct vkCmdOpticalFlowExecuteNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdOpticalFlowExecuteNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->session, params->pExecuteInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdOpticalFlowExecuteNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkOpticalFlowSessionNV DECLSPEC_ALIGN(8) session;
        PTR32 pExecuteInfo;
    } *params = args;
    VkOpticalFlowExecuteInfoNV pExecuteInfo_host;

    convert_VkOpticalFlowExecuteInfoNV_win32_to_host((const VkOpticalFlowExecuteInfoNV32 *)UlongToPtr(params->pExecuteInfo), &pExecuteInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdOpticalFlowExecuteNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->session, &pExecuteInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdPipelineBarrier(void *args)
{
    struct vkCmdPipelineBarrier_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPipelineBarrier(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPipelineBarrier(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags srcStageMask;
        VkPipelineStageFlags dstStageMask;
        VkDependencyFlags dependencyFlags;
        uint32_t memoryBarrierCount;
        PTR32 pMemoryBarriers;
        uint32_t bufferMemoryBarrierCount;
        PTR32 pBufferMemoryBarriers;
        uint32_t imageMemoryBarrierCount;
        PTR32 pImageMemoryBarriers;
    } *params = args;
    const VkMemoryBarrier *pMemoryBarriers_host;
    const VkBufferMemoryBarrier *pBufferMemoryBarriers_host;
    const VkImageMemoryBarrier *pImageMemoryBarriers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
    pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
    pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPipelineBarrier(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPipelineBarrier2(void *args)
{
    struct vkCmdPipelineBarrier2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPipelineBarrier2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPipelineBarrier2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPipelineBarrier2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPipelineBarrier2KHR(void *args)
{
    struct vkCmdPipelineBarrier2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPipelineBarrier2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPipelineBarrier2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPipelineBarrier2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPreprocessGeneratedCommandsNV(void *args)
{
    struct vkCmdPreprocessGeneratedCommandsNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPreprocessGeneratedCommandsNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pGeneratedCommandsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPreprocessGeneratedCommandsNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pGeneratedCommandsInfo;
    } *params = args;
    VkGeneratedCommandsInfoNV pGeneratedCommandsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPreprocessGeneratedCommandsNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pGeneratedCommandsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushConstants(void *args)
{
    struct vkCmdPushConstants_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPushConstants(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->layout, params->stageFlags, params->offset, params->size, params->pValues);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushConstants(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        VkShaderStageFlags stageFlags;
        uint32_t offset;
        uint32_t size;
        PTR32 pValues;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPushConstants(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->layout, params->stageFlags, params->offset, params->size, (const void *)UlongToPtr(params->pValues));
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetKHR(void *args)
{
    struct vkCmdPushDescriptorSetKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPushDescriptorSetKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
        uint32_t descriptorWriteCount;
        PTR32 pDescriptorWrites;
    } *params = args;
    const VkWriteDescriptorSet *pDescriptorWrites_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPushDescriptorSetKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetWithTemplateKHR(void *args)
{
    struct vkCmdPushDescriptorSetWithTemplateKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdPushDescriptorSetWithTemplateKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetWithTemplateKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
        PTR32 pData;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdPushDescriptorSetWithTemplateKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static void thunk64_vkCmdResetEvent(void *args)
{
    struct vkCmdResetEvent_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResetEvent(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetEvent(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags stageMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResetEvent(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdResetEvent2(void *args)
{
    struct vkCmdResetEvent2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResetEvent2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetEvent2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResetEvent2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdResetEvent2KHR(void *args)
{
    struct vkCmdResetEvent2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResetEvent2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetEvent2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResetEvent2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdResetQueryPool(void *args)
{
    struct vkCmdResetQueryPool_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResetQueryPool(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->queryPool, params->firstQuery, params->queryCount);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetQueryPool(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResetQueryPool(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->queryPool, params->firstQuery, params->queryCount);
}

#ifdef _WIN64
static void thunk64_vkCmdResolveImage(void *args)
{
    struct vkCmdResolveImage_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResolveImage(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResolveImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResolveImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageResolve *)UlongToPtr(params->pRegions));
}

#ifdef _WIN64
static void thunk64_vkCmdResolveImage2(void *args)
{
    struct vkCmdResolveImage2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResolveImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pResolveImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResolveImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pResolveImageInfo;
    } *params = args;
    VkResolveImageInfo2 pResolveImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResolveImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pResolveImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdResolveImage2KHR(void *args)
{
    struct vkCmdResolveImage2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdResolveImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pResolveImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResolveImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pResolveImageInfo;
    } *params = args;
    VkResolveImageInfo2 pResolveImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdResolveImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pResolveImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetAlphaToCoverageEnableEXT(void *args)
{
    struct vkCmdSetAlphaToCoverageEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetAlphaToCoverageEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->alphaToCoverageEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetAlphaToCoverageEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 alphaToCoverageEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetAlphaToCoverageEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->alphaToCoverageEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetAlphaToOneEnableEXT(void *args)
{
    struct vkCmdSetAlphaToOneEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetAlphaToOneEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->alphaToOneEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetAlphaToOneEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 alphaToOneEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetAlphaToOneEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->alphaToOneEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetAttachmentFeedbackLoopEnableEXT(void *args)
{
    struct vkCmdSetAttachmentFeedbackLoopEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetAttachmentFeedbackLoopEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->aspectMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetAttachmentFeedbackLoopEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImageAspectFlags aspectMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetAttachmentFeedbackLoopEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->aspectMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetBlendConstants(void *args)
{
    struct vkCmdSetBlendConstants_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetBlendConstants(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->blendConstants);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetBlendConstants(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 blendConstants;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetBlendConstants(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, (const float *)UlongToPtr(params->blendConstants));
}

#ifdef _WIN64
static void thunk64_vkCmdSetCheckpointNV(void *args)
{
    struct vkCmdSetCheckpointNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCheckpointNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pCheckpointMarker);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCheckpointNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCheckpointMarker;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCheckpointNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, (const void *)UlongToPtr(params->pCheckpointMarker));
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoarseSampleOrderNV(void *args)
{
    struct vkCmdSetCoarseSampleOrderNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoarseSampleOrderNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->sampleOrderType, params->customSampleOrderCount, params->pCustomSampleOrders);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoarseSampleOrderNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCoarseSampleOrderTypeNV sampleOrderType;
        uint32_t customSampleOrderCount;
        PTR32 pCustomSampleOrders;
    } *params = args;
    const VkCoarseSampleOrderCustomNV *pCustomSampleOrders_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pCustomSampleOrders_host = convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(ctx, (const VkCoarseSampleOrderCustomNV32 *)UlongToPtr(params->pCustomSampleOrders), params->customSampleOrderCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoarseSampleOrderNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->sampleOrderType, params->customSampleOrderCount, pCustomSampleOrders_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorBlendAdvancedEXT(void *args)
{
    struct vkCmdSetColorBlendAdvancedEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetColorBlendAdvancedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendAdvanced);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorBlendAdvancedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorBlendAdvanced;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetColorBlendAdvancedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendAdvancedEXT *)UlongToPtr(params->pColorBlendAdvanced));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorBlendEnableEXT(void *args)
{
    struct vkCmdSetColorBlendEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetColorBlendEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEnables);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorBlendEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorBlendEnables;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetColorBlendEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstAttachment, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorBlendEnables));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorBlendEquationEXT(void *args)
{
    struct vkCmdSetColorBlendEquationEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetColorBlendEquationEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEquations);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorBlendEquationEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorBlendEquations;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetColorBlendEquationEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendEquationEXT *)UlongToPtr(params->pColorBlendEquations));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorWriteEnableEXT(void *args)
{
    struct vkCmdSetColorWriteEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetColorWriteEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->attachmentCount, params->pColorWriteEnables);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorWriteEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t attachmentCount;
        PTR32 pColorWriteEnables;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetColorWriteEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorWriteEnables));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorWriteMaskEXT(void *args)
{
    struct vkCmdSetColorWriteMaskEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetColorWriteMaskEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstAttachment, params->attachmentCount, params->pColorWriteMasks);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorWriteMaskEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorWriteMasks;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetColorWriteMaskEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorComponentFlags *)UlongToPtr(params->pColorWriteMasks));
}

#ifdef _WIN64
static void thunk64_vkCmdSetConservativeRasterizationModeEXT(void *args)
{
    struct vkCmdSetConservativeRasterizationModeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetConservativeRasterizationModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->conservativeRasterizationMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetConservativeRasterizationModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkConservativeRasterizationModeEXT conservativeRasterizationMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetConservativeRasterizationModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->conservativeRasterizationMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageModulationModeNV(void *args)
{
    struct vkCmdSetCoverageModulationModeNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoverageModulationModeNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->coverageModulationMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageModulationModeNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCoverageModulationModeNV coverageModulationMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoverageModulationModeNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->coverageModulationMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageModulationTableEnableNV(void *args)
{
    struct vkCmdSetCoverageModulationTableEnableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoverageModulationTableEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->coverageModulationTableEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageModulationTableEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 coverageModulationTableEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoverageModulationTableEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->coverageModulationTableEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageModulationTableNV(void *args)
{
    struct vkCmdSetCoverageModulationTableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoverageModulationTableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->coverageModulationTableCount, params->pCoverageModulationTable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageModulationTableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t coverageModulationTableCount;
        PTR32 pCoverageModulationTable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoverageModulationTableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->coverageModulationTableCount, (const float *)UlongToPtr(params->pCoverageModulationTable));
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageReductionModeNV(void *args)
{
    struct vkCmdSetCoverageReductionModeNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoverageReductionModeNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->coverageReductionMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageReductionModeNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCoverageReductionModeNV coverageReductionMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoverageReductionModeNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->coverageReductionMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageToColorEnableNV(void *args)
{
    struct vkCmdSetCoverageToColorEnableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoverageToColorEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->coverageToColorEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageToColorEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 coverageToColorEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoverageToColorEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->coverageToColorEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageToColorLocationNV(void *args)
{
    struct vkCmdSetCoverageToColorLocationNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCoverageToColorLocationNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->coverageToColorLocation);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageToColorLocationNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t coverageToColorLocation;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCoverageToColorLocationNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->coverageToColorLocation);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCullMode(void *args)
{
    struct vkCmdSetCullMode_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCullMode(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->cullMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCullMode(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCullModeFlags cullMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCullMode(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->cullMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCullModeEXT(void *args)
{
    struct vkCmdSetCullModeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetCullModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->cullMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCullModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCullModeFlags cullMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetCullModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->cullMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBias(void *args)
{
    struct vkCmdSetDepthBias_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBias(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBias(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float depthBiasConstantFactor;
        float depthBiasClamp;
        float depthBiasSlopeFactor;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBias(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBias2EXT(void *args)
{
    struct vkCmdSetDepthBias2EXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBias2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pDepthBiasInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBias2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDepthBiasInfo;
    } *params = args;
    VkDepthBiasInfoEXT pDepthBiasInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDepthBiasInfoEXT_win32_to_host(ctx, (const VkDepthBiasInfoEXT32 *)UlongToPtr(params->pDepthBiasInfo), &pDepthBiasInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBias2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pDepthBiasInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBiasEnable(void *args)
{
    struct vkCmdSetDepthBiasEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBiasEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthBiasEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBiasEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBiasEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBiasEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthBiasEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBiasEnableEXT(void *args)
{
    struct vkCmdSetDepthBiasEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBiasEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthBiasEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBiasEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBiasEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBiasEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthBiasEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBounds(void *args)
{
    struct vkCmdSetDepthBounds_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBounds(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->minDepthBounds, params->maxDepthBounds);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBounds(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float minDepthBounds;
        float maxDepthBounds;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBounds(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->minDepthBounds, params->maxDepthBounds);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBoundsTestEnable(void *args)
{
    struct vkCmdSetDepthBoundsTestEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBoundsTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthBoundsTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBoundsTestEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBoundsTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBoundsTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthBoundsTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBoundsTestEnableEXT(void *args)
{
    struct vkCmdSetDepthBoundsTestEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthBoundsTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthBoundsTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBoundsTestEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBoundsTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthBoundsTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthBoundsTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClampEnableEXT(void *args)
{
    struct vkCmdSetDepthClampEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthClampEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthClampEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClampEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthClampEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthClampEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthClampEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClipEnableEXT(void *args)
{
    struct vkCmdSetDepthClipEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthClipEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthClipEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClipEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthClipEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthClipEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthClipEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClipNegativeOneToOneEXT(void *args)
{
    struct vkCmdSetDepthClipNegativeOneToOneEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthClipNegativeOneToOneEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->negativeOneToOne);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClipNegativeOneToOneEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 negativeOneToOne;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthClipNegativeOneToOneEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->negativeOneToOne);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthCompareOp(void *args)
{
    struct vkCmdSetDepthCompareOp_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthCompareOp(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthCompareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthCompareOp(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCompareOp depthCompareOp;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthCompareOp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthCompareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthCompareOpEXT(void *args)
{
    struct vkCmdSetDepthCompareOpEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthCompareOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthCompareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthCompareOpEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCompareOp depthCompareOp;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthCompareOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthCompareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthTestEnable(void *args)
{
    struct vkCmdSetDepthTestEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthTestEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthTestEnableEXT(void *args)
{
    struct vkCmdSetDepthTestEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthTestEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthWriteEnable(void *args)
{
    struct vkCmdSetDepthWriteEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthWriteEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthWriteEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthWriteEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthWriteEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthWriteEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthWriteEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthWriteEnableEXT(void *args)
{
    struct vkCmdSetDepthWriteEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDepthWriteEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->depthWriteEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthWriteEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthWriteEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDepthWriteEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->depthWriteEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDescriptorBufferOffsetsEXT(void *args)
{
    struct vkCmdSetDescriptorBufferOffsetsEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDescriptorBufferOffsetsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, params->pBufferIndices, params->pOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDescriptorBufferOffsetsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t firstSet;
        uint32_t setCount;
        PTR32 pBufferIndices;
        PTR32 pOffsets;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDescriptorBufferOffsetsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, (const uint32_t *)UlongToPtr(params->pBufferIndices), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdSetDeviceMask(void *args)
{
    struct vkCmdSetDeviceMask_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDeviceMask(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->deviceMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDeviceMask(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t deviceMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDeviceMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->deviceMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDeviceMaskKHR(void *args)
{
    struct vkCmdSetDeviceMaskKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDeviceMaskKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->deviceMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDeviceMaskKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t deviceMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDeviceMaskKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->deviceMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDiscardRectangleEXT(void *args)
{
    struct vkCmdSetDiscardRectangleEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDiscardRectangleEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, params->pDiscardRectangles);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDiscardRectangleEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstDiscardRectangle;
        uint32_t discardRectangleCount;
        PTR32 pDiscardRectangles;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDiscardRectangleEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, (const VkRect2D *)UlongToPtr(params->pDiscardRectangles));
}

#ifdef _WIN64
static void thunk64_vkCmdSetDiscardRectangleEnableEXT(void *args)
{
    struct vkCmdSetDiscardRectangleEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDiscardRectangleEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->discardRectangleEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDiscardRectangleEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 discardRectangleEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDiscardRectangleEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->discardRectangleEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDiscardRectangleModeEXT(void *args)
{
    struct vkCmdSetDiscardRectangleModeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetDiscardRectangleModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->discardRectangleMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDiscardRectangleModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDiscardRectangleModeEXT discardRectangleMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetDiscardRectangleModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->discardRectangleMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetEvent(void *args)
{
    struct vkCmdSetEvent_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetEvent(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetEvent(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags stageMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetEvent(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetEvent2(void *args)
{
    struct vkCmdSetEvent2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetEvent2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->event, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetEvent2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetEvent2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->event, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetEvent2KHR(void *args)
{
    struct vkCmdSetEvent2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetEvent2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->event, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetEvent2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetEvent2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->event, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetExclusiveScissorEnableNV(void *args)
{
    struct vkCmdSetExclusiveScissorEnableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetExclusiveScissorEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissorEnables);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetExclusiveScissorEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstExclusiveScissor;
        uint32_t exclusiveScissorCount;
        PTR32 pExclusiveScissorEnables;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetExclusiveScissorEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkBool32 *)UlongToPtr(params->pExclusiveScissorEnables));
}

#ifdef _WIN64
static void thunk64_vkCmdSetExclusiveScissorNV(void *args)
{
    struct vkCmdSetExclusiveScissorNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetExclusiveScissorNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetExclusiveScissorNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstExclusiveScissor;
        uint32_t exclusiveScissorCount;
        PTR32 pExclusiveScissors;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetExclusiveScissorNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkRect2D *)UlongToPtr(params->pExclusiveScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetExtraPrimitiveOverestimationSizeEXT(void *args)
{
    struct vkCmdSetExtraPrimitiveOverestimationSizeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->extraPrimitiveOverestimationSize);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetExtraPrimitiveOverestimationSizeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float extraPrimitiveOverestimationSize;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->extraPrimitiveOverestimationSize);
}

#ifdef _WIN64
static void thunk64_vkCmdSetFragmentShadingRateEnumNV(void *args)
{
    struct vkCmdSetFragmentShadingRateEnumNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetFragmentShadingRateEnumNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->shadingRate, params->combinerOps);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFragmentShadingRateEnumNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkFragmentShadingRateNV shadingRate;
        PTR32 combinerOps;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetFragmentShadingRateEnumNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->shadingRate, (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
}

#ifdef _WIN64
static void thunk64_vkCmdSetFragmentShadingRateKHR(void *args)
{
    struct vkCmdSetFragmentShadingRateKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetFragmentShadingRateKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pFragmentSize, params->combinerOps);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFragmentShadingRateKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pFragmentSize;
        PTR32 combinerOps;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetFragmentShadingRateKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, (const VkExtent2D *)UlongToPtr(params->pFragmentSize), (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
}

#ifdef _WIN64
static void thunk64_vkCmdSetFrontFace(void *args)
{
    struct vkCmdSetFrontFace_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetFrontFace(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->frontFace);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFrontFace(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkFrontFace frontFace;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetFrontFace(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->frontFace);
}

#ifdef _WIN64
static void thunk64_vkCmdSetFrontFaceEXT(void *args)
{
    struct vkCmdSetFrontFaceEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetFrontFaceEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->frontFace);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFrontFaceEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkFrontFace frontFace;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetFrontFaceEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->frontFace);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineRasterizationModeEXT(void *args)
{
    struct vkCmdSetLineRasterizationModeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetLineRasterizationModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->lineRasterizationMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineRasterizationModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkLineRasterizationModeEXT lineRasterizationMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetLineRasterizationModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->lineRasterizationMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineStippleEXT(void *args)
{
    struct vkCmdSetLineStippleEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetLineStippleEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineStippleEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t lineStippleFactor;
        uint16_t lineStipplePattern;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetLineStippleEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineStippleEnableEXT(void *args)
{
    struct vkCmdSetLineStippleEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetLineStippleEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stippledLineEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineStippleEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 stippledLineEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetLineStippleEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stippledLineEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineWidth(void *args)
{
    struct vkCmdSetLineWidth_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetLineWidth(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->lineWidth);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineWidth(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float lineWidth;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetLineWidth(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->lineWidth);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLogicOpEXT(void *args)
{
    struct vkCmdSetLogicOpEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetLogicOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->logicOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLogicOpEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkLogicOp logicOp;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetLogicOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->logicOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLogicOpEnableEXT(void *args)
{
    struct vkCmdSetLogicOpEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetLogicOpEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->logicOpEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLogicOpEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 logicOpEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetLogicOpEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->logicOpEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPatchControlPointsEXT(void *args)
{
    struct vkCmdSetPatchControlPointsEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPatchControlPointsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->patchControlPoints);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPatchControlPointsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t patchControlPoints;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPatchControlPointsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->patchControlPoints);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCmdSetPerformanceMarkerINTEL(void *args)
{
    struct vkCmdSetPerformanceMarkerINTEL_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);

    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPerformanceMarkerINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCmdSetPerformanceMarkerINTEL(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
        VkResult result;
    } *params = args;
    VkPerformanceMarkerInfoINTEL pMarkerInfo_host;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);

    convert_VkPerformanceMarkerInfoINTEL_win32_to_host((const VkPerformanceMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPerformanceMarkerINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pMarkerInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCmdSetPerformanceOverrideINTEL(void *args)
{
    struct vkCmdSetPerformanceOverrideINTEL_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pOverrideInfo);

    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPerformanceOverrideINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pOverrideInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCmdSetPerformanceOverrideINTEL(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pOverrideInfo;
        VkResult result;
    } *params = args;
    VkPerformanceOverrideInfoINTEL pOverrideInfo_host;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pOverrideInfo);

    convert_VkPerformanceOverrideInfoINTEL_win32_to_host((const VkPerformanceOverrideInfoINTEL32 *)UlongToPtr(params->pOverrideInfo), &pOverrideInfo_host);
    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPerformanceOverrideINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pOverrideInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCmdSetPerformanceStreamMarkerINTEL(void *args)
{
    struct vkCmdSetPerformanceStreamMarkerINTEL_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);

    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPerformanceStreamMarkerINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCmdSetPerformanceStreamMarkerINTEL(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
        VkResult result;
    } *params = args;
    VkPerformanceStreamMarkerInfoINTEL pMarkerInfo_host;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);

    convert_VkPerformanceStreamMarkerInfoINTEL_win32_to_host((const VkPerformanceStreamMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPerformanceStreamMarkerINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pMarkerInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkCmdSetPolygonModeEXT(void *args)
{
    struct vkCmdSetPolygonModeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPolygonModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->polygonMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPolygonModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPolygonMode polygonMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPolygonModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->polygonMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveRestartEnable(void *args)
{
    struct vkCmdSetPrimitiveRestartEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPrimitiveRestartEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->primitiveRestartEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveRestartEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 primitiveRestartEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPrimitiveRestartEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->primitiveRestartEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveRestartEnableEXT(void *args)
{
    struct vkCmdSetPrimitiveRestartEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPrimitiveRestartEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->primitiveRestartEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveRestartEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 primitiveRestartEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPrimitiveRestartEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->primitiveRestartEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveTopology(void *args)
{
    struct vkCmdSetPrimitiveTopology_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPrimitiveTopology(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->primitiveTopology);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveTopology(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPrimitiveTopology primitiveTopology;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPrimitiveTopology(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->primitiveTopology);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveTopologyEXT(void *args)
{
    struct vkCmdSetPrimitiveTopologyEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetPrimitiveTopologyEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->primitiveTopology);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveTopologyEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPrimitiveTopology primitiveTopology;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetPrimitiveTopologyEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->primitiveTopology);
}

#ifdef _WIN64
static void thunk64_vkCmdSetProvokingVertexModeEXT(void *args)
{
    struct vkCmdSetProvokingVertexModeEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetProvokingVertexModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->provokingVertexMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetProvokingVertexModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkProvokingVertexModeEXT provokingVertexMode;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetProvokingVertexModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->provokingVertexMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizationSamplesEXT(void *args)
{
    struct vkCmdSetRasterizationSamplesEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetRasterizationSamplesEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->rasterizationSamples);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizationSamplesEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkSampleCountFlagBits rasterizationSamples;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetRasterizationSamplesEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->rasterizationSamples);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizationStreamEXT(void *args)
{
    struct vkCmdSetRasterizationStreamEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetRasterizationStreamEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->rasterizationStream);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizationStreamEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t rasterizationStream;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetRasterizationStreamEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->rasterizationStream);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizerDiscardEnable(void *args)
{
    struct vkCmdSetRasterizerDiscardEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetRasterizerDiscardEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->rasterizerDiscardEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizerDiscardEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 rasterizerDiscardEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetRasterizerDiscardEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->rasterizerDiscardEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizerDiscardEnableEXT(void *args)
{
    struct vkCmdSetRasterizerDiscardEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetRasterizerDiscardEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->rasterizerDiscardEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizerDiscardEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 rasterizerDiscardEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetRasterizerDiscardEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->rasterizerDiscardEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRayTracingPipelineStackSizeKHR(void *args)
{
    struct vkCmdSetRayTracingPipelineStackSizeKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetRayTracingPipelineStackSizeKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineStackSize);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRayTracingPipelineStackSizeKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t pipelineStackSize;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetRayTracingPipelineStackSizeKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineStackSize);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRepresentativeFragmentTestEnableNV(void *args)
{
    struct vkCmdSetRepresentativeFragmentTestEnableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetRepresentativeFragmentTestEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->representativeFragmentTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRepresentativeFragmentTestEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 representativeFragmentTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetRepresentativeFragmentTestEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->representativeFragmentTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetSampleLocationsEXT(void *args)
{
    struct vkCmdSetSampleLocationsEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetSampleLocationsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pSampleLocationsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetSampleLocationsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSampleLocationsInfo;
    } *params = args;
    VkSampleLocationsInfoEXT pSampleLocationsInfo_host;

    convert_VkSampleLocationsInfoEXT_win32_to_host((const VkSampleLocationsInfoEXT32 *)UlongToPtr(params->pSampleLocationsInfo), &pSampleLocationsInfo_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetSampleLocationsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pSampleLocationsInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdSetSampleLocationsEnableEXT(void *args)
{
    struct vkCmdSetSampleLocationsEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetSampleLocationsEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->sampleLocationsEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetSampleLocationsEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 sampleLocationsEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetSampleLocationsEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->sampleLocationsEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetSampleMaskEXT(void *args)
{
    struct vkCmdSetSampleMaskEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetSampleMaskEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->samples, params->pSampleMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetSampleMaskEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkSampleCountFlagBits samples;
        PTR32 pSampleMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetSampleMaskEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->samples, (const VkSampleMask *)UlongToPtr(params->pSampleMask));
}

#ifdef _WIN64
static void thunk64_vkCmdSetScissor(void *args)
{
    struct vkCmdSetScissor_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetScissor(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstScissor, params->scissorCount, params->pScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetScissor(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstScissor;
        uint32_t scissorCount;
        PTR32 pScissors;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetScissor(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstScissor, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetScissorWithCount(void *args)
{
    struct vkCmdSetScissorWithCount_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetScissorWithCount(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->scissorCount, params->pScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetScissorWithCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t scissorCount;
        PTR32 pScissors;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetScissorWithCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetScissorWithCountEXT(void *args)
{
    struct vkCmdSetScissorWithCountEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetScissorWithCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->scissorCount, params->pScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetScissorWithCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t scissorCount;
        PTR32 pScissors;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetScissorWithCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetShadingRateImageEnableNV(void *args)
{
    struct vkCmdSetShadingRateImageEnableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetShadingRateImageEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->shadingRateImageEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetShadingRateImageEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 shadingRateImageEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetShadingRateImageEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->shadingRateImageEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilCompareMask(void *args)
{
    struct vkCmdSetStencilCompareMask_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilCompareMask(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->faceMask, params->compareMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilCompareMask(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        uint32_t compareMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilCompareMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->faceMask, params->compareMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilOp(void *args)
{
    struct vkCmdSetStencilOp_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilOp(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilOp(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        VkStencilOp failOp;
        VkStencilOp passOp;
        VkStencilOp depthFailOp;
        VkCompareOp compareOp;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilOp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilOpEXT(void *args)
{
    struct vkCmdSetStencilOpEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilOpEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        VkStencilOp failOp;
        VkStencilOp passOp;
        VkStencilOp depthFailOp;
        VkCompareOp compareOp;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilReference(void *args)
{
    struct vkCmdSetStencilReference_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilReference(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->faceMask, params->reference);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilReference(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        uint32_t reference;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilReference(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->faceMask, params->reference);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilTestEnable(void *args)
{
    struct vkCmdSetStencilTestEnable_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stencilTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilTestEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 stencilTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stencilTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilTestEnableEXT(void *args)
{
    struct vkCmdSetStencilTestEnableEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stencilTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilTestEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 stencilTestEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stencilTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilWriteMask(void *args)
{
    struct vkCmdSetStencilWriteMask_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetStencilWriteMask(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->faceMask, params->writeMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilWriteMask(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        uint32_t writeMask;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetStencilWriteMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->faceMask, params->writeMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetTessellationDomainOriginEXT(void *args)
{
    struct vkCmdSetTessellationDomainOriginEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetTessellationDomainOriginEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->domainOrigin);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetTessellationDomainOriginEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkTessellationDomainOrigin domainOrigin;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetTessellationDomainOriginEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->domainOrigin);
}

#ifdef _WIN64
static void thunk64_vkCmdSetVertexInputEXT(void *args)
{
    struct vkCmdSetVertexInputEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetVertexInputEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->vertexBindingDescriptionCount, params->pVertexBindingDescriptions, params->vertexAttributeDescriptionCount, params->pVertexAttributeDescriptions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetVertexInputEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t vertexBindingDescriptionCount;
        PTR32 pVertexBindingDescriptions;
        uint32_t vertexAttributeDescriptionCount;
        PTR32 pVertexAttributeDescriptions;
    } *params = args;
    const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions_host;
    const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pVertexBindingDescriptions_host = convert_VkVertexInputBindingDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputBindingDescription2EXT32 *)UlongToPtr(params->pVertexBindingDescriptions), params->vertexBindingDescriptionCount);
    pVertexAttributeDescriptions_host = convert_VkVertexInputAttributeDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputAttributeDescription2EXT32 *)UlongToPtr(params->pVertexAttributeDescriptions), params->vertexAttributeDescriptionCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetVertexInputEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->vertexBindingDescriptionCount, pVertexBindingDescriptions_host, params->vertexAttributeDescriptionCount, pVertexAttributeDescriptions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewport(void *args)
{
    struct vkCmdSetViewport_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewport(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstViewport, params->viewportCount, params->pViewports);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewport(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pViewports;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewport(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstViewport, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportShadingRatePaletteNV(void *args)
{
    struct vkCmdSetViewportShadingRatePaletteNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewportShadingRatePaletteNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstViewport, params->viewportCount, params->pShadingRatePalettes);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportShadingRatePaletteNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pShadingRatePalettes;
    } *params = args;
    const VkShadingRatePaletteNV *pShadingRatePalettes_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pShadingRatePalettes_host = convert_VkShadingRatePaletteNV_array_win32_to_host(ctx, (const VkShadingRatePaletteNV32 *)UlongToPtr(params->pShadingRatePalettes), params->viewportCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewportShadingRatePaletteNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstViewport, params->viewportCount, pShadingRatePalettes_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportSwizzleNV(void *args)
{
    struct vkCmdSetViewportSwizzleNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewportSwizzleNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstViewport, params->viewportCount, params->pViewportSwizzles);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportSwizzleNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pViewportSwizzles;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewportSwizzleNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstViewport, params->viewportCount, (const VkViewportSwizzleNV *)UlongToPtr(params->pViewportSwizzles));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWScalingEnableNV(void *args)
{
    struct vkCmdSetViewportWScalingEnableNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewportWScalingEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->viewportWScalingEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWScalingEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 viewportWScalingEnable;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewportWScalingEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->viewportWScalingEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWScalingNV(void *args)
{
    struct vkCmdSetViewportWScalingNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewportWScalingNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->firstViewport, params->viewportCount, params->pViewportWScalings);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWScalingNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pViewportWScalings;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewportWScalingNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->firstViewport, params->viewportCount, (const VkViewportWScalingNV *)UlongToPtr(params->pViewportWScalings));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWithCount(void *args)
{
    struct vkCmdSetViewportWithCount_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewportWithCount(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->viewportCount, params->pViewports);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWithCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t viewportCount;
        PTR32 pViewports;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewportWithCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWithCountEXT(void *args)
{
    struct vkCmdSetViewportWithCountEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSetViewportWithCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->viewportCount, params->pViewports);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWithCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t viewportCount;
        PTR32 pViewports;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSetViewportWithCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
}

#ifdef _WIN64
static void thunk64_vkCmdSubpassShadingHUAWEI(void *args)
{
    struct vkCmdSubpassShadingHUAWEI_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdSubpassShadingHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSubpassShadingHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdSubpassShadingHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysIndirect2KHR(void *args)
{
    struct vkCmdTraceRaysIndirect2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdTraceRaysIndirect2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->indirectDeviceAddress);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysIndirect2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectDeviceAddress;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdTraceRaysIndirect2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->indirectDeviceAddress);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysIndirectKHR(void *args)
{
    struct vkCmdTraceRaysIndirectKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdTraceRaysIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->indirectDeviceAddress);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysIndirectKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRaygenShaderBindingTable;
        PTR32 pMissShaderBindingTable;
        PTR32 pHitShaderBindingTable;
        PTR32 pCallableShaderBindingTable;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectDeviceAddress;
    } *params = args;
    VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pMissShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pHitShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable_host;

    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pRaygenShaderBindingTable), &pRaygenShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdTraceRaysIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->indirectDeviceAddress);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysKHR(void *args)
{
    struct vkCmdTraceRaysKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdTraceRaysKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->width, params->height, params->depth);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRaygenShaderBindingTable;
        PTR32 pMissShaderBindingTable;
        PTR32 pHitShaderBindingTable;
        PTR32 pCallableShaderBindingTable;
        uint32_t width;
        uint32_t height;
        uint32_t depth;
    } *params = args;
    VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pMissShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pHitShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable_host;

    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pRaygenShaderBindingTable), &pRaygenShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdTraceRaysKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->width, params->height, params->depth);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysNV(void *args)
{
    struct vkCmdTraceRaysNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdTraceRaysNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) raygenShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) raygenShaderBindingOffset;
        VkBuffer DECLSPEC_ALIGN(8) missShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) missShaderBindingOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) missShaderBindingStride;
        VkBuffer DECLSPEC_ALIGN(8) hitShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) hitShaderBindingOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) hitShaderBindingStride;
        VkBuffer DECLSPEC_ALIGN(8) callableShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) callableShaderBindingOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) callableShaderBindingStride;
        uint32_t width;
        uint32_t height;
        uint32_t depth;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdTraceRaysNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
}

#ifdef _WIN64
static void thunk64_vkCmdUpdateBuffer(void *args)
{
    struct vkCmdUpdateBuffer_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdUpdateBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkCmdUpdateBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) dataSize;
        PTR32 pData;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdUpdateBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static void thunk64_vkCmdUpdatePipelineIndirectBufferNV(void *args)
{
    struct vkCmdUpdatePipelineIndirectBufferNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdUpdatePipelineIndirectBufferNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineBindPoint, params->pipeline);
}
#endif /* _WIN64 */

static void thunk32_vkCmdUpdatePipelineIndirectBufferNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdUpdatePipelineIndirectBufferNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineBindPoint, params->pipeline);
}

#ifdef _WIN64
static void thunk64_vkCmdWaitEvents(void *args)
{
    struct vkCmdWaitEvents_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWaitEvents(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->eventCount, params->pEvents, params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWaitEvents(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t eventCount;
        PTR32 pEvents;
        VkPipelineStageFlags srcStageMask;
        VkPipelineStageFlags dstStageMask;
        uint32_t memoryBarrierCount;
        PTR32 pMemoryBarriers;
        uint32_t bufferMemoryBarrierCount;
        PTR32 pBufferMemoryBarriers;
        uint32_t imageMemoryBarrierCount;
        PTR32 pImageMemoryBarriers;
    } *params = args;
    const VkMemoryBarrier *pMemoryBarriers_host;
    const VkBufferMemoryBarrier *pBufferMemoryBarriers_host;
    const VkImageMemoryBarrier *pImageMemoryBarriers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
    pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
    pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWaitEvents(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdWaitEvents2(void *args)
{
    struct vkCmdWaitEvents2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWaitEvents2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWaitEvents2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t eventCount;
        PTR32 pEvents;
        PTR32 pDependencyInfos;
    } *params = args;
    const VkDependencyInfo *pDependencyInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWaitEvents2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdWaitEvents2KHR(void *args)
{
    struct vkCmdWaitEvents2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWaitEvents2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWaitEvents2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t eventCount;
        PTR32 pEvents;
        PTR32 pDependencyInfos;
    } *params = args;
    const VkDependencyInfo *pDependencyInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWaitEvents2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct vkCmdWriteAccelerationStructuresPropertiesKHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteAccelerationStructuresPropertiesKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t accelerationStructureCount;
        PTR32 pAccelerationStructures;
        VkQueryType queryType;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteAccelerationStructuresPropertiesKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteAccelerationStructuresPropertiesNV(void *args)
{
    struct vkCmdWriteAccelerationStructuresPropertiesNV_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteAccelerationStructuresPropertiesNV(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteAccelerationStructuresPropertiesNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t accelerationStructureCount;
        PTR32 pAccelerationStructures;
        VkQueryType queryType;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteAccelerationStructuresPropertiesNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteBufferMarker2AMD(void *args)
{
    struct vkCmdWriteBufferMarker2AMD_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteBufferMarker2AMD(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteBufferMarker2AMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        uint32_t marker;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteBufferMarker2AMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteBufferMarkerAMD(void *args)
{
    struct vkCmdWriteBufferMarkerAMD_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteBufferMarkerAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteBufferMarkerAMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlagBits pipelineStage;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        uint32_t marker;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteBufferMarkerAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteMicromapsPropertiesEXT(void *args)
{
    struct vkCmdWriteMicromapsPropertiesEXT_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteMicromapsPropertiesEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->micromapCount, params->pMicromaps, params->queryType, params->queryPool, params->firstQuery);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteMicromapsPropertiesEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t micromapCount;
        PTR32 pMicromaps;
        VkQueryType queryType;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteMicromapsPropertiesEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->queryPool, params->firstQuery);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteTimestamp(void *args)
{
    struct vkCmdWriteTimestamp_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteTimestamp(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->pipelineStage, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteTimestamp(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlagBits pipelineStage;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteTimestamp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->pipelineStage, params->queryPool, params->query);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteTimestamp2(void *args)
{
    struct vkCmdWriteTimestamp2_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteTimestamp2(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stage, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteTimestamp2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteTimestamp2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stage, params->queryPool, params->query);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteTimestamp2KHR(void *args)
{
    struct vkCmdWriteTimestamp2KHR_params *params = args;

    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdWriteTimestamp2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->stage, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteTimestamp2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdWriteTimestamp2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->stage, params->queryPool, params->query);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCompileDeferredNV(void *args)
{
    struct vkCompileDeferredNV_params *params = args;

    TRACE("%p, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shader);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCompileDeferredNV(wine_device_from_handle(params->device)->device, params->pipeline, params->shader);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCompileDeferredNV(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t shader;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shader);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCompileDeferredNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, params->shader);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyAccelerationStructureKHR(void *args)
{
    struct vkCopyAccelerationStructureKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyAccelerationStructureKHR(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyAccelerationStructureInfoKHR pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyAccelerationStructureInfoKHR_win32_to_host((const VkCopyAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyAccelerationStructureKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct vkCopyAccelerationStructureToMemoryKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyAccelerationStructureToMemoryKHR(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyAccelerationStructureToMemoryInfoKHR pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host((const VkCopyAccelerationStructureToMemoryInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyAccelerationStructureToMemoryKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyImageToImageEXT(void *args)
{
    struct vkCopyImageToImageEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyImageToImageInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyImageToImageEXT(wine_device_from_handle(params->device)->device, params->pCopyImageToImageInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyImageToImageEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyImageToImageInfo;
        VkResult result;
    } *params = args;
    VkCopyImageToImageInfoEXT pCopyImageToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyImageToImageInfo);

    init_conversion_context(ctx);
    convert_VkCopyImageToImageInfoEXT_win32_to_host(ctx, (const VkCopyImageToImageInfoEXT32 *)UlongToPtr(params->pCopyImageToImageInfo), &pCopyImageToImageInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyImageToImageEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCopyImageToImageInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyImageToMemoryEXT(void *args)
{
    struct vkCopyImageToMemoryEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyImageToMemoryInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyImageToMemoryEXT(wine_device_from_handle(params->device)->device, params->pCopyImageToMemoryInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyImageToMemoryEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyImageToMemoryInfo;
        VkResult result;
    } *params = args;
    VkCopyImageToMemoryInfoEXT pCopyImageToMemoryInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyImageToMemoryInfo);

    init_conversion_context(ctx);
    convert_VkCopyImageToMemoryInfoEXT_win32_to_host(ctx, (const VkCopyImageToMemoryInfoEXT32 *)UlongToPtr(params->pCopyImageToMemoryInfo), &pCopyImageToMemoryInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyImageToMemoryEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCopyImageToMemoryInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct vkCopyMemoryToAccelerationStructureKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyMemoryToAccelerationStructureKHR(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToAccelerationStructureInfoKHR pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host((const VkCopyMemoryToAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyMemoryToAccelerationStructureKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToImageEXT(void *args)
{
    struct vkCopyMemoryToImageEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyMemoryToImageInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyMemoryToImageEXT(wine_device_from_handle(params->device)->device, params->pCopyMemoryToImageInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToImageEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyMemoryToImageInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToImageInfoEXT pCopyMemoryToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyMemoryToImageInfo);

    init_conversion_context(ctx);
    convert_VkCopyMemoryToImageInfoEXT_win32_to_host(ctx, (const VkCopyMemoryToImageInfoEXT32 *)UlongToPtr(params->pCopyMemoryToImageInfo), &pCopyMemoryToImageInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyMemoryToImageEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCopyMemoryToImageInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToMicromapEXT(void *args)
{
    struct vkCopyMemoryToMicromapEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyMemoryToMicromapEXT(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToMicromapInfoEXT pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host((const VkCopyMemoryToMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyMemoryToMicromapEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMicromapEXT(void *args)
{
    struct vkCopyMicromapEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyMicromapEXT(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMicromapInfoEXT pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMicromapInfoEXT_win32_to_host((const VkCopyMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyMicromapEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMicromapToMemoryEXT(void *args)
{
    struct vkCopyMicromapToMemoryEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCopyMicromapToMemoryEXT(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMicromapToMemoryEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMicromapToMemoryInfoEXT pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host((const VkCopyMicromapToMemoryInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCopyMicromapToMemoryEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateAccelerationStructureKHR(void *args)
{
    struct vkCreateAccelerationStructureKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateAccelerationStructureKHR(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pAccelerationStructure);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pAccelerationStructure;
        VkResult result;
    } *params = args;
    VkAccelerationStructureCreateInfoKHR pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    init_conversion_context(ctx);
    convert_VkAccelerationStructureCreateInfoKHR_win32_to_host(ctx, (const VkAccelerationStructureCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateAccelerationStructureKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructure));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateAccelerationStructureNV(void *args)
{
    struct vkCreateAccelerationStructureNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateAccelerationStructureNV(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pAccelerationStructure);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pAccelerationStructure;
        VkResult result;
    } *params = args;
    VkAccelerationStructureCreateInfoNV pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    init_conversion_context(ctx);
    convert_VkAccelerationStructureCreateInfoNV_win32_to_host(ctx, (const VkAccelerationStructureCreateInfoNV32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateAccelerationStructureNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructure));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateBuffer(void *args)
{
    struct vkCreateBuffer_params *params = args;
    VkBufferCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);

    init_conversion_context(ctx);
    convert_VkBufferCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateBuffer(params->device, &pCreateInfo_host, params->pAllocator, params->pBuffer);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateBuffer(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pBuffer;
        VkResult result;
    } *params = args;
    VkBufferCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);

    init_conversion_context(ctx);
    convert_VkBufferCreateInfo_win32_to_host(ctx, (const VkBufferCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateBuffer((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkBuffer *)UlongToPtr(params->pBuffer));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateBufferView(void *args)
{
    struct vkCreateBufferView_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateBufferView(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pView);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateBufferView(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pView;
        VkResult result;
    } *params = args;
    VkBufferViewCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    init_conversion_context(ctx);
    convert_VkBufferViewCreateInfo_win32_to_host(ctx, (const VkBufferViewCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateBufferView(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkBufferView *)UlongToPtr(params->pView));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateCommandPool(void *args)
{
    struct vkCreateCommandPool_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool);

    params->result = wine_vkCreateCommandPool(params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool, (void *)params->client_ptr);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pCommandPool;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkCommandPoolCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool);

    convert_VkCommandPoolCreateInfo_win32_to_host((const VkCommandPoolCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateCommandPool((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkCommandPool *)UlongToPtr(params->pCommandPool), UlongToPtr(params->client_ptr));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateComputePipelines(void *args)
{
    struct vkCreateComputePipelines_params *params = args;
    const VkComputePipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkComputePipelineCreateInfo_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateComputePipelines(wine_device_from_handle(params->device)->device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateComputePipelines(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkComputePipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkComputePipelineCreateInfo_array_win32_to_host(ctx, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateComputePipelines(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkComputePipelineCreateInfo_array_host_to_win32(pCreateInfos_host, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateCuFunctionNVX(void *args)
{
    struct vkCreateCuFunctionNVX_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFunction);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateCuFunctionNVX(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pFunction);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateCuFunctionNVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pFunction;
        VkResult result;
    } *params = args;
    VkCuFunctionCreateInfoNVX pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pFunction);

    convert_VkCuFunctionCreateInfoNVX_win32_to_host((const VkCuFunctionCreateInfoNVX32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateCuFunctionNVX(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkCuFunctionNVX *)UlongToPtr(params->pFunction));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateCuModuleNVX(void *args)
{
    struct vkCreateCuModuleNVX_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pModule);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateCuModuleNVX(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pModule);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateCuModuleNVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pModule;
        VkResult result;
    } *params = args;
    VkCuModuleCreateInfoNVX pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pModule);

    convert_VkCuModuleCreateInfoNVX_win32_to_host((const VkCuModuleCreateInfoNVX32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateCuModuleNVX(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkCuModuleNVX *)UlongToPtr(params->pModule));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDebugReportCallbackEXT(void *args)
{
    struct vkCreateDebugReportCallbackEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->instance, params->pCreateInfo, params->pAllocator, params->pCallback);

    params->result = wine_vkCreateDebugReportCallbackEXT(params->instance, params->pCreateInfo, params->pAllocator, params->pCallback);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDebugReportCallbackEXT(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pCallback;
        VkResult result;
    } *params = args;
    VkDebugReportCallbackCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->pCreateInfo, params->pAllocator, params->pCallback);

    convert_VkDebugReportCallbackCreateInfoEXT_win32_to_host((const VkDebugReportCallbackCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateDebugReportCallbackEXT((VkInstance)UlongToPtr(params->instance), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDebugReportCallbackEXT *)UlongToPtr(params->pCallback));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDebugUtilsMessengerEXT(void *args)
{
    struct vkCreateDebugUtilsMessengerEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->instance, params->pCreateInfo, params->pAllocator, params->pMessenger);

    params->result = wine_vkCreateDebugUtilsMessengerEXT(params->instance, params->pCreateInfo, params->pAllocator, params->pMessenger);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDebugUtilsMessengerEXT(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pMessenger;
        VkResult result;
    } *params = args;
    VkDebugUtilsMessengerCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->pCreateInfo, params->pAllocator, params->pMessenger);

    convert_VkDebugUtilsMessengerCreateInfoEXT_win32_to_host((const VkDebugUtilsMessengerCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateDebugUtilsMessengerEXT((VkInstance)UlongToPtr(params->instance), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDebugUtilsMessengerEXT *)UlongToPtr(params->pMessenger));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDeferredOperationKHR(void *args)
{
    struct vkCreateDeferredOperationKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAllocator, params->pDeferredOperation);

    params->result = wine_vkCreateDeferredOperationKHR(params->device, params->pAllocator, params->pDeferredOperation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDeferredOperationKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocator;
        PTR32 pDeferredOperation;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAllocator, params->pDeferredOperation);

    params->result = wine_vkCreateDeferredOperationKHR((VkDevice)UlongToPtr(params->device), (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeferredOperationKHR *)UlongToPtr(params->pDeferredOperation));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorPool(void *args)
{
    struct vkCreateDescriptorPool_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorPool);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateDescriptorPool(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pDescriptorPool);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorPool(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDescriptorPool;
        VkResult result;
    } *params = args;
    VkDescriptorPoolCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorPool);

    init_conversion_context(ctx);
    convert_VkDescriptorPoolCreateInfo_win32_to_host(ctx, (const VkDescriptorPoolCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateDescriptorPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkDescriptorPool *)UlongToPtr(params->pDescriptorPool));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorSetLayout(void *args)
{
    struct vkCreateDescriptorSetLayout_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSetLayout);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateDescriptorSetLayout(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pSetLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorSetLayout(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSetLayout;
        VkResult result;
    } *params = args;
    VkDescriptorSetLayoutCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSetLayout);

    init_conversion_context(ctx);
    convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(ctx, (const VkDescriptorSetLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateDescriptorSetLayout(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkDescriptorSetLayout *)UlongToPtr(params->pSetLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorUpdateTemplate(void *args)
{
    struct vkCreateDescriptorUpdateTemplate_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateDescriptorUpdateTemplate(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pDescriptorUpdateTemplate);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorUpdateTemplate(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDescriptorUpdateTemplate;
        VkResult result;
    } *params = args;
    VkDescriptorUpdateTemplateCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    init_conversion_context(ctx);
    convert_VkDescriptorUpdateTemplateCreateInfo_win32_to_host(ctx, (const VkDescriptorUpdateTemplateCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateDescriptorUpdateTemplate(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkDescriptorUpdateTemplate *)UlongToPtr(params->pDescriptorUpdateTemplate));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorUpdateTemplateKHR(void *args)
{
    struct vkCreateDescriptorUpdateTemplateKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateDescriptorUpdateTemplateKHR(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pDescriptorUpdateTemplate);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorUpdateTemplateKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDescriptorUpdateTemplate;
        VkResult result;
    } *params = args;
    VkDescriptorUpdateTemplateCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    init_conversion_context(ctx);
    convert_VkDescriptorUpdateTemplateCreateInfo_win32_to_host(ctx, (const VkDescriptorUpdateTemplateCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateDescriptorUpdateTemplateKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkDescriptorUpdateTemplate *)UlongToPtr(params->pDescriptorUpdateTemplate));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDevice(void *args)
{
    struct vkCreateDevice_params *params = args;
    VkDeviceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pCreateInfo, params->pAllocator, params->pDevice);

    init_conversion_context(ctx);
    convert_VkDeviceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateDevice(params->physicalDevice, &pCreateInfo_host, params->pAllocator, params->pDevice, (void *)params->client_ptr);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDevice(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDevice;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkDeviceCreateInfo pCreateInfo_host;
    VkDevice pDevice_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pCreateInfo, params->pAllocator, params->pDevice);

    init_conversion_context(ctx);
    convert_VkDeviceCreateInfo_win32_to_host(ctx, (const VkDeviceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    pDevice_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pDevice));
    params->result = wine_vkCreateDevice((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), &pDevice_host, UlongToPtr(params->client_ptr));
    *(PTR32 *)UlongToPtr(params->pDevice) = PtrToUlong(pDevice_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateEvent(void *args)
{
    struct vkCreateEvent_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pEvent);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateEvent(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pEvent);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateEvent(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pEvent;
        VkResult result;
    } *params = args;
    VkEventCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pEvent);

    convert_VkEventCreateInfo_win32_to_host((const VkEventCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateEvent(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkEvent *)UlongToPtr(params->pEvent));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateFence(void *args)
{
    struct vkCreateFence_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFence);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateFence(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pFence);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateFence(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pFence;
        VkResult result;
    } *params = args;
    VkFenceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pFence);

    init_conversion_context(ctx);
    convert_VkFenceCreateInfo_win32_to_host(ctx, (const VkFenceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateFence(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkFence *)UlongToPtr(params->pFence));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateFramebuffer(void *args)
{
    struct vkCreateFramebuffer_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFramebuffer);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateFramebuffer(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pFramebuffer);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateFramebuffer(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pFramebuffer;
        VkResult result;
    } *params = args;
    VkFramebufferCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pFramebuffer);

    init_conversion_context(ctx);
    convert_VkFramebufferCreateInfo_win32_to_host(ctx, (const VkFramebufferCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateFramebuffer(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkFramebuffer *)UlongToPtr(params->pFramebuffer));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateGraphicsPipelines(void *args)
{
    struct vkCreateGraphicsPipelines_params *params = args;
    const VkGraphicsPipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkGraphicsPipelineCreateInfo_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateGraphicsPipelines(wine_device_from_handle(params->device)->device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateGraphicsPipelines(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkGraphicsPipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkGraphicsPipelineCreateInfo_array_win32_to_host(ctx, (const VkGraphicsPipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateGraphicsPipelines(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkGraphicsPipelineCreateInfo_array_host_to_win32(pCreateInfos_host, (const VkGraphicsPipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateImage(void *args)
{
    struct vkCreateImage_params *params = args;
    VkImageCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pImage);

    init_conversion_context(ctx);
    convert_VkImageCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateImage(params->device, &pCreateInfo_host, params->pAllocator, params->pImage);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateImage(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pImage;
        VkResult result;
    } *params = args;
    VkImageCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pImage);

    init_conversion_context(ctx);
    convert_VkImageCreateInfo_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateImage((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkImage *)UlongToPtr(params->pImage));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateImageView(void *args)
{
    struct vkCreateImageView_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateImageView(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pView);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateImageView(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pView;
        VkResult result;
    } *params = args;
    VkImageViewCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    init_conversion_context(ctx);
    convert_VkImageViewCreateInfo_win32_to_host(ctx, (const VkImageViewCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateImageView(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkImageView *)UlongToPtr(params->pView));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateIndirectCommandsLayoutNV(void *args)
{
    struct vkCreateIndirectCommandsLayoutNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectCommandsLayout);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateIndirectCommandsLayoutNV(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pIndirectCommandsLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateIndirectCommandsLayoutNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pIndirectCommandsLayout;
        VkResult result;
    } *params = args;
    VkIndirectCommandsLayoutCreateInfoNV pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectCommandsLayout);

    init_conversion_context(ctx);
    convert_VkIndirectCommandsLayoutCreateInfoNV_win32_to_host(ctx, (const VkIndirectCommandsLayoutCreateInfoNV32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateIndirectCommandsLayoutNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkIndirectCommandsLayoutNV *)UlongToPtr(params->pIndirectCommandsLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateInstance(void *args)
{
    struct vkCreateInstance_params *params = args;
    VkInstanceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->pCreateInfo, params->pAllocator, params->pInstance);

    init_conversion_context(ctx);
    convert_VkInstanceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateInstance(&pCreateInfo_host, params->pAllocator, params->pInstance, (void *)params->client_ptr);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateInstance(void *args)
{
    struct
    {
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pInstance;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkInstanceCreateInfo pCreateInfo_host;
    VkInstance pInstance_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->pCreateInfo, params->pAllocator, params->pInstance);

    init_conversion_context(ctx);
    convert_VkInstanceCreateInfo_win32_to_host(ctx, (const VkInstanceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    pInstance_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pInstance));
    params->result = wine_vkCreateInstance(&pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), &pInstance_host, UlongToPtr(params->client_ptr));
    *(PTR32 *)UlongToPtr(params->pInstance) = PtrToUlong(pInstance_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateMicromapEXT(void *args)
{
    struct vkCreateMicromapEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pMicromap);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateMicromapEXT(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pMicromap);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pMicromap;
        VkResult result;
    } *params = args;
    VkMicromapCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pMicromap);

    convert_VkMicromapCreateInfoEXT_win32_to_host((const VkMicromapCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateMicromapEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkMicromapEXT *)UlongToPtr(params->pMicromap));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateOpticalFlowSessionNV(void *args)
{
    struct vkCreateOpticalFlowSessionNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSession);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateOpticalFlowSessionNV(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pSession);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateOpticalFlowSessionNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSession;
        VkResult result;
    } *params = args;
    VkOpticalFlowSessionCreateInfoNV pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSession);

    init_conversion_context(ctx);
    convert_VkOpticalFlowSessionCreateInfoNV_win32_to_host(ctx, (const VkOpticalFlowSessionCreateInfoNV32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateOpticalFlowSessionNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkOpticalFlowSessionNV *)UlongToPtr(params->pSession));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePipelineCache(void *args)
{
    struct vkCreatePipelineCache_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineCache);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreatePipelineCache(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pPipelineCache);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePipelineCache(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPipelineCache;
        VkResult result;
    } *params = args;
    VkPipelineCacheCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineCache);

    convert_VkPipelineCacheCreateInfo_win32_to_host((const VkPipelineCacheCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreatePipelineCache(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkPipelineCache *)UlongToPtr(params->pPipelineCache));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePipelineLayout(void *args)
{
    struct vkCreatePipelineLayout_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineLayout);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreatePipelineLayout(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pPipelineLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePipelineLayout(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPipelineLayout;
        VkResult result;
    } *params = args;
    VkPipelineLayoutCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineLayout);

    convert_VkPipelineLayoutCreateInfo_win32_to_host((const VkPipelineLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreatePipelineLayout(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkPipelineLayout *)UlongToPtr(params->pPipelineLayout));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePrivateDataSlot(void *args)
{
    struct vkCreatePrivateDataSlot_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreatePrivateDataSlot(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pPrivateDataSlot);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePrivateDataSlot(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPrivateDataSlot;
        VkResult result;
    } *params = args;
    VkPrivateDataSlotCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    convert_VkPrivateDataSlotCreateInfo_win32_to_host((const VkPrivateDataSlotCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreatePrivateDataSlot(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkPrivateDataSlot *)UlongToPtr(params->pPrivateDataSlot));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePrivateDataSlotEXT(void *args)
{
    struct vkCreatePrivateDataSlotEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreatePrivateDataSlotEXT(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pPrivateDataSlot);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePrivateDataSlotEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPrivateDataSlot;
        VkResult result;
    } *params = args;
    VkPrivateDataSlotCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    convert_VkPrivateDataSlotCreateInfo_win32_to_host((const VkPrivateDataSlotCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreatePrivateDataSlotEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkPrivateDataSlot *)UlongToPtr(params->pPrivateDataSlot));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateQueryPool(void *args)
{
    struct vkCreateQueryPool_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pQueryPool);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateQueryPool(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pQueryPool);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateQueryPool(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pQueryPool;
        VkResult result;
    } *params = args;
    VkQueryPoolCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pQueryPool);

    init_conversion_context(ctx);
    convert_VkQueryPoolCreateInfo_win32_to_host(ctx, (const VkQueryPoolCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateQueryPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkQueryPool *)UlongToPtr(params->pQueryPool));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRayTracingPipelinesKHR(void *args)
{
    struct vkCreateRayTracingPipelinesKHR_params *params = args;
    const VkRayTracingPipelineCreateInfoKHR *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoKHR_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateRayTracingPipelinesKHR(wine_device_from_handle(params->device)->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRayTracingPipelinesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkRayTracingPipelineCreateInfoKHR *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoKHR_array_win32_to_host(ctx, (const VkRayTracingPipelineCreateInfoKHR32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateRayTracingPipelinesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->deferred_operation : 0, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkRayTracingPipelineCreateInfoKHR_array_host_to_win32(pCreateInfos_host, (const VkRayTracingPipelineCreateInfoKHR32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRayTracingPipelinesNV(void *args)
{
    struct vkCreateRayTracingPipelinesNV_params *params = args;
    const VkRayTracingPipelineCreateInfoNV *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoNV_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateRayTracingPipelinesNV(wine_device_from_handle(params->device)->device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRayTracingPipelinesNV(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkRayTracingPipelineCreateInfoNV *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoNV_array_win32_to_host(ctx, (const VkRayTracingPipelineCreateInfoNV32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateRayTracingPipelinesNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkRayTracingPipelineCreateInfoNV_array_host_to_win32(pCreateInfos_host, (const VkRayTracingPipelineCreateInfoNV32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRenderPass(void *args)
{
    struct vkCreateRenderPass_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateRenderPass(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pRenderPass);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRenderPass(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pRenderPass;
        VkResult result;
    } *params = args;
    VkRenderPassCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    init_conversion_context(ctx);
    convert_VkRenderPassCreateInfo_win32_to_host(ctx, (const VkRenderPassCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateRenderPass(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkRenderPass *)UlongToPtr(params->pRenderPass));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRenderPass2(void *args)
{
    struct vkCreateRenderPass2_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateRenderPass2(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pRenderPass);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRenderPass2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pRenderPass;
        VkResult result;
    } *params = args;
    VkRenderPassCreateInfo2 pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    init_conversion_context(ctx);
    convert_VkRenderPassCreateInfo2_win32_to_host(ctx, (const VkRenderPassCreateInfo232 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateRenderPass2(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkRenderPass *)UlongToPtr(params->pRenderPass));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRenderPass2KHR(void *args)
{
    struct vkCreateRenderPass2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateRenderPass2KHR(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pRenderPass);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRenderPass2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pRenderPass;
        VkResult result;
    } *params = args;
    VkRenderPassCreateInfo2 pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    init_conversion_context(ctx);
    convert_VkRenderPassCreateInfo2_win32_to_host(ctx, (const VkRenderPassCreateInfo232 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateRenderPass2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkRenderPass *)UlongToPtr(params->pRenderPass));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSampler(void *args)
{
    struct vkCreateSampler_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSampler);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateSampler(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pSampler);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSampler(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSampler;
        VkResult result;
    } *params = args;
    VkSamplerCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSampler);

    init_conversion_context(ctx);
    convert_VkSamplerCreateInfo_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateSampler(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkSampler *)UlongToPtr(params->pSampler));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSamplerYcbcrConversion(void *args)
{
    struct vkCreateSamplerYcbcrConversion_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateSamplerYcbcrConversion(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pYcbcrConversion);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSamplerYcbcrConversion(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pYcbcrConversion;
        VkResult result;
    } *params = args;
    VkSamplerYcbcrConversionCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    init_conversion_context(ctx);
    convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(ctx, (const VkSamplerYcbcrConversionCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateSamplerYcbcrConversion(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkSamplerYcbcrConversion *)UlongToPtr(params->pYcbcrConversion));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSamplerYcbcrConversionKHR(void *args)
{
    struct vkCreateSamplerYcbcrConversionKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateSamplerYcbcrConversionKHR(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pYcbcrConversion);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSamplerYcbcrConversionKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pYcbcrConversion;
        VkResult result;
    } *params = args;
    VkSamplerYcbcrConversionCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    init_conversion_context(ctx);
    convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(ctx, (const VkSamplerYcbcrConversionCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateSamplerYcbcrConversionKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkSamplerYcbcrConversion *)UlongToPtr(params->pYcbcrConversion));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSemaphore(void *args)
{
    struct vkCreateSemaphore_params *params = args;
    VkSemaphoreCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSemaphore);

    init_conversion_context(ctx);
    convert_VkSemaphoreCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateSemaphore(params->device, &pCreateInfo_host, params->pAllocator, params->pSemaphore, (void *)params->pCreateInfo);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSemaphore(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSemaphore;
        VkResult result;
    } *params = args;
    VkSemaphoreCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSemaphore);

    init_conversion_context(ctx);
    convert_VkSemaphoreCreateInfo_win32_to_host(ctx, (const VkSemaphoreCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateSemaphore((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSemaphore *)UlongToPtr(params->pSemaphore), UlongToPtr(params->pCreateInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateShaderModule(void *args)
{
    struct vkCreateShaderModule_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pShaderModule);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateShaderModule(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pShaderModule);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateShaderModule(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pShaderModule;
        VkResult result;
    } *params = args;
    VkShaderModuleCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pShaderModule);

    init_conversion_context(ctx);
    convert_VkShaderModuleCreateInfo_win32_to_host(ctx, (const VkShaderModuleCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateShaderModule(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkShaderModule *)UlongToPtr(params->pShaderModule));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateShadersEXT(void *args)
{
    struct vkCreateShadersEXT_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->device, params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pShaders);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateShadersEXT(wine_device_from_handle(params->device)->device, params->createInfoCount, params->pCreateInfos, NULL, params->pShaders);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateShadersEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pShaders;
        VkResult result;
    } *params = args;
    const VkShaderCreateInfoEXT *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->device, params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pShaders);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkShaderCreateInfoEXT_array_win32_to_host(ctx, (const VkShaderCreateInfoEXT32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateShadersEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->createInfoCount, pCreateInfos_host, NULL, (VkShaderEXT *)UlongToPtr(params->pShaders));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSwapchainKHR(void *args)
{
    struct vkCreateSwapchainKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSwapchain);

    params->result = wine_vkCreateSwapchainKHR(params->device, params->pCreateInfo, params->pAllocator, params->pSwapchain, (void *)params->client_ptr);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSwapchainKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSwapchain;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkSwapchainCreateInfoKHR pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSwapchain);

    init_conversion_context(ctx);
    convert_VkSwapchainCreateInfoKHR_win32_to_unwrapped_host(ctx, (const VkSwapchainCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateSwapchainKHR((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSwapchainKHR *)UlongToPtr(params->pSwapchain), UlongToPtr(params->client_ptr));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateValidationCacheEXT(void *args)
{
    struct vkCreateValidationCacheEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pValidationCache);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkCreateValidationCacheEXT(wine_device_from_handle(params->device)->device, params->pCreateInfo, NULL, params->pValidationCache);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateValidationCacheEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pValidationCache;
        VkResult result;
    } *params = args;
    VkValidationCacheCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pValidationCache);

    convert_VkValidationCacheCreateInfoEXT_win32_to_host((const VkValidationCacheCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkCreateValidationCacheEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, NULL, (VkValidationCacheEXT *)UlongToPtr(params->pValidationCache));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateWin32SurfaceKHR(void *args)
{
    struct vkCreateWin32SurfaceKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->instance, params->pCreateInfo, params->pAllocator, params->pSurface);

    params->result = wine_vkCreateWin32SurfaceKHR(params->instance, params->pCreateInfo, params->pAllocator, params->pSurface);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateWin32SurfaceKHR(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSurface;
        VkResult result;
    } *params = args;
    VkWin32SurfaceCreateInfoKHR pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->pCreateInfo, params->pAllocator, params->pSurface);

    convert_VkWin32SurfaceCreateInfoKHR_win32_to_host((const VkWin32SurfaceCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateWin32SurfaceKHR((VkInstance)UlongToPtr(params->instance), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSurfaceKHR *)UlongToPtr(params->pSurface));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDebugMarkerSetObjectNameEXT(void *args)
{
    struct vkDebugMarkerSetObjectNameEXT_params *params = args;
    VkDebugMarkerObjectNameInfoEXT pNameInfo_host;

    TRACE("%p, %p\n", params->device, params->pNameInfo);

    convert_VkDebugMarkerObjectNameInfoEXT_win64_to_host(params->pNameInfo, &pNameInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkDebugMarkerSetObjectNameEXT(wine_device_from_handle(params->device)->device, &pNameInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDebugMarkerSetObjectNameEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pNameInfo;
        VkResult result;
    } *params = args;
    VkDebugMarkerObjectNameInfoEXT pNameInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pNameInfo);

    convert_VkDebugMarkerObjectNameInfoEXT_win32_to_host((const VkDebugMarkerObjectNameInfoEXT32 *)UlongToPtr(params->pNameInfo), &pNameInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDebugMarkerSetObjectNameEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pNameInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDebugMarkerSetObjectTagEXT(void *args)
{
    struct vkDebugMarkerSetObjectTagEXT_params *params = args;
    VkDebugMarkerObjectTagInfoEXT pTagInfo_host;

    TRACE("%p, %p\n", params->device, params->pTagInfo);

    convert_VkDebugMarkerObjectTagInfoEXT_win64_to_host(params->pTagInfo, &pTagInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkDebugMarkerSetObjectTagEXT(wine_device_from_handle(params->device)->device, &pTagInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDebugMarkerSetObjectTagEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pTagInfo;
        VkResult result;
    } *params = args;
    VkDebugMarkerObjectTagInfoEXT pTagInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pTagInfo);

    convert_VkDebugMarkerObjectTagInfoEXT_win32_to_host((const VkDebugMarkerObjectTagInfoEXT32 *)UlongToPtr(params->pTagInfo), &pTagInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDebugMarkerSetObjectTagEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pTagInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDebugReportMessageEXT(void *args)
{
    struct vkDebugReportMessageEXT_params *params = args;

    TRACE("%p, %#x, %#x, 0x%s, 0x%s, %d, %p, %p\n", params->instance, params->flags, params->objectType, wine_dbgstr_longlong(params->object), wine_dbgstr_longlong(params->location), params->messageCode, params->pLayerPrefix, params->pMessage);

    wine_instance_from_handle(params->instance)->funcs.p_vkDebugReportMessageEXT(wine_instance_from_handle(params->instance)->instance, params->flags, params->objectType, wine_vk_unwrap_handle(params->objectType, params->object), params->location, params->messageCode, params->pLayerPrefix, params->pMessage);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDebugReportMessageEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugReportFlagsEXT flags;
        VkDebugReportObjectTypeEXT objectType;
        uint64_t DECLSPEC_ALIGN(8) object;
        PTR32 location;
        int32_t messageCode;
        PTR32 pLayerPrefix;
        PTR32 pMessage;
    } *params = args;

    TRACE("%#x, %#x, %#x, 0x%s, 0x%s, %d, %#x, %#x\n", params->instance, params->flags, params->objectType, wine_dbgstr_longlong(params->object), wine_dbgstr_longlong(params->location), params->messageCode, params->pLayerPrefix, params->pMessage);

    wine_instance_from_handle((VkInstance)UlongToPtr(params->instance))->funcs.p_vkDebugReportMessageEXT(wine_instance_from_handle((VkInstance)UlongToPtr(params->instance))->instance, params->flags, params->objectType, wine_vk_unwrap_handle(params->objectType, params->object), params->location, params->messageCode, (const char *)UlongToPtr(params->pLayerPrefix), (const char *)UlongToPtr(params->pMessage));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDeferredOperationJoinKHR(void *args)
{
    struct vkDeferredOperationJoinKHR_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkDeferredOperationJoinKHR(wine_device_from_handle(params->device)->device, wine_deferred_operation_from_handle(params->operation)->deferred_operation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDeferredOperationJoinKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDeferredOperationJoinKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_deferred_operation_from_handle(params->operation)->deferred_operation);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyAccelerationStructureKHR(void *args)
{
    struct vkDestroyAccelerationStructureKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyAccelerationStructureKHR(wine_device_from_handle(params->device)->device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureKHR DECLSPEC_ALIGN(8) accelerationStructure;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyAccelerationStructureKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyAccelerationStructureNV(void *args)
{
    struct vkDestroyAccelerationStructureNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyAccelerationStructureNV(wine_device_from_handle(params->device)->device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyAccelerationStructureNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyBuffer(void *args)
{
    struct vkDestroyBuffer_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->buffer), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyBuffer(wine_device_from_handle(params->device)->device, params->buffer, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyBuffer(void *args)
{
    struct
    {
        PTR32 device;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->buffer), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyBuffer(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->buffer, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyBufferView(void *args)
{
    struct vkDestroyBufferView_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->bufferView), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyBufferView(wine_device_from_handle(params->device)->device, params->bufferView, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyBufferView(void *args)
{
    struct
    {
        PTR32 device;
        VkBufferView DECLSPEC_ALIGN(8) bufferView;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->bufferView), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyBufferView(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->bufferView, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyCommandPool(void *args)
{
    struct vkDestroyCommandPool_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->commandPool), params->pAllocator);

    wine_vkDestroyCommandPool(params->device, params->commandPool, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->pAllocator);

    wine_vkDestroyCommandPool((VkDevice)UlongToPtr(params->device), params->commandPool, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyCuFunctionNVX(void *args)
{
    struct vkDestroyCuFunctionNVX_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->function), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyCuFunctionNVX(wine_device_from_handle(params->device)->device, params->function, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyCuFunctionNVX(void *args)
{
    struct
    {
        PTR32 device;
        VkCuFunctionNVX DECLSPEC_ALIGN(8) function;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->function), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyCuFunctionNVX(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->function, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyCuModuleNVX(void *args)
{
    struct vkDestroyCuModuleNVX_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->module), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyCuModuleNVX(wine_device_from_handle(params->device)->device, params->module, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyCuModuleNVX(void *args)
{
    struct
    {
        PTR32 device;
        VkCuModuleNVX DECLSPEC_ALIGN(8) module;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->module), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyCuModuleNVX(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->module, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDebugReportCallbackEXT(void *args)
{
    struct vkDestroyDebugReportCallbackEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->callback), params->pAllocator);

    wine_vkDestroyDebugReportCallbackEXT(params->instance, params->callback, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDebugReportCallbackEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugReportCallbackEXT DECLSPEC_ALIGN(8) callback;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->instance, wine_dbgstr_longlong(params->callback), params->pAllocator);

    wine_vkDestroyDebugReportCallbackEXT((VkInstance)UlongToPtr(params->instance), params->callback, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDebugUtilsMessengerEXT(void *args)
{
    struct vkDestroyDebugUtilsMessengerEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->messenger), params->pAllocator);

    wine_vkDestroyDebugUtilsMessengerEXT(params->instance, params->messenger, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDebugUtilsMessengerEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugUtilsMessengerEXT DECLSPEC_ALIGN(8) messenger;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->instance, wine_dbgstr_longlong(params->messenger), params->pAllocator);

    wine_vkDestroyDebugUtilsMessengerEXT((VkInstance)UlongToPtr(params->instance), params->messenger, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDeferredOperationKHR(void *args)
{
    struct vkDestroyDeferredOperationKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->operation), params->pAllocator);

    wine_vkDestroyDeferredOperationKHR(params->device, params->operation, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDeferredOperationKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->operation), params->pAllocator);

    wine_vkDestroyDeferredOperationKHR((VkDevice)UlongToPtr(params->device), params->operation, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorPool(void *args)
{
    struct vkDestroyDescriptorPool_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyDescriptorPool(wine_device_from_handle(params->device)->device, params->descriptorPool, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorPool(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyDescriptorPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorPool, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorSetLayout(void *args)
{
    struct vkDestroyDescriptorSetLayout_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorSetLayout), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyDescriptorSetLayout(wine_device_from_handle(params->device)->device, params->descriptorSetLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorSetLayout(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSetLayout DECLSPEC_ALIGN(8) descriptorSetLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorSetLayout), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyDescriptorSetLayout(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorSetLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorUpdateTemplate(void *args)
{
    struct vkDestroyDescriptorUpdateTemplate_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyDescriptorUpdateTemplate(wine_device_from_handle(params->device)->device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorUpdateTemplate(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyDescriptorUpdateTemplate(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorUpdateTemplateKHR(void *args)
{
    struct vkDestroyDescriptorUpdateTemplateKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyDescriptorUpdateTemplateKHR(wine_device_from_handle(params->device)->device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorUpdateTemplateKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyDescriptorUpdateTemplateKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDevice(void *args)
{
    struct vkDestroyDevice_params *params = args;

    TRACE("%p, %p\n", params->device, params->pAllocator);

    if (!params->device)
        return STATUS_SUCCESS;

    wine_vkDestroyDevice(params->device, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDevice(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, %#x\n", params->device, params->pAllocator);

    if (!params->device)
        return STATUS_SUCCESS;

    wine_vkDestroyDevice((VkDevice)UlongToPtr(params->device), (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyEvent(void *args)
{
    struct vkDestroyEvent_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->event), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyEvent(wine_device_from_handle(params->device)->device, params->event, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyEvent(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->event), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyEvent(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->event, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyFence(void *args)
{
    struct vkDestroyFence_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyFence(wine_device_from_handle(params->device)->device, params->fence, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyFence(void *args)
{
    struct
    {
        PTR32 device;
        VkFence DECLSPEC_ALIGN(8) fence;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyFence(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->fence, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyFramebuffer(void *args)
{
    struct vkDestroyFramebuffer_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyFramebuffer(wine_device_from_handle(params->device)->device, params->framebuffer, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyFramebuffer(void *args)
{
    struct
    {
        PTR32 device;
        VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyFramebuffer(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->framebuffer, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyImage(void *args)
{
    struct vkDestroyImage_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyImage(wine_device_from_handle(params->device)->device, params->image, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyImage(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyImage(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyImageView(void *args)
{
    struct vkDestroyImageView_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->imageView), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyImageView(wine_device_from_handle(params->device)->device, params->imageView, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyImageView(void *args)
{
    struct
    {
        PTR32 device;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->imageView), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyImageView(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->imageView, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyIndirectCommandsLayoutNV(void *args)
{
    struct vkDestroyIndirectCommandsLayoutNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->indirectCommandsLayout), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyIndirectCommandsLayoutNV(wine_device_from_handle(params->device)->device, params->indirectCommandsLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyIndirectCommandsLayoutNV(void *args)
{
    struct
    {
        PTR32 device;
        VkIndirectCommandsLayoutNV DECLSPEC_ALIGN(8) indirectCommandsLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->indirectCommandsLayout), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyIndirectCommandsLayoutNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->indirectCommandsLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyInstance(void *args)
{
    struct vkDestroyInstance_params *params = args;

    TRACE("%p, %p\n", params->instance, params->pAllocator);

    if (!params->instance)
        return STATUS_SUCCESS;

    wine_vkDestroyInstance(params->instance, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyInstance(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, %#x\n", params->instance, params->pAllocator);

    if (!params->instance)
        return STATUS_SUCCESS;

    wine_vkDestroyInstance((VkInstance)UlongToPtr(params->instance), (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyMicromapEXT(void *args)
{
    struct vkDestroyMicromapEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->micromap), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyMicromapEXT(wine_device_from_handle(params->device)->device, params->micromap, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkMicromapEXT DECLSPEC_ALIGN(8) micromap;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->micromap), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyMicromapEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->micromap, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyOpticalFlowSessionNV(void *args)
{
    struct vkDestroyOpticalFlowSessionNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->session), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyOpticalFlowSessionNV(wine_device_from_handle(params->device)->device, params->session, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyOpticalFlowSessionNV(void *args)
{
    struct
    {
        PTR32 device;
        VkOpticalFlowSessionNV DECLSPEC_ALIGN(8) session;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyOpticalFlowSessionNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->session, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipeline(void *args)
{
    struct vkDestroyPipeline_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyPipeline(wine_device_from_handle(params->device)->device, params->pipeline, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipeline(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyPipeline(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipelineCache(void *args)
{
    struct vkDestroyPipelineCache_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyPipelineCache(wine_device_from_handle(params->device)->device, params->pipelineCache, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipelineCache(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyPipelineCache(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipelineCache, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipelineLayout(void *args)
{
    struct vkDestroyPipelineLayout_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipelineLayout), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyPipelineLayout(wine_device_from_handle(params->device)->device, params->pipelineLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipelineLayout(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineLayout DECLSPEC_ALIGN(8) pipelineLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineLayout), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyPipelineLayout(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipelineLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPrivateDataSlot(void *args)
{
    struct vkDestroyPrivateDataSlot_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyPrivateDataSlot(wine_device_from_handle(params->device)->device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPrivateDataSlot(void *args)
{
    struct
    {
        PTR32 device;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyPrivateDataSlot(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPrivateDataSlotEXT(void *args)
{
    struct vkDestroyPrivateDataSlotEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyPrivateDataSlotEXT(wine_device_from_handle(params->device)->device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPrivateDataSlotEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyPrivateDataSlotEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyQueryPool(void *args)
{
    struct vkDestroyQueryPool_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->queryPool), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyQueryPool(wine_device_from_handle(params->device)->device, params->queryPool, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyQueryPool(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->queryPool), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyQueryPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->queryPool, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyRenderPass(void *args)
{
    struct vkDestroyRenderPass_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyRenderPass(wine_device_from_handle(params->device)->device, params->renderPass, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyRenderPass(void *args)
{
    struct
    {
        PTR32 device;
        VkRenderPass DECLSPEC_ALIGN(8) renderPass;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyRenderPass(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->renderPass, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySampler(void *args)
{
    struct vkDestroySampler_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->sampler), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroySampler(wine_device_from_handle(params->device)->device, params->sampler, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySampler(void *args)
{
    struct
    {
        PTR32 device;
        VkSampler DECLSPEC_ALIGN(8) sampler;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->sampler), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroySampler(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->sampler, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySamplerYcbcrConversion(void *args)
{
    struct vkDestroySamplerYcbcrConversion_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroySamplerYcbcrConversion(wine_device_from_handle(params->device)->device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySamplerYcbcrConversion(void *args)
{
    struct
    {
        PTR32 device;
        VkSamplerYcbcrConversion DECLSPEC_ALIGN(8) ycbcrConversion;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroySamplerYcbcrConversion(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySamplerYcbcrConversionKHR(void *args)
{
    struct vkDestroySamplerYcbcrConversionKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroySamplerYcbcrConversionKHR(wine_device_from_handle(params->device)->device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySamplerYcbcrConversionKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSamplerYcbcrConversion DECLSPEC_ALIGN(8) ycbcrConversion;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroySamplerYcbcrConversionKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySemaphore(void *args)
{
    struct vkDestroySemaphore_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);

    wine_vkDestroySemaphore(params->device, params->semaphore, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySemaphore(void *args)
{
    struct
    {
        PTR32 device;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);

    wine_vkDestroySemaphore((VkDevice)UlongToPtr(params->device), params->semaphore, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyShaderEXT(void *args)
{
    struct vkDestroyShaderEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->shader), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyShaderEXT(wine_device_from_handle(params->device)->device, params->shader, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyShaderEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderEXT DECLSPEC_ALIGN(8) shader;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->shader), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyShaderEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->shader, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyShaderModule(void *args)
{
    struct vkDestroyShaderModule_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyShaderModule(wine_device_from_handle(params->device)->device, params->shaderModule, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyShaderModule(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderModule DECLSPEC_ALIGN(8) shaderModule;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyShaderModule(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->shaderModule, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySurfaceKHR(void *args)
{
    struct vkDestroySurfaceKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->surface), params->pAllocator);

    wine_vkDestroySurfaceKHR(params->instance, params->surface, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySurfaceKHR(void *args)
{
    struct
    {
        PTR32 instance;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->instance, wine_dbgstr_longlong(params->surface), params->pAllocator);

    wine_vkDestroySurfaceKHR((VkInstance)UlongToPtr(params->instance), params->surface, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySwapchainKHR(void *args)
{
    struct vkDestroySwapchainKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pAllocator);

    wine_vkDestroySwapchainKHR(params->device, params->swapchain, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySwapchainKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pAllocator);

    wine_vkDestroySwapchainKHR((VkDevice)UlongToPtr(params->device), params->swapchain, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyValidationCacheEXT(void *args)
{
    struct vkDestroyValidationCacheEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pAllocator);

    wine_device_from_handle(params->device)->funcs.p_vkDestroyValidationCacheEXT(wine_device_from_handle(params->device)->device, params->validationCache, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyValidationCacheEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkValidationCacheEXT DECLSPEC_ALIGN(8) validationCache;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pAllocator);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDestroyValidationCacheEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->validationCache, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDeviceWaitIdle(void *args)
{
    struct vkDeviceWaitIdle_params *params = args;

    TRACE("%p\n", params->device);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkDeviceWaitIdle(wine_device_from_handle(params->device)->device);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDeviceWaitIdle(void *args)
{
    struct
    {
        PTR32 device;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->device);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkDeviceWaitIdle(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEndCommandBuffer(void *args)
{
    struct vkEndCommandBuffer_params *params = args;

    TRACE("%p\n", params->commandBuffer);

    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkEndCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEndCommandBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->commandBuffer);

    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkEndCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateDeviceExtensionProperties(void *args)
{
    struct vkEnumerateDeviceExtensionProperties_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceExtensionProperties(params->physicalDevice, params->pLayerName, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateDeviceExtensionProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pLayerName;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceExtensionProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (const char *)UlongToPtr(params->pLayerName), (uint32_t *)UlongToPtr(params->pPropertyCount), (VkExtensionProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateDeviceLayerProperties(void *args)
{
    struct vkEnumerateDeviceLayerProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceLayerProperties(params->physicalDevice, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateDeviceLayerProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceLayerProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (uint32_t *)UlongToPtr(params->pPropertyCount), (VkLayerProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateInstanceExtensionProperties(void *args)
{
    struct vkEnumerateInstanceExtensionProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateInstanceExtensionProperties(params->pLayerName, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateInstanceExtensionProperties(void *args)
{
    struct
    {
        PTR32 pLayerName;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateInstanceExtensionProperties((const char *)UlongToPtr(params->pLayerName), (uint32_t *)UlongToPtr(params->pPropertyCount), (VkExtensionProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateInstanceVersion(void *args)
{
    struct vkEnumerateInstanceVersion_params *params = args;

    TRACE("%p\n", params->pApiVersion);

    params->result = wine_vkEnumerateInstanceVersion(params->pApiVersion);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateInstanceVersion(void *args)
{
    struct
    {
        PTR32 pApiVersion;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->pApiVersion);

    params->result = wine_vkEnumerateInstanceVersion((uint32_t *)UlongToPtr(params->pApiVersion));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDeviceGroups(void *args)
{
    struct vkEnumeratePhysicalDeviceGroups_params *params = args;

    TRACE("%p, %p, %p\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    params->result = wine_vkEnumeratePhysicalDeviceGroups(params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDeviceGroups(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pPhysicalDeviceGroupCount;
        PTR32 pPhysicalDeviceGroupProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    init_conversion_context(ctx);
    pPhysicalDeviceGroupProperties_host = convert_VkPhysicalDeviceGroupProperties_array_win32_to_unwrapped_host(ctx, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    params->result = wine_vkEnumeratePhysicalDeviceGroups((VkInstance)UlongToPtr(params->instance), (uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount), pPhysicalDeviceGroupProperties_host);
    convert_VkPhysicalDeviceGroupProperties_array_unwrapped_host_to_win32(pPhysicalDeviceGroupProperties_host, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDeviceGroupsKHR(void *args)
{
    struct vkEnumeratePhysicalDeviceGroupsKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    params->result = wine_vkEnumeratePhysicalDeviceGroupsKHR(params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDeviceGroupsKHR(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pPhysicalDeviceGroupCount;
        PTR32 pPhysicalDeviceGroupProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    init_conversion_context(ctx);
    pPhysicalDeviceGroupProperties_host = convert_VkPhysicalDeviceGroupProperties_array_win32_to_unwrapped_host(ctx, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    params->result = wine_vkEnumeratePhysicalDeviceGroupsKHR((VkInstance)UlongToPtr(params->instance), (uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount), pPhysicalDeviceGroupProperties_host);
    convert_VkPhysicalDeviceGroupProperties_array_unwrapped_host_to_win32(pPhysicalDeviceGroupProperties_host, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(void *args)
{
    struct vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->physicalDevice, params->queueFamilyIndex, params->pCounterCount, params->pCounters, params->pCounterDescriptions);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->queueFamilyIndex, params->pCounterCount, params->pCounters, params->pCounterDescriptions);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        PTR32 pCounterCount;
        PTR32 pCounters;
        PTR32 pCounterDescriptions;
        VkResult result;
    } *params = args;
    VkPerformanceCounterKHR *pCounters_host;
    VkPerformanceCounterDescriptionKHR *pCounterDescriptions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->physicalDevice, params->queueFamilyIndex, params->pCounterCount, params->pCounters, params->pCounterDescriptions);

    init_conversion_context(ctx);
    pCounters_host = convert_VkPerformanceCounterKHR_array_win32_to_host(ctx, (VkPerformanceCounterKHR32 *)UlongToPtr(params->pCounters), *(uint32_t *)UlongToPtr(params->pCounterCount));
    pCounterDescriptions_host = convert_VkPerformanceCounterDescriptionKHR_array_win32_to_host(ctx, (VkPerformanceCounterDescriptionKHR32 *)UlongToPtr(params->pCounterDescriptions), *(uint32_t *)UlongToPtr(params->pCounterCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->queueFamilyIndex, (uint32_t *)UlongToPtr(params->pCounterCount), pCounters_host, pCounterDescriptions_host);
    convert_VkPerformanceCounterKHR_array_host_to_win32(pCounters_host, (VkPerformanceCounterKHR32 *)UlongToPtr(params->pCounters), *(uint32_t *)UlongToPtr(params->pCounterCount));
    convert_VkPerformanceCounterDescriptionKHR_array_host_to_win32(pCounterDescriptions_host, (VkPerformanceCounterDescriptionKHR32 *)UlongToPtr(params->pCounterDescriptions), *(uint32_t *)UlongToPtr(params->pCounterCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDevices(void *args)
{
    struct vkEnumeratePhysicalDevices_params *params = args;

    TRACE("%p, %p, %p\n", params->instance, params->pPhysicalDeviceCount, params->pPhysicalDevices);

    params->result = wine_vkEnumeratePhysicalDevices(params->instance, params->pPhysicalDeviceCount, params->pPhysicalDevices);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDevices(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pPhysicalDeviceCount;
        PTR32 pPhysicalDevices;
        VkResult result;
    } *params = args;
    VkPhysicalDevice *pPhysicalDevices_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->instance, params->pPhysicalDeviceCount, params->pPhysicalDevices);

    init_conversion_context(ctx);
    pPhysicalDevices_host = (params->pPhysicalDevices && *(uint32_t *)UlongToPtr(params->pPhysicalDeviceCount)) ? conversion_context_alloc(ctx, sizeof(*pPhysicalDevices_host) * *(uint32_t *)UlongToPtr(params->pPhysicalDeviceCount)) : NULL;
    params->result = wine_vkEnumeratePhysicalDevices((VkInstance)UlongToPtr(params->instance), (uint32_t *)UlongToPtr(params->pPhysicalDeviceCount), pPhysicalDevices_host);
    convert_VkPhysicalDevice_array_unwrapped_host_to_win32(pPhysicalDevices_host, (PTR32 *)UlongToPtr(params->pPhysicalDevices), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFlushMappedMemoryRanges(void *args)
{
    struct vkFlushMappedMemoryRanges_params *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win64_to_host(ctx, params->pMemoryRanges, params->memoryRangeCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkFlushMappedMemoryRanges(wine_device_from_handle(params->device)->device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFlushMappedMemoryRanges(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t memoryRangeCount;
        PTR32 pMemoryRanges;
        VkResult result;
    } *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win32_to_host(ctx, (const VkMappedMemoryRange32 *)UlongToPtr(params->pMemoryRanges), params->memoryRangeCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkFlushMappedMemoryRanges(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFreeCommandBuffers(void *args)
{
    struct vkFreeCommandBuffers_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->commandPool), params->commandBufferCount, params->pCommandBuffers);

    wine_vkFreeCommandBuffers(params->device, params->commandPool, params->commandBufferCount, params->pCommandBuffers);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFreeCommandBuffers(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        uint32_t commandBufferCount;
        PTR32 pCommandBuffers;
    } *params = args;
    const VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->commandBufferCount, params->pCommandBuffers);

    init_conversion_context(ctx);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(params->pCommandBuffers), params->commandBufferCount);
    wine_vkFreeCommandBuffers((VkDevice)UlongToPtr(params->device), params->commandPool, params->commandBufferCount, pCommandBuffers_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFreeDescriptorSets(void *args)
{
    struct vkFreeDescriptorSets_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->descriptorSetCount, params->pDescriptorSets);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkFreeDescriptorSets(wine_device_from_handle(params->device)->device, params->descriptorPool, params->descriptorSetCount, params->pDescriptorSets);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFreeDescriptorSets(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
        uint32_t descriptorSetCount;
        PTR32 pDescriptorSets;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->descriptorSetCount, params->pDescriptorSets);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkFreeDescriptorSets(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorPool, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFreeMemory(void *args)
{
    struct vkFreeMemory_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);

    wine_vkFreeMemory(params->device, params->memory, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFreeMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);

    wine_vkFreeMemory((VkDevice)UlongToPtr(params->device), params->memory, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureBuildSizesKHR(void *args)
{
    struct vkGetAccelerationStructureBuildSizesKHR_params *params = args;

    TRACE("%p, %#x, %p, %p, %p\n", params->device, params->buildType, params->pBuildInfo, params->pMaxPrimitiveCounts, params->pSizeInfo);

    wine_device_from_handle(params->device)->funcs.p_vkGetAccelerationStructureBuildSizesKHR(wine_device_from_handle(params->device)->device, params->buildType, params->pBuildInfo, params->pMaxPrimitiveCounts, params->pSizeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureBuildSizesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureBuildTypeKHR buildType;
        PTR32 pBuildInfo;
        PTR32 pMaxPrimitiveCounts;
        PTR32 pSizeInfo;
    } *params = args;
    VkAccelerationStructureBuildGeometryInfoKHR pBuildInfo_host;
    VkAccelerationStructureBuildSizesInfoKHR pSizeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x, %#x\n", params->device, params->buildType, params->pBuildInfo, params->pMaxPrimitiveCounts, params->pSizeInfo);

    init_conversion_context(ctx);
    convert_VkAccelerationStructureBuildGeometryInfoKHR_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_win32_to_host((VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo), &pSizeInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetAccelerationStructureBuildSizesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->buildType, &pBuildInfo_host, (const uint32_t *)UlongToPtr(params->pMaxPrimitiveCounts), &pSizeInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_host_to_win32(&pSizeInfo_host, (VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureDeviceAddressKHR(void *args)
{
    struct vkGetAccelerationStructureDeviceAddressKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetAccelerationStructureDeviceAddressKHR(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureDeviceAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkAccelerationStructureDeviceAddressInfoKHR pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkAccelerationStructureDeviceAddressInfoKHR_win32_to_host((const VkAccelerationStructureDeviceAddressInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetAccelerationStructureDeviceAddressKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureHandleNV(void *args)
{
    struct vkGetAccelerationStructureHandleNV_params *params = args;

    TRACE("%p, 0x%s, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetAccelerationStructureHandleNV(wine_device_from_handle(params->device)->device, params->accelerationStructure, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureHandleNV(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetAccelerationStructureHandleNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->accelerationStructure, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureMemoryRequirementsNV(void *args)
{
    struct vkGetAccelerationStructureMemoryRequirementsNV_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetAccelerationStructureMemoryRequirementsNV(wine_device_from_handle(params->device)->device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureMemoryRequirementsNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkAccelerationStructureMemoryRequirementsInfoNV pInfo_host;
    VkMemoryRequirements2KHR pMemoryRequirements_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    convert_VkAccelerationStructureMemoryRequirementsInfoNV_win32_to_host((const VkAccelerationStructureMemoryRequirementsInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2KHR_win32_to_host((VkMemoryRequirements2KHR32 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetAccelerationStructureMemoryRequirementsNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2KHR_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements2KHR32 *)UlongToPtr(params->pMemoryRequirements));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(wine_device_from_handle(params->device)->device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkAccelerationStructureCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkAccelerationStructureCaptureDescriptorDataInfoEXT_win32_to_host((const VkAccelerationStructureCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferDeviceAddress(void *args)
{
    struct vkGetBufferDeviceAddress_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetBufferDeviceAddress(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferDeviceAddress(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferDeviceAddress(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferDeviceAddressEXT(void *args)
{
    struct vkGetBufferDeviceAddressEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetBufferDeviceAddressEXT(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferDeviceAddressEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferDeviceAddressEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferDeviceAddressKHR(void *args)
{
    struct vkGetBufferDeviceAddressKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetBufferDeviceAddressKHR(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferDeviceAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferDeviceAddressKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferMemoryRequirements(void *args)
{
    struct vkGetBufferMemoryRequirements_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->buffer), params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetBufferMemoryRequirements(wine_device_from_handle(params->device)->device, params->buffer, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkMemoryRequirements pMemoryRequirements_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->buffer), params->pMemoryRequirements);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferMemoryRequirements(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->buffer, &pMemoryRequirements_host);
    convert_VkMemoryRequirements_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements32 *)UlongToPtr(params->pMemoryRequirements));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferMemoryRequirements2(void *args)
{
    struct vkGetBufferMemoryRequirements2_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetBufferMemoryRequirements2(wine_device_from_handle(params->device)->device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferMemoryRequirements2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkBufferMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkBufferMemoryRequirementsInfo2_win32_to_host((const VkBufferMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferMemoryRequirements2(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferMemoryRequirements2KHR(void *args)
{
    struct vkGetBufferMemoryRequirements2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetBufferMemoryRequirements2KHR(wine_device_from_handle(params->device)->device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferMemoryRequirements2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkBufferMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkBufferMemoryRequirementsInfo2_win32_to_host((const VkBufferMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferMemoryRequirements2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferOpaqueCaptureAddress(void *args)
{
    struct vkGetBufferOpaqueCaptureAddress_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetBufferOpaqueCaptureAddress(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferOpaqueCaptureAddress(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferOpaqueCaptureAddress(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferOpaqueCaptureAddressKHR(void *args)
{
    struct vkGetBufferOpaqueCaptureAddressKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetBufferOpaqueCaptureAddressKHR(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferOpaqueCaptureAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferOpaqueCaptureAddressKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetBufferOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetBufferOpaqueCaptureDescriptorDataEXT(wine_device_from_handle(params->device)->device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkBufferCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkBufferCaptureDescriptorDataInfoEXT_win32_to_host((const VkBufferCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetBufferOpaqueCaptureDescriptorDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetCalibratedTimestampsEXT(void *args)
{
    struct vkGetCalibratedTimestampsEXT_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);

    params->result = wine_vkGetCalibratedTimestampsEXT(params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetCalibratedTimestampsEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t timestampCount;
        PTR32 pTimestampInfos;
        PTR32 pTimestamps;
        PTR32 pMaxDeviation;
        VkResult result;
    } *params = args;
    const VkCalibratedTimestampInfoEXT *pTimestampInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);

    init_conversion_context(ctx);
    pTimestampInfos_host = convert_VkCalibratedTimestampInfoEXT_array_win32_to_host(ctx, (const VkCalibratedTimestampInfoEXT32 *)UlongToPtr(params->pTimestampInfos), params->timestampCount);
    params->result = wine_vkGetCalibratedTimestampsEXT((VkDevice)UlongToPtr(params->device), params->timestampCount, pTimestampInfos_host, (uint64_t *)UlongToPtr(params->pTimestamps), (uint64_t *)UlongToPtr(params->pMaxDeviation));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeferredOperationMaxConcurrencyKHR(void *args)
{
    struct vkGetDeferredOperationMaxConcurrencyKHR_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeferredOperationMaxConcurrencyKHR(wine_device_from_handle(params->device)->device, wine_deferred_operation_from_handle(params->operation)->deferred_operation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeferredOperationMaxConcurrencyKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        uint32_t result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeferredOperationMaxConcurrencyKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_deferred_operation_from_handle(params->operation)->deferred_operation);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeferredOperationResultKHR(void *args)
{
    struct vkGetDeferredOperationResultKHR_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeferredOperationResultKHR(wine_device_from_handle(params->device)->device, wine_deferred_operation_from_handle(params->operation)->deferred_operation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeferredOperationResultKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeferredOperationResultKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_deferred_operation_from_handle(params->operation)->deferred_operation);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkGetDescriptorEXT(void *args)
{
    struct vkGetDescriptorEXT_params *params = args;

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorEXT(wine_device_from_handle(params->device)->device, params->pDescriptorInfo, params->dataSize, params->pDescriptor);
}
#endif /* _WIN64 */

static void thunk32_vkGetDescriptorEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pDescriptorInfo;
        PTR32 dataSize;
        PTR32 pDescriptor;
    } *params = args;
    VkDescriptorGetInfoEXT pDescriptorInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDescriptorGetInfoEXT_win32_to_host(ctx, (const VkDescriptorGetInfoEXT32 *)UlongToPtr(params->pDescriptorInfo), &pDescriptorInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pDescriptorInfo_host, params->dataSize, (void *)UlongToPtr(params->pDescriptor));
    free_conversion_context(ctx);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetHostMappingVALVE(void *args)
{
    struct vkGetDescriptorSetHostMappingVALVE_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorSet), params->ppData);

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorSetHostMappingVALVE(wine_device_from_handle(params->device)->device, params->descriptorSet, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetHostMappingVALVE(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSet DECLSPEC_ALIGN(8) descriptorSet;
        PTR32 ppData;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorSet), params->ppData);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorSetHostMappingVALVE(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorSet, (void **)UlongToPtr(params->ppData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutBindingOffsetEXT(void *args)
{
    struct vkGetDescriptorSetLayoutBindingOffsetEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->layout), params->binding, params->pOffset);

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorSetLayoutBindingOffsetEXT(wine_device_from_handle(params->device)->device, params->layout, params->binding, params->pOffset);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutBindingOffsetEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSetLayout DECLSPEC_ALIGN(8) layout;
        uint32_t binding;
        PTR32 pOffset;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->layout), params->binding, params->pOffset);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorSetLayoutBindingOffsetEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->layout, params->binding, (VkDeviceSize *)UlongToPtr(params->pOffset));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutHostMappingInfoVALVE(void *args)
{
    struct vkGetDescriptorSetLayoutHostMappingInfoVALVE_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pBindingReference, params->pHostMapping);

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorSetLayoutHostMappingInfoVALVE(wine_device_from_handle(params->device)->device, params->pBindingReference, params->pHostMapping);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutHostMappingInfoVALVE(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pBindingReference;
        PTR32 pHostMapping;
    } *params = args;
    VkDescriptorSetBindingReferenceVALVE pBindingReference_host;
    VkDescriptorSetLayoutHostMappingInfoVALVE pHostMapping_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pBindingReference, params->pHostMapping);

    convert_VkDescriptorSetBindingReferenceVALVE_win32_to_host((const VkDescriptorSetBindingReferenceVALVE32 *)UlongToPtr(params->pBindingReference), &pBindingReference_host);
    convert_VkDescriptorSetLayoutHostMappingInfoVALVE_win32_to_host((VkDescriptorSetLayoutHostMappingInfoVALVE32 *)UlongToPtr(params->pHostMapping), &pHostMapping_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorSetLayoutHostMappingInfoVALVE(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pBindingReference_host, &pHostMapping_host);
    convert_VkDescriptorSetLayoutHostMappingInfoVALVE_host_to_win32(&pHostMapping_host, (VkDescriptorSetLayoutHostMappingInfoVALVE32 *)UlongToPtr(params->pHostMapping));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutSizeEXT(void *args)
{
    struct vkGetDescriptorSetLayoutSizeEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->layout), params->pLayoutSizeInBytes);

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorSetLayoutSizeEXT(wine_device_from_handle(params->device)->device, params->layout, params->pLayoutSizeInBytes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutSizeEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSetLayout DECLSPEC_ALIGN(8) layout;
        PTR32 pLayoutSizeInBytes;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->layout), params->pLayoutSizeInBytes);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorSetLayoutSizeEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->layout, (VkDeviceSize *)UlongToPtr(params->pLayoutSizeInBytes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutSupport(void *args)
{
    struct vkGetDescriptorSetLayoutSupport_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pSupport);

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorSetLayoutSupport(wine_device_from_handle(params->device)->device, params->pCreateInfo, params->pSupport);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutSupport(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pSupport;
    } *params = args;
    VkDescriptorSetLayoutCreateInfo pCreateInfo_host;
    VkDescriptorSetLayoutSupport pSupport_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pSupport);

    init_conversion_context(ctx);
    convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(ctx, (const VkDescriptorSetLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkDescriptorSetLayoutSupport_win32_to_host(ctx, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport), &pSupport_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorSetLayoutSupport(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, &pSupport_host);
    convert_VkDescriptorSetLayoutSupport_host_to_win32(&pSupport_host, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutSupportKHR(void *args)
{
    struct vkGetDescriptorSetLayoutSupportKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pSupport);

    wine_device_from_handle(params->device)->funcs.p_vkGetDescriptorSetLayoutSupportKHR(wine_device_from_handle(params->device)->device, params->pCreateInfo, params->pSupport);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutSupportKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pSupport;
    } *params = args;
    VkDescriptorSetLayoutCreateInfo pCreateInfo_host;
    VkDescriptorSetLayoutSupport pSupport_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pSupport);

    init_conversion_context(ctx);
    convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(ctx, (const VkDescriptorSetLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkDescriptorSetLayoutSupport_win32_to_host(ctx, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport), &pSupport_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDescriptorSetLayoutSupportKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, &pSupport_host);
    convert_VkDescriptorSetLayoutSupport_host_to_win32(&pSupport_host, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceAccelerationStructureCompatibilityKHR(void *args)
{
    struct vkGetDeviceAccelerationStructureCompatibilityKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pVersionInfo, params->pCompatibility);

    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceAccelerationStructureCompatibilityKHR(wine_device_from_handle(params->device)->device, params->pVersionInfo, params->pCompatibility);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceAccelerationStructureCompatibilityKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pVersionInfo;
        PTR32 pCompatibility;
    } *params = args;
    VkAccelerationStructureVersionInfoKHR pVersionInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pVersionInfo, params->pCompatibility);

    convert_VkAccelerationStructureVersionInfoKHR_win32_to_host((const VkAccelerationStructureVersionInfoKHR32 *)UlongToPtr(params->pVersionInfo), &pVersionInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceAccelerationStructureCompatibilityKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pVersionInfo_host, (VkAccelerationStructureCompatibilityKHR *)UlongToPtr(params->pCompatibility));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceBufferMemoryRequirements(void *args)
{
    struct vkGetDeviceBufferMemoryRequirements_params *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceBufferMemoryRequirements(wine_device_from_handle(params->device)->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceBufferMemoryRequirements(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
{
    struct vkGetDeviceBufferMemoryRequirementsKHR_params *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceBufferMemoryRequirementsKHR(wine_device_from_handle(params->device)->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceBufferMemoryRequirementsKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceFaultInfoEXT(void *args)
{
    struct vkGetDeviceFaultInfoEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pFaultCounts, params->pFaultInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeviceFaultInfoEXT(wine_device_from_handle(params->device)->device, params->pFaultCounts, params->pFaultInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceFaultInfoEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pFaultCounts;
        PTR32 pFaultInfo;
        VkResult result;
    } *params = args;
    VkDeviceFaultCountsEXT pFaultCounts_host;
    VkDeviceFaultInfoEXT *pFaultInfo_host = NULL;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pFaultCounts, params->pFaultInfo);

    init_conversion_context(ctx);
    convert_VkDeviceFaultCountsEXT_win32_to_host((VkDeviceFaultCountsEXT32 *)UlongToPtr(params->pFaultCounts), &pFaultCounts_host);
    if (params->pFaultInfo)
    {
        pFaultInfo_host = conversion_context_alloc(ctx, sizeof(*pFaultInfo_host));
        convert_VkDeviceFaultInfoEXT_win32_to_host(ctx, (VkDeviceFaultInfoEXT32 *)UlongToPtr(params->pFaultInfo), pFaultInfo_host);
    }
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceFaultInfoEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pFaultCounts_host, pFaultInfo_host);
    convert_VkDeviceFaultCountsEXT_host_to_win32(&pFaultCounts_host, (VkDeviceFaultCountsEXT32 *)UlongToPtr(params->pFaultCounts));
    convert_VkDeviceFaultInfoEXT_host_to_win32(pFaultInfo_host, (VkDeviceFaultInfoEXT32 *)UlongToPtr(params->pFaultInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupPeerMemoryFeatures(void *args)
{
    struct vkGetDeviceGroupPeerMemoryFeatures_params *params = args;

    TRACE("%p, %u, %u, %u, %p\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceGroupPeerMemoryFeatures(wine_device_from_handle(params->device)->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupPeerMemoryFeatures(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t heapIndex;
        uint32_t localDeviceIndex;
        uint32_t remoteDeviceIndex;
        PTR32 pPeerMemoryFeatures;
    } *params = args;

    TRACE("%#x, %u, %u, %u, %#x\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceGroupPeerMemoryFeatures(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, (VkPeerMemoryFeatureFlags *)UlongToPtr(params->pPeerMemoryFeatures));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupPeerMemoryFeaturesKHR(void *args)
{
    struct vkGetDeviceGroupPeerMemoryFeaturesKHR_params *params = args;

    TRACE("%p, %u, %u, %u, %p\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceGroupPeerMemoryFeaturesKHR(wine_device_from_handle(params->device)->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupPeerMemoryFeaturesKHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t heapIndex;
        uint32_t localDeviceIndex;
        uint32_t remoteDeviceIndex;
        PTR32 pPeerMemoryFeatures;
    } *params = args;

    TRACE("%#x, %u, %u, %u, %#x\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceGroupPeerMemoryFeaturesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, (VkPeerMemoryFeatureFlags *)UlongToPtr(params->pPeerMemoryFeatures));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupPresentCapabilitiesKHR(void *args)
{
    struct vkGetDeviceGroupPresentCapabilitiesKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pDeviceGroupPresentCapabilities);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeviceGroupPresentCapabilitiesKHR(wine_device_from_handle(params->device)->device, params->pDeviceGroupPresentCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupPresentCapabilitiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pDeviceGroupPresentCapabilities;
        VkResult result;
    } *params = args;
    VkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities_host;

    TRACE("%#x, %#x\n", params->device, params->pDeviceGroupPresentCapabilities);

    convert_VkDeviceGroupPresentCapabilitiesKHR_win32_to_host((VkDeviceGroupPresentCapabilitiesKHR32 *)UlongToPtr(params->pDeviceGroupPresentCapabilities), &pDeviceGroupPresentCapabilities_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceGroupPresentCapabilitiesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pDeviceGroupPresentCapabilities_host);
    convert_VkDeviceGroupPresentCapabilitiesKHR_host_to_win32(&pDeviceGroupPresentCapabilities_host, (VkDeviceGroupPresentCapabilitiesKHR32 *)UlongToPtr(params->pDeviceGroupPresentCapabilities));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupSurfacePresentModesKHR(void *args)
{
    struct vkGetDeviceGroupSurfacePresentModesKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->surface), params->pModes);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeviceGroupSurfacePresentModesKHR(wine_device_from_handle(params->device)->device, wine_surface_from_handle(params->surface)->driver_surface, params->pModes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupSurfacePresentModesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pModes;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->surface), params->pModes);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceGroupSurfacePresentModesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_surface_from_handle(params->surface)->driver_surface, (VkDeviceGroupPresentModeFlagsKHR *)UlongToPtr(params->pModes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageMemoryRequirements(void *args)
{
    struct vkGetDeviceImageMemoryRequirements_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceImageMemoryRequirements(wine_device_from_handle(params->device)->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceImageMemoryRequirements(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageMemoryRequirementsKHR(void *args)
{
    struct vkGetDeviceImageMemoryRequirementsKHR_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceImageMemoryRequirementsKHR(wine_device_from_handle(params->device)->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceImageMemoryRequirementsKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSparseMemoryRequirements(void *args)
{
    struct vkGetDeviceImageSparseMemoryRequirements_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceImageSparseMemoryRequirements(wine_device_from_handle(params->device)->device, &pInfo_host, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSparseMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceImageSparseMemoryRequirements(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSparseMemoryRequirementsKHR(void *args)
{
    struct vkGetDeviceImageSparseMemoryRequirementsKHR_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceImageSparseMemoryRequirementsKHR(wine_device_from_handle(params->device)->device, &pInfo_host, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSparseMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceImageSparseMemoryRequirementsKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSubresourceLayoutKHR(void *args)
{
    struct vkGetDeviceImageSubresourceLayoutKHR_params *params = args;
    VkDeviceImageSubresourceInfoKHR pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pLayout);

    init_conversion_context(ctx);
    convert_VkDeviceImageSubresourceInfoKHR_win64_to_host(ctx, params->pInfo, &pInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceImageSubresourceLayoutKHR(wine_device_from_handle(params->device)->device, &pInfo_host, params->pLayout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSubresourceLayoutKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pLayout;
    } *params = args;
    VkDeviceImageSubresourceInfoKHR pInfo_host;
    VkSubresourceLayout2KHR pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pLayout);

    init_conversion_context(ctx);
    convert_VkDeviceImageSubresourceInfoKHR_win32_to_host(ctx, (const VkDeviceImageSubresourceInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkSubresourceLayout2KHR_win32_to_host(ctx, (VkSubresourceLayout2KHR32 *)UlongToPtr(params->pLayout), &pLayout_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceImageSubresourceLayoutKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pLayout_host);
    convert_VkSubresourceLayout2KHR_host_to_win32(&pLayout_host, (VkSubresourceLayout2KHR32 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMemoryCommitment(void *args)
{
    struct vkGetDeviceMemoryCommitment_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);

    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceMemoryCommitment(wine_device_from_handle(params->device)->device, wine_device_memory_from_handle(params->memory)->memory, params->pCommittedMemoryInBytes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMemoryCommitment(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        PTR32 pCommittedMemoryInBytes;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceMemoryCommitment(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_device_memory_from_handle(params->memory)->memory, (VkDeviceSize *)UlongToPtr(params->pCommittedMemoryInBytes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMemoryOpaqueCaptureAddress(void *args)
{
    struct vkGetDeviceMemoryOpaqueCaptureAddress_params *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%p, %p\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win64_to_host(params->pInfo, &pInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeviceMemoryOpaqueCaptureAddress(wine_device_from_handle(params->device)->device, &pInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMemoryOpaqueCaptureAddress(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host((const VkDeviceMemoryOpaqueCaptureAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceMemoryOpaqueCaptureAddress(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMemoryOpaqueCaptureAddressKHR(void *args)
{
    struct vkGetDeviceMemoryOpaqueCaptureAddressKHR_params *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%p, %p\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win64_to_host(params->pInfo, &pInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeviceMemoryOpaqueCaptureAddressKHR(wine_device_from_handle(params->device)->device, &pInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMemoryOpaqueCaptureAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host((const VkDeviceMemoryOpaqueCaptureAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceMemoryOpaqueCaptureAddressKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMicromapCompatibilityEXT(void *args)
{
    struct vkGetDeviceMicromapCompatibilityEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pVersionInfo, params->pCompatibility);

    wine_device_from_handle(params->device)->funcs.p_vkGetDeviceMicromapCompatibilityEXT(wine_device_from_handle(params->device)->device, params->pVersionInfo, params->pCompatibility);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMicromapCompatibilityEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pVersionInfo;
        PTR32 pCompatibility;
    } *params = args;
    VkMicromapVersionInfoEXT pVersionInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pVersionInfo, params->pCompatibility);

    convert_VkMicromapVersionInfoEXT_win32_to_host((const VkMicromapVersionInfoEXT32 *)UlongToPtr(params->pVersionInfo), &pVersionInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceMicromapCompatibilityEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pVersionInfo_host, (VkAccelerationStructureCompatibilityKHR *)UlongToPtr(params->pCompatibility));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceQueue(void *args)
{
    struct vkGetDeviceQueue_params *params = args;

    TRACE("%p, %u, %u, %p\n", params->device, params->queueFamilyIndex, params->queueIndex, params->pQueue);

    wine_vkGetDeviceQueue(params->device, params->queueFamilyIndex, params->queueIndex, params->pQueue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceQueue(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t queueFamilyIndex;
        uint32_t queueIndex;
        PTR32 pQueue;
    } *params = args;
    VkQueue pQueue_host;

    TRACE("%#x, %u, %u, %#x\n", params->device, params->queueFamilyIndex, params->queueIndex, params->pQueue);

    pQueue_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pQueue));
    wine_vkGetDeviceQueue((VkDevice)UlongToPtr(params->device), params->queueFamilyIndex, params->queueIndex, &pQueue_host);
    *(PTR32 *)UlongToPtr(params->pQueue) = PtrToUlong(pQueue_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceQueue2(void *args)
{
    struct vkGetDeviceQueue2_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pQueueInfo, params->pQueue);

    wine_vkGetDeviceQueue2(params->device, params->pQueueInfo, params->pQueue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceQueue2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pQueueInfo;
        PTR32 pQueue;
    } *params = args;
    VkDeviceQueueInfo2 pQueueInfo_host;
    VkQueue pQueue_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pQueueInfo, params->pQueue);

    convert_VkDeviceQueueInfo2_win32_to_host((const VkDeviceQueueInfo232 *)UlongToPtr(params->pQueueInfo), &pQueueInfo_host);
    pQueue_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pQueue));
    wine_vkGetDeviceQueue2((VkDevice)UlongToPtr(params->device), &pQueueInfo_host, &pQueue_host);
    *(PTR32 *)UlongToPtr(params->pQueue) = PtrToUlong(pQueue_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(void *args)
{
    struct vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->renderpass), params->pMaxWorkgroupSize);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(wine_device_from_handle(params->device)->device, params->renderpass, params->pMaxWorkgroupSize);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(void *args)
{
    struct
    {
        PTR32 device;
        VkRenderPass DECLSPEC_ALIGN(8) renderpass;
        PTR32 pMaxWorkgroupSize;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->renderpass), params->pMaxWorkgroupSize);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->renderpass, (VkExtent2D *)UlongToPtr(params->pMaxWorkgroupSize));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDynamicRenderingTilePropertiesQCOM(void *args)
{
    struct vkGetDynamicRenderingTilePropertiesQCOM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pRenderingInfo, params->pProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetDynamicRenderingTilePropertiesQCOM(wine_device_from_handle(params->device)->device, params->pRenderingInfo, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDynamicRenderingTilePropertiesQCOM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pRenderingInfo;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkRenderingInfo pRenderingInfo_host;
    VkTilePropertiesQCOM pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pRenderingInfo, params->pProperties);

    init_conversion_context(ctx);
    convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
    convert_VkTilePropertiesQCOM_win32_to_host((VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties), &pProperties_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetDynamicRenderingTilePropertiesQCOM(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pRenderingInfo_host, &pProperties_host);
    convert_VkTilePropertiesQCOM_host_to_win32(&pProperties_host, (VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetEventStatus(void *args)
{
    struct vkGetEventStatus_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetEventStatus(wine_device_from_handle(params->device)->device, params->event);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetEventStatus(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetEventStatus(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->event);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetFenceStatus(void *args)
{
    struct vkGetFenceStatus_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetFenceStatus(wine_device_from_handle(params->device)->device, params->fence);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetFenceStatus(void *args)
{
    struct
    {
        PTR32 device;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetFenceStatus(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->fence);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetFramebufferTilePropertiesQCOM(void *args)
{
    struct vkGetFramebufferTilePropertiesQCOM_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pPropertiesCount, params->pProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetFramebufferTilePropertiesQCOM(wine_device_from_handle(params->device)->device, params->framebuffer, params->pPropertiesCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetFramebufferTilePropertiesQCOM(void *args)
{
    struct
    {
        PTR32 device;
        VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
        PTR32 pPropertiesCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkTilePropertiesQCOM *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pPropertiesCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkTilePropertiesQCOM_array_win32_to_host(ctx, (VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertiesCount));
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetFramebufferTilePropertiesQCOM(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->framebuffer, (uint32_t *)UlongToPtr(params->pPropertiesCount), pProperties_host);
    convert_VkTilePropertiesQCOM_array_host_to_win32(pProperties_host, (VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertiesCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetGeneratedCommandsMemoryRequirementsNV(void *args)
{
    struct vkGetGeneratedCommandsMemoryRequirementsNV_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetGeneratedCommandsMemoryRequirementsNV(wine_device_from_handle(params->device)->device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetGeneratedCommandsMemoryRequirementsNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkGeneratedCommandsMemoryRequirementsInfoNV pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsMemoryRequirementsInfoNV_win32_to_host((const VkGeneratedCommandsMemoryRequirementsInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetGeneratedCommandsMemoryRequirementsNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageMemoryRequirements(void *args)
{
    struct vkGetImageMemoryRequirements_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageMemoryRequirements(wine_device_from_handle(params->device)->device, params->image, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkMemoryRequirements pMemoryRequirements_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pMemoryRequirements);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageMemoryRequirements(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, &pMemoryRequirements_host);
    convert_VkMemoryRequirements_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements32 *)UlongToPtr(params->pMemoryRequirements));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageMemoryRequirements2(void *args)
{
    struct vkGetImageMemoryRequirements2_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageMemoryRequirements2(wine_device_from_handle(params->device)->device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageMemoryRequirements2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkImageMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageMemoryRequirementsInfo2_win32_to_host(ctx, (const VkImageMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageMemoryRequirements2(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageMemoryRequirements2KHR(void *args)
{
    struct vkGetImageMemoryRequirements2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageMemoryRequirements2KHR(wine_device_from_handle(params->device)->device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageMemoryRequirements2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkImageMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageMemoryRequirementsInfo2_win32_to_host(ctx, (const VkImageMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageMemoryRequirements2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetImageOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetImageOpaqueCaptureDescriptorDataEXT(wine_device_from_handle(params->device)->device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkImageCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkImageCaptureDescriptorDataInfoEXT_win32_to_host((const VkImageCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageOpaqueCaptureDescriptorDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSparseMemoryRequirements(void *args)
{
    struct vkGetImageSparseMemoryRequirements_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageSparseMemoryRequirements(wine_device_from_handle(params->device)->device, params->image, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSparseMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkSparseImageMemoryRequirements *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    pSparseMemoryRequirements_host = (params->pSparseMemoryRequirements && *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount)) ? conversion_context_alloc(ctx, sizeof(*pSparseMemoryRequirements_host) * *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount)) : NULL;
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSparseMemoryRequirements(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements32 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSparseMemoryRequirements2(void *args)
{
    struct vkGetImageSparseMemoryRequirements2_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageSparseMemoryRequirements2(wine_device_from_handle(params->device)->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSparseMemoryRequirements2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkImageSparseMemoryRequirementsInfo2 pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host((const VkImageSparseMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSparseMemoryRequirements2(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSparseMemoryRequirements2KHR(void *args)
{
    struct vkGetImageSparseMemoryRequirements2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageSparseMemoryRequirements2KHR(wine_device_from_handle(params->device)->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSparseMemoryRequirements2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkImageSparseMemoryRequirementsInfo2 pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host((const VkImageSparseMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSparseMemoryRequirements2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout(void *args)
{
    struct vkGetImageSubresourceLayout_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageSubresourceLayout(wine_device_from_handle(params->device)->device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkSubresourceLayout pLayout_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    convert_VkSubresourceLayout_win32_to_host((VkSubresourceLayout32 *)UlongToPtr(params->pLayout), &pLayout_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSubresourceLayout(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, (const VkImageSubresource *)UlongToPtr(params->pSubresource), &pLayout_host);
    convert_VkSubresourceLayout_host_to_win32(&pLayout_host, (VkSubresourceLayout32 *)UlongToPtr(params->pLayout));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout2EXT(void *args)
{
    struct vkGetImageSubresourceLayout2EXT_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageSubresourceLayout2EXT(wine_device_from_handle(params->device)->device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout2EXT(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkImageSubresource2KHR pSubresource_host;
    VkSubresourceLayout2KHR pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    init_conversion_context(ctx);
    convert_VkImageSubresource2KHR_win32_to_host((const VkImageSubresource2KHR32 *)UlongToPtr(params->pSubresource), &pSubresource_host);
    convert_VkSubresourceLayout2KHR_win32_to_host(ctx, (VkSubresourceLayout2KHR32 *)UlongToPtr(params->pLayout), &pLayout_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSubresourceLayout2EXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, &pSubresource_host, &pLayout_host);
    convert_VkSubresourceLayout2KHR_host_to_win32(&pLayout_host, (VkSubresourceLayout2KHR32 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout2KHR(void *args)
{
    struct vkGetImageSubresourceLayout2KHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    wine_device_from_handle(params->device)->funcs.p_vkGetImageSubresourceLayout2KHR(wine_device_from_handle(params->device)->device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout2KHR(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkImageSubresource2KHR pSubresource_host;
    VkSubresourceLayout2KHR pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    init_conversion_context(ctx);
    convert_VkImageSubresource2KHR_win32_to_host((const VkImageSubresource2KHR32 *)UlongToPtr(params->pSubresource), &pSubresource_host);
    convert_VkSubresourceLayout2KHR_win32_to_host(ctx, (VkSubresourceLayout2KHR32 *)UlongToPtr(params->pLayout), &pLayout_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSubresourceLayout2KHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, &pSubresource_host, &pLayout_host);
    convert_VkSubresourceLayout2KHR_host_to_win32(&pLayout_host, (VkSubresourceLayout2KHR32 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewAddressNVX(void *args)
{
    struct vkGetImageViewAddressNVX_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->imageView), params->pProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetImageViewAddressNVX(wine_device_from_handle(params->device)->device, params->imageView, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewAddressNVX(void *args)
{
    struct
    {
        PTR32 device;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkImageViewAddressPropertiesNVX pProperties_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->imageView), params->pProperties);

    convert_VkImageViewAddressPropertiesNVX_win32_to_host((VkImageViewAddressPropertiesNVX32 *)UlongToPtr(params->pProperties), &pProperties_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageViewAddressNVX(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->imageView, &pProperties_host);
    convert_VkImageViewAddressPropertiesNVX_host_to_win32(&pProperties_host, (VkImageViewAddressPropertiesNVX32 *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewHandleNVX(void *args)
{
    struct vkGetImageViewHandleNVX_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetImageViewHandleNVX(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewHandleNVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint32_t result;
    } *params = args;
    VkImageViewHandleInfoNVX pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkImageViewHandleInfoNVX_win32_to_host((const VkImageViewHandleInfoNVX32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageViewHandleNVX(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetImageViewOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetImageViewOpaqueCaptureDescriptorDataEXT(wine_device_from_handle(params->device)->device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkImageViewCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkImageViewCaptureDescriptorDataInfoEXT_win32_to_host((const VkImageViewCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageViewOpaqueCaptureDescriptorDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetLatencyTimingsNV(void *args)
{
    struct vkGetLatencyTimingsNV_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pTimingCount, params->pLatencyMarkerInfo);

    wine_device_from_handle(params->device)->funcs.p_vkGetLatencyTimingsNV(wine_device_from_handle(params->device)->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->pTimingCount, params->pLatencyMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetLatencyTimingsNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pTimingCount;
        PTR32 pLatencyMarkerInfo;
    } *params = args;
    VkGetLatencyMarkerInfoNV pLatencyMarkerInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pTimingCount, params->pLatencyMarkerInfo);

    init_conversion_context(ctx);
    convert_VkGetLatencyMarkerInfoNV_win32_to_host(ctx, (VkGetLatencyMarkerInfoNV32 *)UlongToPtr(params->pLatencyMarkerInfo), &pLatencyMarkerInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetLatencyTimingsNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_swapchain_from_handle(params->swapchain)->swapchain, (uint32_t *)UlongToPtr(params->pTimingCount), &pLatencyMarkerInfo_host);
    convert_VkGetLatencyMarkerInfoNV_host_to_win32(&pLatencyMarkerInfo_host, (VkGetLatencyMarkerInfoNV32 *)UlongToPtr(params->pLatencyMarkerInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryFdKHR(void *args)
{
    struct vkGetMemoryFdKHR_params *params = args;
    VkMemoryGetFdInfoKHR pGetFdInfo_host;

    TRACE("%p, %p, %p\n", params->device, params->pGetFdInfo, params->pFd);

    convert_VkMemoryGetFdInfoKHR_win64_to_host(params->pGetFdInfo, &pGetFdInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetMemoryFdKHR(wine_device_from_handle(params->device)->device, &pGetFdInfo_host, params->pFd);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryFdKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetFdInfo;
        PTR32 pFd;
        VkResult result;
    } *params = args;
    VkMemoryGetFdInfoKHR pGetFdInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetFdInfo, params->pFd);

    convert_VkMemoryGetFdInfoKHR_win32_to_host((const VkMemoryGetFdInfoKHR32 *)UlongToPtr(params->pGetFdInfo), &pGetFdInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetMemoryFdKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pGetFdInfo_host, (int *)UlongToPtr(params->pFd));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryFdPropertiesKHR(void *args)
{
    struct vkGetMemoryFdPropertiesKHR_params *params = args;

    TRACE("%p, %#x, %d, %p\n", params->device, params->handleType, params->fd, params->pMemoryFdProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetMemoryFdPropertiesKHR(wine_device_from_handle(params->device)->device, params->handleType, params->fd, params->pMemoryFdProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryFdPropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkExternalMemoryHandleTypeFlagBits handleType;
        int fd;
        PTR32 pMemoryFdProperties;
        VkResult result;
    } *params = args;
    VkMemoryFdPropertiesKHR pMemoryFdProperties_host;

    TRACE("%#x, %#x, %d, %#x\n", params->device, params->handleType, params->fd, params->pMemoryFdProperties);

    convert_VkMemoryFdPropertiesKHR_win32_to_host((VkMemoryFdPropertiesKHR32 *)UlongToPtr(params->pMemoryFdProperties), &pMemoryFdProperties_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetMemoryFdPropertiesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->handleType, params->fd, &pMemoryFdProperties_host);
    convert_VkMemoryFdPropertiesKHR_host_to_win32(&pMemoryFdProperties_host, (VkMemoryFdPropertiesKHR32 *)UlongToPtr(params->pMemoryFdProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryHostPointerPropertiesEXT(void *args)
{
    struct vkGetMemoryHostPointerPropertiesEXT_params *params = args;

    TRACE("%p, %#x, %p, %p\n", params->device, params->handleType, params->pHostPointer, params->pMemoryHostPointerProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetMemoryHostPointerPropertiesEXT(wine_device_from_handle(params->device)->device, params->handleType, params->pHostPointer, params->pMemoryHostPointerProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryHostPointerPropertiesEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkExternalMemoryHandleTypeFlagBits handleType;
        PTR32 pHostPointer;
        PTR32 pMemoryHostPointerProperties;
        VkResult result;
    } *params = args;
    VkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->handleType, params->pHostPointer, params->pMemoryHostPointerProperties);

    convert_VkMemoryHostPointerPropertiesEXT_win32_to_host((VkMemoryHostPointerPropertiesEXT32 *)UlongToPtr(params->pMemoryHostPointerProperties), &pMemoryHostPointerProperties_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetMemoryHostPointerPropertiesEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->handleType, (const void *)UlongToPtr(params->pHostPointer), &pMemoryHostPointerProperties_host);
    convert_VkMemoryHostPointerPropertiesEXT_host_to_win32(&pMemoryHostPointerProperties_host, (VkMemoryHostPointerPropertiesEXT32 *)UlongToPtr(params->pMemoryHostPointerProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryWin32HandleKHR(void *args)
{
    struct vkGetMemoryWin32HandleKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    params->result = wine_vkGetMemoryWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetWin32HandleInfo;
        PTR32 pHandle;
        VkResult result;
    } *params = args;
    VkMemoryGetWin32HandleInfoKHR pGetWin32HandleInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkMemoryGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
    params->result = wine_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryWin32HandlePropertiesKHR(void *args)
{
    struct vkGetMemoryWin32HandlePropertiesKHR_params *params = args;

    TRACE("%p, %#x, %p, %p\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);

    params->result = wine_vkGetMemoryWin32HandlePropertiesKHR(params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryWin32HandlePropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkExternalMemoryHandleTypeFlagBits handleType;
        HANDLE handle;
        PTR32 pMemoryWin32HandleProperties;
        VkResult result;
    } *params = args;
    VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties_host;

    TRACE("%#x, %#x, %p, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);

    convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host((VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties), &pMemoryWin32HandleProperties_host);
    params->result = wine_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, params->handle, &pMemoryWin32HandleProperties_host);
    convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(&pMemoryWin32HandleProperties_host, (VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMicromapBuildSizesEXT(void *args)
{
    struct vkGetMicromapBuildSizesEXT_params *params = args;

    TRACE("%p, %#x, %p, %p\n", params->device, params->buildType, params->pBuildInfo, params->pSizeInfo);

    wine_device_from_handle(params->device)->funcs.p_vkGetMicromapBuildSizesEXT(wine_device_from_handle(params->device)->device, params->buildType, params->pBuildInfo, params->pSizeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMicromapBuildSizesEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureBuildTypeKHR buildType;
        PTR32 pBuildInfo;
        PTR32 pSizeInfo;
    } *params = args;
    VkMicromapBuildInfoEXT pBuildInfo_host;
    VkMicromapBuildSizesInfoEXT pSizeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->buildType, params->pBuildInfo, params->pSizeInfo);

    init_conversion_context(ctx);
    convert_VkMicromapBuildInfoEXT_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
    convert_VkMicromapBuildSizesInfoEXT_win32_to_host((VkMicromapBuildSizesInfoEXT32 *)UlongToPtr(params->pSizeInfo), &pSizeInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetMicromapBuildSizesEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->buildType, &pBuildInfo_host, &pSizeInfo_host);
    convert_VkMicromapBuildSizesInfoEXT_host_to_win32(&pSizeInfo_host, (VkMicromapBuildSizesInfoEXT32 *)UlongToPtr(params->pSizeInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPerformanceParameterINTEL(void *args)
{
    struct vkGetPerformanceParameterINTEL_params *params = args;

    TRACE("%p, %#x, %p\n", params->device, params->parameter, params->pValue);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPerformanceParameterINTEL(wine_device_from_handle(params->device)->device, params->parameter, params->pValue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPerformanceParameterINTEL(void *args)
{
    struct
    {
        PTR32 device;
        VkPerformanceParameterTypeINTEL parameter;
        PTR32 pValue;
        VkResult result;
    } *params = args;
    VkPerformanceValueINTEL pValue_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->parameter, params->pValue);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPerformanceParameterINTEL(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->parameter, &pValue_host);
    convert_VkPerformanceValueINTEL_host_to_win32(&pValue_host, (VkPerformanceValueINTEL32 *)UlongToPtr(params->pValue));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(void *args)
{
    struct vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);

    params->result = wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pTimeDomainCount;
        PTR32 pTimeDomains;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);

    params->result = wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (uint32_t *)UlongToPtr(params->pTimeDomainCount), (VkTimeDomainEXT *)UlongToPtr(params->pTimeDomains));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkCooperativeMatrixPropertiesKHR *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkCooperativeMatrixPropertiesKHR_array_win32_to_host(ctx, (VkCooperativeMatrixPropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkCooperativeMatrixPropertiesKHR_array_host_to_win32(pProperties_host, (VkCooperativeMatrixPropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(void *args)
{
    struct vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkCooperativeMatrixPropertiesNV *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkCooperativeMatrixPropertiesNV_array_win32_to_host(ctx, (VkCooperativeMatrixPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkCooperativeMatrixPropertiesNV_array_host_to_win32(pProperties_host, (VkCooperativeMatrixPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferProperties(void *args)
{
    struct vkGetPhysicalDeviceExternalBufferProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    wine_vkGetPhysicalDeviceExternalBufferProperties(params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalBufferInfo;
        PTR32 pExternalBufferProperties;
    } *params = args;
    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
    VkExternalBufferProperties pExternalBufferProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
    convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
    wine_vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
    convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceExternalBufferPropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalBufferInfo;
        PTR32 pExternalBufferProperties;
    } *params = args;
    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
    VkExternalBufferProperties pExternalBufferProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
    convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
    wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
    convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalFenceProperties(void *args)
{
    struct vkGetPhysicalDeviceExternalFenceProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    wine_vkGetPhysicalDeviceExternalFenceProperties(params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalFenceProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalFenceInfo;
        PTR32 pExternalFenceProperties;
    } *params = args;
    VkPhysicalDeviceExternalFenceInfo pExternalFenceInfo_host;
    VkExternalFenceProperties pExternalFenceProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    convert_VkPhysicalDeviceExternalFenceInfo_win32_to_host((const VkPhysicalDeviceExternalFenceInfo32 *)UlongToPtr(params->pExternalFenceInfo), &pExternalFenceInfo_host);
    convert_VkExternalFenceProperties_win32_to_host((VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties), &pExternalFenceProperties_host);
    wine_vkGetPhysicalDeviceExternalFenceProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalFenceInfo_host, &pExternalFenceProperties_host);
    convert_VkExternalFenceProperties_host_to_win32(&pExternalFenceProperties_host, (VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalFencePropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceExternalFencePropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalFencePropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalFenceInfo;
        PTR32 pExternalFenceProperties;
    } *params = args;
    VkPhysicalDeviceExternalFenceInfo pExternalFenceInfo_host;
    VkExternalFenceProperties pExternalFenceProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    convert_VkPhysicalDeviceExternalFenceInfo_win32_to_host((const VkPhysicalDeviceExternalFenceInfo32 *)UlongToPtr(params->pExternalFenceInfo), &pExternalFenceInfo_host);
    convert_VkExternalFenceProperties_win32_to_host((VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties), &pExternalFenceProperties_host);
    wine_vkGetPhysicalDeviceExternalFencePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalFenceInfo_host, &pExternalFenceProperties_host);
    convert_VkExternalFenceProperties_host_to_win32(&pExternalFenceProperties_host, (VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
{
    struct vkGetPhysicalDeviceExternalSemaphoreProperties_params *params = args;
    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalSemaphoreInfo_win64_to_host(ctx, params->pExternalSemaphoreInfo, &pExternalSemaphoreInfo_host);
    wine_vkGetPhysicalDeviceExternalSemaphoreProperties(params->physicalDevice, &pExternalSemaphoreInfo_host, params->pExternalSemaphoreProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalSemaphoreInfo;
        PTR32 pExternalSemaphoreProperties;
    } *params = args;
    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
    VkExternalSemaphoreProperties pExternalSemaphoreProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
    convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
    wine_vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
    convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceExternalSemaphorePropertiesKHR_params *params = args;
    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalSemaphoreInfo_win64_to_host(ctx, params->pExternalSemaphoreInfo, &pExternalSemaphoreInfo_host);
    wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(params->physicalDevice, &pExternalSemaphoreInfo_host, params->pExternalSemaphoreProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalSemaphoreInfo;
        PTR32 pExternalSemaphoreProperties;
    } *params = args;
    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
    VkExternalSemaphoreProperties pExternalSemaphoreProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
    convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
    wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
    convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFeatures(void *args)
{
    struct vkGetPhysicalDeviceFeatures_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pFeatures);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFeatures(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFeatures(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFeatures;
    } *params = args;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pFeatures);

    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFeatures(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (VkPhysicalDeviceFeatures *)UlongToPtr(params->pFeatures));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFeatures2(void *args)
{
    struct vkGetPhysicalDeviceFeatures2_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pFeatures);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFeatures2(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFeatures2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFeatures;
    } *params = args;
    VkPhysicalDeviceFeatures2 pFeatures_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pFeatures);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceFeatures2_win32_to_host(ctx, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures), &pFeatures_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFeatures2(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pFeatures_host);
    convert_VkPhysicalDeviceFeatures2_host_to_win32(&pFeatures_host, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFeatures2KHR(void *args)
{
    struct vkGetPhysicalDeviceFeatures2KHR_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pFeatures);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFeatures2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFeatures2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFeatures;
    } *params = args;
    VkPhysicalDeviceFeatures2 pFeatures_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pFeatures);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceFeatures2_win32_to_host(ctx, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures), &pFeatures_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFeatures2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pFeatures_host);
    convert_VkPhysicalDeviceFeatures2_host_to_win32(&pFeatures_host, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFormatProperties(void *args)
{
    struct vkGetPhysicalDeviceFormatProperties_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->format, params->pFormatProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFormatProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->format, params->pFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFormatProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        PTR32 pFormatProperties;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->format, params->pFormatProperties);

    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFormatProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->format, (VkFormatProperties *)UlongToPtr(params->pFormatProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFormatProperties2(void *args)
{
    struct vkGetPhysicalDeviceFormatProperties2_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->format, params->pFormatProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFormatProperties2(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->format, params->pFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFormatProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        PTR32 pFormatProperties;
    } *params = args;
    VkFormatProperties2 pFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->format, params->pFormatProperties);

    init_conversion_context(ctx);
    convert_VkFormatProperties2_win32_to_host(ctx, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties), &pFormatProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFormatProperties2(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->format, &pFormatProperties_host);
    convert_VkFormatProperties2_host_to_win32(&pFormatProperties_host, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFormatProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceFormatProperties2KHR_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->format, params->pFormatProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFormatProperties2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->format, params->pFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFormatProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        PTR32 pFormatProperties;
    } *params = args;
    VkFormatProperties2 pFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->format, params->pFormatProperties);

    init_conversion_context(ctx);
    convert_VkFormatProperties2_win32_to_host(ctx, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties), &pFormatProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFormatProperties2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->format, &pFormatProperties_host);
    convert_VkFormatProperties2_host_to_win32(&pFormatProperties_host, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFragmentShadingRatesKHR(void *args)
{
    struct vkGetPhysicalDeviceFragmentShadingRatesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pFragmentShadingRateCount, params->pFragmentShadingRates);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceFragmentShadingRatesKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pFragmentShadingRateCount, params->pFragmentShadingRates);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFragmentShadingRatesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFragmentShadingRateCount;
        PTR32 pFragmentShadingRates;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pFragmentShadingRateCount, params->pFragmentShadingRates);

    init_conversion_context(ctx);
    pFragmentShadingRates_host = convert_VkPhysicalDeviceFragmentShadingRateKHR_array_win32_to_host(ctx, (VkPhysicalDeviceFragmentShadingRateKHR32 *)UlongToPtr(params->pFragmentShadingRates), *(uint32_t *)UlongToPtr(params->pFragmentShadingRateCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceFragmentShadingRatesKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pFragmentShadingRateCount), pFragmentShadingRates_host);
    convert_VkPhysicalDeviceFragmentShadingRateKHR_array_host_to_win32(pFragmentShadingRates_host, (VkPhysicalDeviceFragmentShadingRateKHR32 *)UlongToPtr(params->pFragmentShadingRates), *(uint32_t *)UlongToPtr(params->pFragmentShadingRateCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties(void *args)
{
    struct vkGetPhysicalDeviceImageFormatProperties_params *params = args;

    TRACE("%p, %#x, %#x, %#x, %#x, %#x, %p\n", params->physicalDevice, params->format, params->type, params->tiling, params->usage, params->flags, params->pImageFormatProperties);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceImageFormatProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->format, params->type, params->tiling, params->usage, params->flags, params->pImageFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        VkImageType type;
        VkImageTiling tiling;
        VkImageUsageFlags usage;
        VkImageCreateFlags flags;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkImageFormatProperties pImageFormatProperties_host;

    TRACE("%#x, %#x, %#x, %#x, %#x, %#x, %#x\n", params->physicalDevice, params->format, params->type, params->tiling, params->usage, params->flags, params->pImageFormatProperties);

    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceImageFormatProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->format, params->type, params->tiling, params->usage, params->flags, &pImageFormatProperties_host);
    convert_VkImageFormatProperties_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties32 *)UlongToPtr(params->pImageFormatProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties2(void *args)
{
    struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pImageFormatInfo;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    VkImageFormatProperties2 pImageFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
    convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
    convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2KHR(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pImageFormatInfo;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    VkImageFormatProperties2 pImageFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
    convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
    convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMemoryProperties(void *args)
{
    struct vkGetPhysicalDeviceMemoryProperties_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pMemoryProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pMemoryProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMemoryProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pMemoryProperties;
    } *params = args;
    VkPhysicalDeviceMemoryProperties pMemoryProperties_host;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pMemoryProperties);

    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pMemoryProperties_host);
    convert_VkPhysicalDeviceMemoryProperties_host_to_win32(&pMemoryProperties_host, (VkPhysicalDeviceMemoryProperties32 *)UlongToPtr(params->pMemoryProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMemoryProperties2(void *args)
{
    struct vkGetPhysicalDeviceMemoryProperties2_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pMemoryProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties2(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pMemoryProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMemoryProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pMemoryProperties;
    } *params = args;
    VkPhysicalDeviceMemoryProperties2 pMemoryProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pMemoryProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(ctx, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties), &pMemoryProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties2(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pMemoryProperties_host);
    convert_VkPhysicalDeviceMemoryProperties2_host_to_win32(&pMemoryProperties_host, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMemoryProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceMemoryProperties2KHR_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pMemoryProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pMemoryProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMemoryProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pMemoryProperties;
    } *params = args;
    VkPhysicalDeviceMemoryProperties2 pMemoryProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pMemoryProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(ctx, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties), &pMemoryProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pMemoryProperties_host);
    convert_VkPhysicalDeviceMemoryProperties2_host_to_win32(&pMemoryProperties_host, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMultisamplePropertiesEXT(void *args)
{
    struct vkGetPhysicalDeviceMultisamplePropertiesEXT_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->samples, params->pMultisampleProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceMultisamplePropertiesEXT(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->samples, params->pMultisampleProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMultisamplePropertiesEXT(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSampleCountFlagBits samples;
        PTR32 pMultisampleProperties;
    } *params = args;
    VkMultisamplePropertiesEXT pMultisampleProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->samples, params->pMultisampleProperties);

    convert_VkMultisamplePropertiesEXT_win32_to_host((VkMultisamplePropertiesEXT32 *)UlongToPtr(params->pMultisampleProperties), &pMultisampleProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceMultisamplePropertiesEXT(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->samples, &pMultisampleProperties_host);
    convert_VkMultisamplePropertiesEXT_host_to_win32(&pMultisampleProperties_host, (VkMultisamplePropertiesEXT32 *)UlongToPtr(params->pMultisampleProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(void *args)
{
    struct vkGetPhysicalDeviceOpticalFlowImageFormatsNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pOpticalFlowImageFormatInfo, params->pFormatCount, params->pImageFormatProperties);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pOpticalFlowImageFormatInfo, params->pFormatCount, params->pImageFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pOpticalFlowImageFormatInfo;
        PTR32 pFormatCount;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkOpticalFlowImageFormatInfoNV pOpticalFlowImageFormatInfo_host;
    VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pOpticalFlowImageFormatInfo, params->pFormatCount, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkOpticalFlowImageFormatInfoNV_win32_to_host((const VkOpticalFlowImageFormatInfoNV32 *)UlongToPtr(params->pOpticalFlowImageFormatInfo), &pOpticalFlowImageFormatInfo_host);
    pImageFormatProperties_host = convert_VkOpticalFlowImageFormatPropertiesNV_array_win32_to_host(ctx, (VkOpticalFlowImageFormatPropertiesNV32 *)UlongToPtr(params->pImageFormatProperties), *(uint32_t *)UlongToPtr(params->pFormatCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pOpticalFlowImageFormatInfo_host, (uint32_t *)UlongToPtr(params->pFormatCount), pImageFormatProperties_host);
    convert_VkOpticalFlowImageFormatPropertiesNV_array_host_to_win32(pImageFormatProperties_host, (VkOpticalFlowImageFormatPropertiesNV32 *)UlongToPtr(params->pImageFormatProperties), *(uint32_t *)UlongToPtr(params->pFormatCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDevicePresentRectanglesKHR(void *args)
{
    struct vkGetPhysicalDevicePresentRectanglesKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pRectCount, params->pRects);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDevicePresentRectanglesKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, wine_surface_from_handle(params->surface)->driver_surface, params->pRectCount, params->pRects);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDevicePresentRectanglesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pRectCount;
        PTR32 pRects;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pRectCount, params->pRects);

    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDevicePresentRectanglesKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, wine_surface_from_handle(params->surface)->driver_surface, (uint32_t *)UlongToPtr(params->pRectCount), (VkRect2D *)UlongToPtr(params->pRects));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceProperties(void *args)
{
    struct vkGetPhysicalDeviceProperties_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceProperties pProperties_host;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pProperties);

    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pProperties_host);
    convert_VkPhysicalDeviceProperties_host_to_win32(&pProperties_host, (VkPhysicalDeviceProperties32 *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceProperties2(void *args)
{
    struct vkGetPhysicalDeviceProperties2_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceProperties2(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceProperties2 pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceProperties2_win32_to_host(ctx, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties), &pProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceProperties2(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pProperties_host);
    convert_VkPhysicalDeviceProperties2_host_to_win32(&pProperties_host, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceProperties2KHR_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceProperties2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceProperties2 pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceProperties2_win32_to_host(ctx, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties), &pProperties_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceProperties2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pProperties_host);
    convert_VkPhysicalDeviceProperties2_host_to_win32(&pProperties_host, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPerformanceQueryCreateInfo, params->pNumPasses);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pPerformanceQueryCreateInfo, params->pNumPasses);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPerformanceQueryCreateInfo;
        PTR32 pNumPasses;
    } *params = args;
    VkQueryPoolPerformanceCreateInfoKHR pPerformanceQueryCreateInfo_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPerformanceQueryCreateInfo, params->pNumPasses);

    convert_VkQueryPoolPerformanceCreateInfoKHR_win32_to_host((const VkQueryPoolPerformanceCreateInfoKHR32 *)UlongToPtr(params->pPerformanceQueryCreateInfo), &pPerformanceQueryCreateInfo_host);
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pPerformanceQueryCreateInfo_host, (uint32_t *)UlongToPtr(params->pNumPasses));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyProperties(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyPropertyCount;
        PTR32 pQueueFamilyProperties;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount), (VkQueueFamilyProperties *)UlongToPtr(params->pQueueFamilyProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyProperties2(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyProperties2_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties2(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyPropertyCount;
        PTR32 pQueueFamilyProperties;
    } *params = args;
    VkQueueFamilyProperties2 *pQueueFamilyProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    init_conversion_context(ctx);
    pQueueFamilyProperties_host = convert_VkQueueFamilyProperties2_array_win32_to_host(ctx, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties2(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount), pQueueFamilyProperties_host);
    convert_VkQueueFamilyProperties2_array_host_to_win32(pQueueFamilyProperties_host, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyProperties2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyPropertyCount;
        PTR32 pQueueFamilyProperties;
    } *params = args;
    VkQueueFamilyProperties2 *pQueueFamilyProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    init_conversion_context(ctx);
    pQueueFamilyProperties_host = convert_VkQueueFamilyProperties2_array_win32_to_host(ctx, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount), pQueueFamilyProperties_host);
    convert_VkQueueFamilyProperties2_array_host_to_win32(pQueueFamilyProperties_host, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSparseImageFormatProperties(void *args)
{
    struct vkGetPhysicalDeviceSparseImageFormatProperties_params *params = args;

    TRACE("%p, %#x, %#x, %#x, %#x, %#x, %p, %p\n", params->physicalDevice, params->format, params->type, params->samples, params->usage, params->tiling, params->pPropertyCount, params->pProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->format, params->type, params->samples, params->usage, params->tiling, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSparseImageFormatProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        VkImageType type;
        VkSampleCountFlagBits samples;
        VkImageUsageFlags usage;
        VkImageTiling tiling;
        PTR32 pPropertyCount;
        PTR32 pProperties;
    } *params = args;

    TRACE("%#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x\n", params->physicalDevice, params->format, params->type, params->samples, params->usage, params->tiling, params->pPropertyCount, params->pProperties);

    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->format, params->type, params->samples, params->usage, params->tiling, (uint32_t *)UlongToPtr(params->pPropertyCount), (VkSparseImageFormatProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2(void *args)
{
    struct vkGetPhysicalDeviceSparseImageFormatProperties2_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties2(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pFormatInfo, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFormatInfo;
        PTR32 pPropertyCount;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceSparseImageFormatInfo2 pFormatInfo_host;
    VkSparseImageFormatProperties2 *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSparseImageFormatInfo2_win32_to_host((const VkPhysicalDeviceSparseImageFormatInfo232 *)UlongToPtr(params->pFormatInfo), &pFormatInfo_host);
    pProperties_host = convert_VkSparseImageFormatProperties2_array_win32_to_host(ctx, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties2(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pFormatInfo_host, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkSparseImageFormatProperties2_array_host_to_win32(pProperties_host, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceSparseImageFormatProperties2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pFormatInfo, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFormatInfo;
        PTR32 pPropertyCount;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceSparseImageFormatInfo2 pFormatInfo_host;
    VkSparseImageFormatProperties2 *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSparseImageFormatInfo2_win32_to_host((const VkPhysicalDeviceSparseImageFormatInfo232 *)UlongToPtr(params->pFormatInfo), &pFormatInfo_host);
    pProperties_host = convert_VkSparseImageFormatProperties2_array_win32_to_host(ctx, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pFormatInfo_host, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkSparseImageFormatProperties2_array_host_to_win32(pProperties_host, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(void *args)
{
    struct vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pCombinationCount, params->pCombinations);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pCombinationCount, params->pCombinations);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pCombinationCount;
        PTR32 pCombinations;
        VkResult result;
    } *params = args;
    VkFramebufferMixedSamplesCombinationNV *pCombinations_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pCombinationCount, params->pCombinations);

    init_conversion_context(ctx);
    pCombinations_host = convert_VkFramebufferMixedSamplesCombinationNV_array_win32_to_host(ctx, (VkFramebufferMixedSamplesCombinationNV32 *)UlongToPtr(params->pCombinations), *(uint32_t *)UlongToPtr(params->pCombinationCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pCombinationCount), pCombinations_host);
    convert_VkFramebufferMixedSamplesCombinationNV_array_host_to_win32(pCombinations_host, (VkFramebufferMixedSamplesCombinationNV32 *)UlongToPtr(params->pCombinations), *(uint32_t *)UlongToPtr(params->pCombinationCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceCapabilities2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceCapabilities);

    params->result = wine_vkGetPhysicalDeviceSurfaceCapabilities2KHR(params->physicalDevice, params->pSurfaceInfo, params->pSurfaceCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pSurfaceInfo;
        PTR32 pSurfaceCapabilities;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo_host;
    VkSurfaceCapabilities2KHR pSurfaceCapabilities_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceCapabilities);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_unwrapped_host(ctx, (const VkPhysicalDeviceSurfaceInfo2KHR32 *)UlongToPtr(params->pSurfaceInfo), &pSurfaceInfo_host);
    convert_VkSurfaceCapabilities2KHR_win32_to_host(ctx, (VkSurfaceCapabilities2KHR32 *)UlongToPtr(params->pSurfaceCapabilities), &pSurfaceCapabilities_host);
    params->result = wine_vkGetPhysicalDeviceSurfaceCapabilities2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pSurfaceInfo_host, &pSurfaceCapabilities_host);
    convert_VkSurfaceCapabilities2KHR_host_to_win32(&pSurfaceCapabilities_host, (VkSurfaceCapabilities2KHR32 *)UlongToPtr(params->pSurfaceCapabilities));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceCapabilitiesKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceCapabilities);

    params->result = wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(params->physicalDevice, params->surface, params->pSurfaceCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pSurfaceCapabilities;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceCapabilities);

    params->result = wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), params->surface, (VkSurfaceCapabilitiesKHR *)UlongToPtr(params->pSurfaceCapabilities));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceFormats2KHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceFormats2KHR_params *params = args;
    VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo_host;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceFormatCount, params->pSurfaceFormats);

    convert_VkPhysicalDeviceSurfaceInfo2KHR_win64_to_host(params->pSurfaceInfo, &pSurfaceInfo_host);
    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSurfaceFormats2KHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, &pSurfaceInfo_host, params->pSurfaceFormatCount, params->pSurfaceFormats);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceFormats2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pSurfaceInfo;
        PTR32 pSurfaceFormatCount;
        PTR32 pSurfaceFormats;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo_host;
    VkSurfaceFormat2KHR *pSurfaceFormats_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceFormatCount, params->pSurfaceFormats);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_host(ctx, (const VkPhysicalDeviceSurfaceInfo2KHR32 *)UlongToPtr(params->pSurfaceInfo), &pSurfaceInfo_host);
    pSurfaceFormats_host = convert_VkSurfaceFormat2KHR_array_win32_to_host(ctx, (VkSurfaceFormat2KHR32 *)UlongToPtr(params->pSurfaceFormats), *(uint32_t *)UlongToPtr(params->pSurfaceFormatCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSurfaceFormats2KHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, &pSurfaceInfo_host, (uint32_t *)UlongToPtr(params->pSurfaceFormatCount), pSurfaceFormats_host);
    convert_VkSurfaceFormat2KHR_array_host_to_win32(pSurfaceFormats_host, (VkSurfaceFormat2KHR32 *)UlongToPtr(params->pSurfaceFormats), *(uint32_t *)UlongToPtr(params->pSurfaceFormatCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceFormatsKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceFormatsKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceFormatCount, params->pSurfaceFormats);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSurfaceFormatsKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->surface ? wine_surface_from_handle(params->surface)->driver_surface : 0, params->pSurfaceFormatCount, params->pSurfaceFormats);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceFormatsKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pSurfaceFormatCount;
        PTR32 pSurfaceFormats;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceFormatCount, params->pSurfaceFormats);

    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSurfaceFormatsKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->surface ? wine_surface_from_handle(params->surface)->driver_surface : 0, (uint32_t *)UlongToPtr(params->pSurfaceFormatCount), (VkSurfaceFormatKHR *)UlongToPtr(params->pSurfaceFormats));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfacePresentModesKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfacePresentModesKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pPresentModeCount, params->pPresentModes);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSurfacePresentModesKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->surface ? wine_surface_from_handle(params->surface)->driver_surface : 0, params->pPresentModeCount, params->pPresentModes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfacePresentModesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pPresentModeCount;
        PTR32 pPresentModes;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pPresentModeCount, params->pPresentModes);

    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSurfacePresentModesKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->surface ? wine_surface_from_handle(params->surface)->driver_surface : 0, (uint32_t *)UlongToPtr(params->pPresentModeCount), (VkPresentModeKHR *)UlongToPtr(params->pPresentModes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceSupportKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceSupportKHR_params *params = args;

    TRACE("%p, %u, 0x%s, %p\n", params->physicalDevice, params->queueFamilyIndex, wine_dbgstr_longlong(params->surface), params->pSupported);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceSurfaceSupportKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->queueFamilyIndex, wine_surface_from_handle(params->surface)->driver_surface, params->pSupported);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceSupportKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pSupported;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, 0x%s, %#x\n", params->physicalDevice, params->queueFamilyIndex, wine_dbgstr_longlong(params->surface), params->pSupported);

    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceSurfaceSupportKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->queueFamilyIndex, wine_surface_from_handle(params->surface)->driver_surface, (VkBool32 *)UlongToPtr(params->pSupported));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceToolProperties(void *args)
{
    struct vkGetPhysicalDeviceToolProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceToolProperties(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pToolCount, params->pToolProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceToolProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pToolCount;
        PTR32 pToolProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceToolProperties *pToolProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    init_conversion_context(ctx);
    pToolProperties_host = convert_VkPhysicalDeviceToolProperties_array_win32_to_host(ctx, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceToolProperties(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pToolCount), pToolProperties_host);
    convert_VkPhysicalDeviceToolProperties_array_host_to_win32(pToolProperties_host, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceToolPropertiesEXT(void *args)
{
    struct vkGetPhysicalDeviceToolPropertiesEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceToolPropertiesEXT(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->pToolCount, params->pToolProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceToolPropertiesEXT(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pToolCount;
        PTR32 pToolProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceToolProperties *pToolProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    init_conversion_context(ctx);
    pToolProperties_host = convert_VkPhysicalDeviceToolProperties_array_win32_to_host(ctx, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceToolPropertiesEXT(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, (uint32_t *)UlongToPtr(params->pToolCount), pToolProperties_host);
    convert_VkPhysicalDeviceToolProperties_array_host_to_win32(pToolProperties_host, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceWin32PresentationSupportKHR(void *args)
{
    struct vkGetPhysicalDeviceWin32PresentationSupportKHR_params *params = args;

    TRACE("%p, %u\n", params->physicalDevice, params->queueFamilyIndex);

    params->result = wine_phys_dev_from_handle(params->physicalDevice)->instance->funcs.p_vkGetPhysicalDeviceWin32PresentationSupportKHR(wine_phys_dev_from_handle(params->physicalDevice)->phys_dev, params->queueFamilyIndex);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceWin32PresentationSupportKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        VkBool32 result;
    } *params = args;

    TRACE("%#x, %u\n", params->physicalDevice, params->queueFamilyIndex);

    params->result = wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->funcs.p_vkGetPhysicalDeviceWin32PresentationSupportKHR(wine_phys_dev_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->phys_dev, params->queueFamilyIndex);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineCacheData(void *args)
{
    struct vkGetPipelineCacheData_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pDataSize, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPipelineCacheData(wine_device_from_handle(params->device)->device, params->pipelineCache, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineCacheData(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    size_t pDataSize_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pDataSize, params->pData);

    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelineCacheData(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipelineCache, &pDataSize_host, (void *)UlongToPtr(params->pData));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineExecutableInternalRepresentationsKHR(void *args)
{
    struct vkGetPipelineExecutableInternalRepresentationsKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pExecutableInfo, params->pInternalRepresentationCount, params->pInternalRepresentations);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPipelineExecutableInternalRepresentationsKHR(wine_device_from_handle(params->device)->device, params->pExecutableInfo, params->pInternalRepresentationCount, params->pInternalRepresentations);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineExecutableInternalRepresentationsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pExecutableInfo;
        PTR32 pInternalRepresentationCount;
        PTR32 pInternalRepresentations;
        VkResult result;
    } *params = args;
    VkPipelineExecutableInfoKHR pExecutableInfo_host;
    VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pExecutableInfo, params->pInternalRepresentationCount, params->pInternalRepresentations);

    init_conversion_context(ctx);
    convert_VkPipelineExecutableInfoKHR_win32_to_host((const VkPipelineExecutableInfoKHR32 *)UlongToPtr(params->pExecutableInfo), &pExecutableInfo_host);
    pInternalRepresentations_host = convert_VkPipelineExecutableInternalRepresentationKHR_array_win32_to_host(ctx, (VkPipelineExecutableInternalRepresentationKHR32 *)UlongToPtr(params->pInternalRepresentations), *(uint32_t *)UlongToPtr(params->pInternalRepresentationCount));
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelineExecutableInternalRepresentationsKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pExecutableInfo_host, (uint32_t *)UlongToPtr(params->pInternalRepresentationCount), pInternalRepresentations_host);
    convert_VkPipelineExecutableInternalRepresentationKHR_array_host_to_win32(pInternalRepresentations_host, (VkPipelineExecutableInternalRepresentationKHR32 *)UlongToPtr(params->pInternalRepresentations), *(uint32_t *)UlongToPtr(params->pInternalRepresentationCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineExecutablePropertiesKHR(void *args)
{
    struct vkGetPipelineExecutablePropertiesKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pPipelineInfo, params->pExecutableCount, params->pProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPipelineExecutablePropertiesKHR(wine_device_from_handle(params->device)->device, params->pPipelineInfo, params->pExecutableCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineExecutablePropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineInfo;
        PTR32 pExecutableCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkPipelineInfoKHR pPipelineInfo_host;
    VkPipelineExecutablePropertiesKHR *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pPipelineInfo, params->pExecutableCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPipelineInfoKHR_win32_to_host((const VkPipelineInfoKHR32 *)UlongToPtr(params->pPipelineInfo), &pPipelineInfo_host);
    pProperties_host = convert_VkPipelineExecutablePropertiesKHR_array_win32_to_host(ctx, (VkPipelineExecutablePropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pExecutableCount));
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelineExecutablePropertiesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pPipelineInfo_host, (uint32_t *)UlongToPtr(params->pExecutableCount), pProperties_host);
    convert_VkPipelineExecutablePropertiesKHR_array_host_to_win32(pProperties_host, (VkPipelineExecutablePropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pExecutableCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineExecutableStatisticsKHR(void *args)
{
    struct vkGetPipelineExecutableStatisticsKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pExecutableInfo, params->pStatisticCount, params->pStatistics);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPipelineExecutableStatisticsKHR(wine_device_from_handle(params->device)->device, params->pExecutableInfo, params->pStatisticCount, params->pStatistics);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineExecutableStatisticsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pExecutableInfo;
        PTR32 pStatisticCount;
        PTR32 pStatistics;
        VkResult result;
    } *params = args;
    VkPipelineExecutableInfoKHR pExecutableInfo_host;
    VkPipelineExecutableStatisticKHR *pStatistics_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pExecutableInfo, params->pStatisticCount, params->pStatistics);

    init_conversion_context(ctx);
    convert_VkPipelineExecutableInfoKHR_win32_to_host((const VkPipelineExecutableInfoKHR32 *)UlongToPtr(params->pExecutableInfo), &pExecutableInfo_host);
    pStatistics_host = convert_VkPipelineExecutableStatisticKHR_array_win32_to_host(ctx, (VkPipelineExecutableStatisticKHR32 *)UlongToPtr(params->pStatistics), *(uint32_t *)UlongToPtr(params->pStatisticCount));
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelineExecutableStatisticsKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pExecutableInfo_host, (uint32_t *)UlongToPtr(params->pStatisticCount), pStatistics_host);
    convert_VkPipelineExecutableStatisticKHR_array_host_to_win32(pStatistics_host, (VkPipelineExecutableStatisticKHR32 *)UlongToPtr(params->pStatistics), *(uint32_t *)UlongToPtr(params->pStatisticCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineIndirectDeviceAddressNV(void *args)
{
    struct vkGetPipelineIndirectDeviceAddressNV_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPipelineIndirectDeviceAddressNV(wine_device_from_handle(params->device)->device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineIndirectDeviceAddressNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkPipelineIndirectDeviceAddressInfoNV pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkPipelineIndirectDeviceAddressInfoNV_win32_to_host((const VkPipelineIndirectDeviceAddressInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelineIndirectDeviceAddressNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineIndirectMemoryRequirementsNV(void *args)
{
    struct vkGetPipelineIndirectMemoryRequirementsNV_params *params = args;
    VkComputePipelineCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkComputePipelineCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    wine_device_from_handle(params->device)->funcs.p_vkGetPipelineIndirectMemoryRequirementsNV(wine_device_from_handle(params->device)->device, &pCreateInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineIndirectMemoryRequirementsNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkComputePipelineCreateInfo pCreateInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkComputePipelineCreateInfo_win32_to_host(ctx, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelineIndirectMemoryRequirementsNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, &pMemoryRequirements_host);
    convert_VkComputePipelineCreateInfo_host_to_win32(&pCreateInfo_host, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfo));
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelinePropertiesEXT(void *args)
{
    struct vkGetPipelinePropertiesEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pPipelineInfo, params->pPipelineProperties);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetPipelinePropertiesEXT(wine_device_from_handle(params->device)->device, params->pPipelineInfo, params->pPipelineProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelinePropertiesEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineInfo;
        PTR32 pPipelineProperties;
        VkResult result;
    } *params = args;
    VkPipelineInfoEXT pPipelineInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pPipelineInfo, params->pPipelineProperties);

    convert_VkPipelineInfoEXT_win32_to_host((const VkPipelineInfoEXT32 *)UlongToPtr(params->pPipelineInfo), &pPipelineInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPipelinePropertiesEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pPipelineInfo_host, (VkBaseOutStructure *)UlongToPtr(params->pPipelineProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPrivateData(void *args)
{
    struct vkGetPrivateData_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, %p\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    wine_device_from_handle(params->device)->funcs.p_vkGetPrivateData(wine_device_from_handle(params->device)->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPrivateData(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pData;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, %#x\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPrivateData(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, (uint64_t *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPrivateDataEXT(void *args)
{
    struct vkGetPrivateDataEXT_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, %p\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    wine_device_from_handle(params->device)->funcs.p_vkGetPrivateDataEXT(wine_device_from_handle(params->device)->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPrivateDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pData;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, %#x\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetPrivateDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, (uint64_t *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetQueryPoolResults(void *args)
{
    struct vkGetQueryPoolResults_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride), params->flags);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetQueryPoolResults(wine_device_from_handle(params->device)->device, params->queryPool, params->firstQuery, params->queryCount, params->dataSize, params->pData, params->stride, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetQueryPoolResults(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
        PTR32 dataSize;
        PTR32 pData;
        VkDeviceSize DECLSPEC_ALIGN(8) stride;
        VkQueryResultFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride), params->flags);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetQueryPoolResults(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->queryPool, params->firstQuery, params->queryCount, params->dataSize, (void *)UlongToPtr(params->pData), params->stride, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetQueueCheckpointData2NV(void *args)
{
    struct vkGetQueueCheckpointData2NV_params *params = args;

    TRACE("%p, %p, %p\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    wine_queue_from_handle(params->queue)->device->funcs.p_vkGetQueueCheckpointData2NV(wine_queue_from_handle(params->queue)->queue, params->pCheckpointDataCount, params->pCheckpointData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetQueueCheckpointData2NV(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pCheckpointDataCount;
        PTR32 pCheckpointData;
    } *params = args;
    VkCheckpointData2NV *pCheckpointData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    init_conversion_context(ctx);
    pCheckpointData_host = convert_VkCheckpointData2NV_array_win32_to_host(ctx, (VkCheckpointData2NV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkGetQueueCheckpointData2NV(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue, (uint32_t *)UlongToPtr(params->pCheckpointDataCount), pCheckpointData_host);
    convert_VkCheckpointData2NV_array_host_to_win32(pCheckpointData_host, (VkCheckpointData2NV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetQueueCheckpointDataNV(void *args)
{
    struct vkGetQueueCheckpointDataNV_params *params = args;

    TRACE("%p, %p, %p\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    wine_queue_from_handle(params->queue)->device->funcs.p_vkGetQueueCheckpointDataNV(wine_queue_from_handle(params->queue)->queue, params->pCheckpointDataCount, params->pCheckpointData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetQueueCheckpointDataNV(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pCheckpointDataCount;
        PTR32 pCheckpointData;
    } *params = args;
    VkCheckpointDataNV *pCheckpointData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    init_conversion_context(ctx);
    pCheckpointData_host = convert_VkCheckpointDataNV_array_win32_to_host(ctx, (VkCheckpointDataNV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkGetQueueCheckpointDataNV(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue, (uint32_t *)UlongToPtr(params->pCheckpointDataCount), pCheckpointData_host);
    convert_VkCheckpointDataNV_array_host_to_win32(pCheckpointData_host, (VkCheckpointDataNV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(void *args)
{
    struct vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(wine_device_from_handle(params->device)->device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t firstGroup;
        uint32_t groupCount;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingShaderGroupHandlesKHR(void *args)
{
    struct vkGetRayTracingShaderGroupHandlesKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetRayTracingShaderGroupHandlesKHR(wine_device_from_handle(params->device)->device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingShaderGroupHandlesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t firstGroup;
        uint32_t groupCount;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetRayTracingShaderGroupHandlesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingShaderGroupHandlesNV(void *args)
{
    struct vkGetRayTracingShaderGroupHandlesNV_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetRayTracingShaderGroupHandlesNV(wine_device_from_handle(params->device)->device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingShaderGroupHandlesNV(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t firstGroup;
        uint32_t groupCount;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetRayTracingShaderGroupHandlesNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingShaderGroupStackSizeKHR(void *args)
{
    struct vkGetRayTracingShaderGroupStackSizeKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->group, params->groupShader);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetRayTracingShaderGroupStackSizeKHR(wine_device_from_handle(params->device)->device, params->pipeline, params->group, params->groupShader);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingShaderGroupStackSizeKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t group;
        VkShaderGroupShaderKHR groupShader;
        VkDeviceSize result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->group, params->groupShader);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetRayTracingShaderGroupStackSizeKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, params->group, params->groupShader);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRenderAreaGranularity(void *args)
{
    struct vkGetRenderAreaGranularity_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pGranularity);

    wine_device_from_handle(params->device)->funcs.p_vkGetRenderAreaGranularity(wine_device_from_handle(params->device)->device, params->renderPass, params->pGranularity);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRenderAreaGranularity(void *args)
{
    struct
    {
        PTR32 device;
        VkRenderPass DECLSPEC_ALIGN(8) renderPass;
        PTR32 pGranularity;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pGranularity);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetRenderAreaGranularity(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->renderPass, (VkExtent2D *)UlongToPtr(params->pGranularity));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRenderingAreaGranularityKHR(void *args)
{
    struct vkGetRenderingAreaGranularityKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pRenderingAreaInfo, params->pGranularity);

    wine_device_from_handle(params->device)->funcs.p_vkGetRenderingAreaGranularityKHR(wine_device_from_handle(params->device)->device, params->pRenderingAreaInfo, params->pGranularity);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRenderingAreaGranularityKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pRenderingAreaInfo;
        PTR32 pGranularity;
    } *params = args;
    VkRenderingAreaInfoKHR pRenderingAreaInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pRenderingAreaInfo, params->pGranularity);

    convert_VkRenderingAreaInfoKHR_win32_to_host((const VkRenderingAreaInfoKHR32 *)UlongToPtr(params->pRenderingAreaInfo), &pRenderingAreaInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetRenderingAreaGranularityKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pRenderingAreaInfo_host, (VkExtent2D *)UlongToPtr(params->pGranularity));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSamplerOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetSamplerOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetSamplerOpaqueCaptureDescriptorDataEXT(wine_device_from_handle(params->device)->device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSamplerOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkSamplerCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkSamplerCaptureDescriptorDataInfoEXT_win32_to_host((const VkSamplerCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetSamplerOpaqueCaptureDescriptorDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreCounterValue(void *args)
{
    struct vkGetSemaphoreCounterValue_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = wine_vkGetSemaphoreCounterValue(params->device, params->semaphore, params->pValue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreCounterValue(void *args)
{
    struct
    {
        PTR32 device;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        PTR32 pValue;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = wine_vkGetSemaphoreCounterValue((VkDevice)UlongToPtr(params->device), params->semaphore, (uint64_t *)UlongToPtr(params->pValue));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreCounterValueKHR(void *args)
{
    struct vkGetSemaphoreCounterValueKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = wine_vkGetSemaphoreCounterValueKHR(params->device, params->semaphore, params->pValue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreCounterValueKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        PTR32 pValue;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = wine_vkGetSemaphoreCounterValueKHR((VkDevice)UlongToPtr(params->device), params->semaphore, (uint64_t *)UlongToPtr(params->pValue));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreFdKHR(void *args)
{
    struct vkGetSemaphoreFdKHR_params *params = args;
    VkSemaphoreGetFdInfoKHR pGetFdInfo_host;

    TRACE("%p, %p, %p\n", params->device, params->pGetFdInfo, params->pFd);

    convert_VkSemaphoreGetFdInfoKHR_win64_to_host(params->pGetFdInfo, &pGetFdInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetSemaphoreFdKHR(wine_device_from_handle(params->device)->device, &pGetFdInfo_host, params->pFd);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreFdKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetFdInfo;
        PTR32 pFd;
        VkResult result;
    } *params = args;
    VkSemaphoreGetFdInfoKHR pGetFdInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetFdInfo, params->pFd);

    convert_VkSemaphoreGetFdInfoKHR_win32_to_host((const VkSemaphoreGetFdInfoKHR32 *)UlongToPtr(params->pGetFdInfo), &pGetFdInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetSemaphoreFdKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pGetFdInfo_host, (int *)UlongToPtr(params->pFd));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreWin32HandleKHR(void *args)
{
    struct vkGetSemaphoreWin32HandleKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    params->result = wine_vkGetSemaphoreWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetWin32HandleInfo;
        PTR32 pHandle;
        VkResult result;
    } *params = args;
    VkSemaphoreGetWin32HandleInfoKHR pGetWin32HandleInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
    params->result = wine_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderBinaryDataEXT(void *args)
{
    struct vkGetShaderBinaryDataEXT_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->shader), params->pDataSize, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetShaderBinaryDataEXT(wine_device_from_handle(params->device)->device, params->shader, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderBinaryDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderEXT DECLSPEC_ALIGN(8) shader;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    size_t pDataSize_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->shader), params->pDataSize, params->pData);

    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetShaderBinaryDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->shader, &pDataSize_host, (void *)UlongToPtr(params->pData));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderInfoAMD(void *args)
{
    struct vkGetShaderInfoAMD_params *params = args;

    TRACE("%p, 0x%s, %#x, %#x, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shaderStage, params->infoType, params->pInfoSize, params->pInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetShaderInfoAMD(wine_device_from_handle(params->device)->device, params->pipeline, params->shaderStage, params->infoType, params->pInfoSize, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderInfoAMD(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        VkShaderStageFlagBits shaderStage;
        VkShaderInfoTypeAMD infoType;
        PTR32 pInfoSize;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    size_t pInfoSize_host;

    TRACE("%#x, 0x%s, %#x, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shaderStage, params->infoType, params->pInfoSize, params->pInfo);

    pInfoSize_host = *(PTR32 *)UlongToPtr(params->pInfoSize);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetShaderInfoAMD(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->pipeline, params->shaderStage, params->infoType, &pInfoSize_host, (void *)UlongToPtr(params->pInfo));
    *(PTR32 *)UlongToPtr(params->pInfoSize) = pInfoSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderModuleCreateInfoIdentifierEXT(void *args)
{
    struct vkGetShaderModuleCreateInfoIdentifierEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pIdentifier);

    wine_device_from_handle(params->device)->funcs.p_vkGetShaderModuleCreateInfoIdentifierEXT(wine_device_from_handle(params->device)->device, params->pCreateInfo, params->pIdentifier);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderModuleCreateInfoIdentifierEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pIdentifier;
    } *params = args;
    VkShaderModuleCreateInfo pCreateInfo_host;
    VkShaderModuleIdentifierEXT pIdentifier_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pIdentifier);

    init_conversion_context(ctx);
    convert_VkShaderModuleCreateInfo_win32_to_host(ctx, (const VkShaderModuleCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkShaderModuleIdentifierEXT_win32_to_host((VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier), &pIdentifier_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetShaderModuleCreateInfoIdentifierEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pCreateInfo_host, &pIdentifier_host);
    convert_VkShaderModuleIdentifierEXT_host_to_win32(&pIdentifier_host, (VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderModuleIdentifierEXT(void *args)
{
    struct vkGetShaderModuleIdentifierEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pIdentifier);

    wine_device_from_handle(params->device)->funcs.p_vkGetShaderModuleIdentifierEXT(wine_device_from_handle(params->device)->device, params->shaderModule, params->pIdentifier);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderModuleIdentifierEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderModule DECLSPEC_ALIGN(8) shaderModule;
        PTR32 pIdentifier;
    } *params = args;
    VkShaderModuleIdentifierEXT pIdentifier_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pIdentifier);

    convert_VkShaderModuleIdentifierEXT_win32_to_host((VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier), &pIdentifier_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetShaderModuleIdentifierEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->shaderModule, &pIdentifier_host);
    convert_VkShaderModuleIdentifierEXT_host_to_win32(&pIdentifier_host, (VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSwapchainImagesKHR(void *args)
{
    struct vkGetSwapchainImagesKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSwapchainImageCount, params->pSwapchainImages);

    params->result = wine_vkGetSwapchainImagesKHR(params->device, params->swapchain, params->pSwapchainImageCount, params->pSwapchainImages);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSwapchainImagesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pSwapchainImageCount;
        PTR32 pSwapchainImages;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSwapchainImageCount, params->pSwapchainImages);

    params->result = wine_vkGetSwapchainImagesKHR((VkDevice)UlongToPtr(params->device), params->swapchain, (uint32_t *)UlongToPtr(params->pSwapchainImageCount), (VkImage *)UlongToPtr(params->pSwapchainImages));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetValidationCacheDataEXT(void *args)
{
    struct vkGetValidationCacheDataEXT_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pDataSize, params->pData);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkGetValidationCacheDataEXT(wine_device_from_handle(params->device)->device, params->validationCache, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetValidationCacheDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkValidationCacheEXT DECLSPEC_ALIGN(8) validationCache;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    size_t pDataSize_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pDataSize, params->pData);

    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetValidationCacheDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->validationCache, &pDataSize_host, (void *)UlongToPtr(params->pData));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkImportSemaphoreFdKHR(void *args)
{
    struct vkImportSemaphoreFdKHR_params *params = args;
    VkImportSemaphoreFdInfoKHR pImportSemaphoreFdInfo_host;

    TRACE("%p, %p\n", params->device, params->pImportSemaphoreFdInfo);

    convert_VkImportSemaphoreFdInfoKHR_win64_to_host(params->pImportSemaphoreFdInfo, &pImportSemaphoreFdInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkImportSemaphoreFdKHR(wine_device_from_handle(params->device)->device, &pImportSemaphoreFdInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkImportSemaphoreFdKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pImportSemaphoreFdInfo;
        VkResult result;
    } *params = args;
    VkImportSemaphoreFdInfoKHR pImportSemaphoreFdInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreFdInfo);

    convert_VkImportSemaphoreFdInfoKHR_win32_to_host((const VkImportSemaphoreFdInfoKHR32 *)UlongToPtr(params->pImportSemaphoreFdInfo), &pImportSemaphoreFdInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkImportSemaphoreFdKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pImportSemaphoreFdInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkImportSemaphoreWin32HandleKHR(void *args)
{
    struct vkImportSemaphoreWin32HandleKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pImportSemaphoreWin32HandleInfo);

    params->result = wine_vkImportSemaphoreWin32HandleKHR(params->device, params->pImportSemaphoreWin32HandleInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkImportSemaphoreWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pImportSemaphoreWin32HandleInfo;
        VkResult result;
    } *params = args;
    VkImportSemaphoreWin32HandleInfoKHR pImportSemaphoreWin32HandleInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreWin32HandleInfo);

    convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportSemaphoreWin32HandleInfoKHR32 *)UlongToPtr(params->pImportSemaphoreWin32HandleInfo), &pImportSemaphoreWin32HandleInfo_host);
    params->result = wine_vkImportSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportSemaphoreWin32HandleInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkInitializePerformanceApiINTEL(void *args)
{
    struct vkInitializePerformanceApiINTEL_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInitializeInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkInitializePerformanceApiINTEL(wine_device_from_handle(params->device)->device, params->pInitializeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkInitializePerformanceApiINTEL(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInitializeInfo;
        VkResult result;
    } *params = args;
    VkInitializePerformanceApiInfoINTEL pInitializeInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInitializeInfo);

    convert_VkInitializePerformanceApiInfoINTEL_win32_to_host((const VkInitializePerformanceApiInfoINTEL32 *)UlongToPtr(params->pInitializeInfo), &pInitializeInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkInitializePerformanceApiINTEL(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pInitializeInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkInvalidateMappedMemoryRanges(void *args)
{
    struct vkInvalidateMappedMemoryRanges_params *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win64_to_host(ctx, params->pMemoryRanges, params->memoryRangeCount);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkInvalidateMappedMemoryRanges(wine_device_from_handle(params->device)->device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkInvalidateMappedMemoryRanges(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t memoryRangeCount;
        PTR32 pMemoryRanges;
        VkResult result;
    } *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win32_to_host(ctx, (const VkMappedMemoryRange32 *)UlongToPtr(params->pMemoryRanges), params->memoryRangeCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkInvalidateMappedMemoryRanges(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkLatencySleepNV(void *args)
{
    struct vkLatencySleepNV_params *params = args;
    VkLatencySleepInfoNV pSleepInfo_host;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepInfo);

    convert_VkLatencySleepInfoNV_win64_to_host(params->pSleepInfo, &pSleepInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkLatencySleepNV(wine_device_from_handle(params->device)->device, wine_swapchain_from_handle(params->swapchain)->swapchain, &pSleepInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkLatencySleepNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pSleepInfo;
        VkResult result;
    } *params = args;
    VkLatencySleepInfoNV pSleepInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepInfo);

    convert_VkLatencySleepInfoNV_win32_to_host((const VkLatencySleepInfoNV32 *)UlongToPtr(params->pSleepInfo), &pSleepInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkLatencySleepNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_swapchain_from_handle(params->swapchain)->swapchain, &pSleepInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMapMemory(void *args)
{
    struct vkMapMemory_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s, %#x, %p\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);

    params->result = wine_vkMapMemory(params->device, params->memory, params->offset, params->size, params->flags, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMapMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        VkMemoryMapFlags flags;
        PTR32 ppData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);

    params->result = wine_vkMapMemory((VkDevice)UlongToPtr(params->device), params->memory, params->offset, params->size, params->flags, (void **)UlongToPtr(params->ppData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMapMemory2KHR(void *args)
{
    struct vkMapMemory2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pMemoryMapInfo, params->ppData);

    params->result = wine_vkMapMemory2KHR(params->device, params->pMemoryMapInfo, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMapMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pMemoryMapInfo;
        PTR32 ppData;
        VkResult result;
    } *params = args;
    VkMemoryMapInfoKHR pMemoryMapInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pMemoryMapInfo, params->ppData);

    convert_VkMemoryMapInfoKHR_win32_to_unwrapped_host((const VkMemoryMapInfoKHR32 *)UlongToPtr(params->pMemoryMapInfo), &pMemoryMapInfo_host);
    params->result = wine_vkMapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryMapInfo_host, (void **)UlongToPtr(params->ppData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMergePipelineCaches(void *args)
{
    struct vkMergePipelineCaches_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkMergePipelineCaches(wine_device_from_handle(params->device)->device, params->dstCache, params->srcCacheCount, params->pSrcCaches);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMergePipelineCaches(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) dstCache;
        uint32_t srcCacheCount;
        PTR32 pSrcCaches;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkMergePipelineCaches(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->dstCache, params->srcCacheCount, (const VkPipelineCache *)UlongToPtr(params->pSrcCaches));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMergeValidationCachesEXT(void *args)
{
    struct vkMergeValidationCachesEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkMergeValidationCachesEXT(wine_device_from_handle(params->device)->device, params->dstCache, params->srcCacheCount, params->pSrcCaches);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMergeValidationCachesEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkValidationCacheEXT DECLSPEC_ALIGN(8) dstCache;
        uint32_t srcCacheCount;
        PTR32 pSrcCaches;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkMergeValidationCachesEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->dstCache, params->srcCacheCount, (const VkValidationCacheEXT *)UlongToPtr(params->pSrcCaches));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueBeginDebugUtilsLabelEXT(void *args)
{
    struct vkQueueBeginDebugUtilsLabelEXT_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pLabelInfo);

    wine_queue_from_handle(params->queue)->device->funcs.p_vkQueueBeginDebugUtilsLabelEXT(wine_queue_from_handle(params->queue)->queue, params->pLabelInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueBeginDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    TRACE("%#x, %#x\n", params->queue, params->pLabelInfo);

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkQueueBeginDebugUtilsLabelEXT(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue, &pLabelInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueBindSparse(void *args)
{
    struct vkQueueBindSparse_params *params = args;
    const VkBindSparseInfo *pBindInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->bindInfoCount, params->pBindInfo, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pBindInfo_host = convert_VkBindSparseInfo_array_win64_to_unwrapped_host(ctx, params->pBindInfo, params->bindInfoCount);
    params->result = wine_vkQueueBindSparse(params->queue, params->bindInfoCount, pBindInfo_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueBindSparse(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t bindInfoCount;
        PTR32 pBindInfo;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkBindSparseInfo *pBindInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->bindInfoCount, params->pBindInfo, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pBindInfo_host = convert_VkBindSparseInfo_array_win32_to_unwrapped_host(ctx, (const VkBindSparseInfo32 *)UlongToPtr(params->pBindInfo), params->bindInfoCount);
    params->result = wine_vkQueueBindSparse((VkQueue)UlongToPtr(params->queue), params->bindInfoCount, pBindInfo_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueEndDebugUtilsLabelEXT(void *args)
{
    struct vkQueueEndDebugUtilsLabelEXT_params *params = args;

    TRACE("%p\n", params->queue);

    wine_queue_from_handle(params->queue)->device->funcs.p_vkQueueEndDebugUtilsLabelEXT(wine_queue_from_handle(params->queue)->queue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueEndDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 queue;
    } *params = args;

    TRACE("%#x\n", params->queue);

    wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkQueueEndDebugUtilsLabelEXT(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueInsertDebugUtilsLabelEXT(void *args)
{
    struct vkQueueInsertDebugUtilsLabelEXT_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pLabelInfo);

    wine_queue_from_handle(params->queue)->device->funcs.p_vkQueueInsertDebugUtilsLabelEXT(wine_queue_from_handle(params->queue)->queue, params->pLabelInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueInsertDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    TRACE("%#x, %#x\n", params->queue, params->pLabelInfo);

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkQueueInsertDebugUtilsLabelEXT(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue, &pLabelInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueNotifyOutOfBandNV(void *args)
{
    struct vkQueueNotifyOutOfBandNV_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pQueueTypeInfo);

    wine_queue_from_handle(params->queue)->device->funcs.p_vkQueueNotifyOutOfBandNV(wine_queue_from_handle(params->queue)->queue, params->pQueueTypeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueNotifyOutOfBandNV(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pQueueTypeInfo;
    } *params = args;
    VkOutOfBandQueueTypeInfoNV pQueueTypeInfo_host;

    TRACE("%#x, %#x\n", params->queue, params->pQueueTypeInfo);

    convert_VkOutOfBandQueueTypeInfoNV_win32_to_host((const VkOutOfBandQueueTypeInfoNV32 *)UlongToPtr(params->pQueueTypeInfo), &pQueueTypeInfo_host);
    wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkQueueNotifyOutOfBandNV(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue, &pQueueTypeInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueuePresentKHR(void *args)
{
    struct vkQueuePresentKHR_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pPresentInfo);

    params->result = wine_vkQueuePresentKHR(params->queue, params->pPresentInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueuePresentKHR(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pPresentInfo;
        VkResult result;
    } *params = args;
    VkPresentInfoKHR pPresentInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->queue, params->pPresentInfo);

    init_conversion_context(ctx);
    convert_VkPresentInfoKHR_win32_to_unwrapped_host(ctx, (const VkPresentInfoKHR32 *)UlongToPtr(params->pPresentInfo), &pPresentInfo_host);
    params->result = wine_vkQueuePresentKHR((VkQueue)UlongToPtr(params->queue), &pPresentInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSetPerformanceConfigurationINTEL(void *args)
{
    struct vkQueueSetPerformanceConfigurationINTEL_params *params = args;

    TRACE("%p, 0x%s\n", params->queue, wine_dbgstr_longlong(params->configuration));

    params->result = wine_queue_from_handle(params->queue)->device->funcs.p_vkQueueSetPerformanceConfigurationINTEL(wine_queue_from_handle(params->queue)->queue, params->configuration);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSetPerformanceConfigurationINTEL(void *args)
{
    struct
    {
        PTR32 queue;
        VkPerformanceConfigurationINTEL DECLSPEC_ALIGN(8) configuration;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->queue, wine_dbgstr_longlong(params->configuration));

    params->result = wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkQueueSetPerformanceConfigurationINTEL(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue, params->configuration);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSubmit(void *args)
{
    struct vkQueueSubmit_params *params = args;
    const VkSubmitInfo *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
    params->result = wine_vkQueueSubmit(params->queue, params->submitCount, pSubmits_host, params->fence, (void *)params->pSubmits);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSubmit(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t submitCount;
        PTR32 pSubmits;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkSubmitInfo *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo32 *)UlongToPtr(params->pSubmits), params->submitCount);
    params->result = wine_vkQueueSubmit((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence, UlongToPtr(params->pSubmits));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSubmit2(void *args)
{
    struct vkQueueSubmit2_params *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
    params->result = wine_vkQueueSubmit2(params->queue, params->submitCount, pSubmits_host, params->fence, (void *)params->pSubmits);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSubmit2(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t submitCount;
        PTR32 pSubmits;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
    params->result = wine_vkQueueSubmit2((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence, UlongToPtr(params->pSubmits));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSubmit2KHR(void *args)
{
    struct vkQueueSubmit2KHR_params *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
    params->result = wine_vkQueueSubmit2KHR(params->queue, params->submitCount, pSubmits_host, params->fence, (void *)params->pSubmits);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSubmit2KHR(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t submitCount;
        PTR32 pSubmits;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
    params->result = wine_vkQueueSubmit2KHR((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence, UlongToPtr(params->pSubmits));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueWaitIdle(void *args)
{
    struct vkQueueWaitIdle_params *params = args;

    TRACE("%p\n", params->queue);

    params->result = wine_queue_from_handle(params->queue)->device->funcs.p_vkQueueWaitIdle(wine_queue_from_handle(params->queue)->queue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueWaitIdle(void *args)
{
    struct
    {
        PTR32 queue;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->queue);

    params->result = wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->funcs.p_vkQueueWaitIdle(wine_queue_from_handle((VkQueue)UlongToPtr(params->queue))->queue);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleasePerformanceConfigurationINTEL(void *args)
{
    struct vkReleasePerformanceConfigurationINTEL_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->configuration));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkReleasePerformanceConfigurationINTEL(wine_device_from_handle(params->device)->device, params->configuration);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleasePerformanceConfigurationINTEL(void *args)
{
    struct
    {
        PTR32 device;
        VkPerformanceConfigurationINTEL DECLSPEC_ALIGN(8) configuration;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->configuration));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkReleasePerformanceConfigurationINTEL(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->configuration);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleaseProfilingLockKHR(void *args)
{
    struct vkReleaseProfilingLockKHR_params *params = args;

    TRACE("%p\n", params->device);

    wine_device_from_handle(params->device)->funcs.p_vkReleaseProfilingLockKHR(wine_device_from_handle(params->device)->device);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleaseProfilingLockKHR(void *args)
{
    struct
    {
        PTR32 device;
    } *params = args;

    TRACE("%#x\n", params->device);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkReleaseProfilingLockKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleaseSwapchainImagesEXT(void *args)
{
    struct vkReleaseSwapchainImagesEXT_params *params = args;
    VkReleaseSwapchainImagesInfoEXT pReleaseInfo_host;

    TRACE("%p, %p\n", params->device, params->pReleaseInfo);

    convert_VkReleaseSwapchainImagesInfoEXT_win64_to_host(params->pReleaseInfo, &pReleaseInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkReleaseSwapchainImagesEXT(wine_device_from_handle(params->device)->device, &pReleaseInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleaseSwapchainImagesEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pReleaseInfo;
        VkResult result;
    } *params = args;
    VkReleaseSwapchainImagesInfoEXT pReleaseInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pReleaseInfo);

    convert_VkReleaseSwapchainImagesInfoEXT_win32_to_host((const VkReleaseSwapchainImagesInfoEXT32 *)UlongToPtr(params->pReleaseInfo), &pReleaseInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkReleaseSwapchainImagesEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pReleaseInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetCommandBuffer(void *args)
{
    struct vkResetCommandBuffer_params *params = args;

    TRACE("%p, %#x\n", params->commandBuffer, params->flags);

    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkResetCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetCommandBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCommandBufferResetFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x\n", params->commandBuffer, params->flags);

    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkResetCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetCommandPool(void *args)
{
    struct vkResetCommandPool_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkResetCommandPool(wine_device_from_handle(params->device)->device, wine_cmd_pool_from_handle(params->commandPool)->command_pool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        VkCommandPoolResetFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkResetCommandPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_cmd_pool_from_handle(params->commandPool)->command_pool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetDescriptorPool(void *args)
{
    struct vkResetDescriptorPool_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->flags);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkResetDescriptorPool(wine_device_from_handle(params->device)->device, params->descriptorPool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetDescriptorPool(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
        VkDescriptorPoolResetFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->flags);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkResetDescriptorPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorPool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetEvent(void *args)
{
    struct vkResetEvent_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkResetEvent(wine_device_from_handle(params->device)->device, params->event);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetEvent(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkResetEvent(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->event);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetFences(void *args)
{
    struct vkResetFences_params *params = args;

    TRACE("%p, %u, %p\n", params->device, params->fenceCount, params->pFences);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkResetFences(wine_device_from_handle(params->device)->device, params->fenceCount, params->pFences);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetFences(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t fenceCount;
        PTR32 pFences;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, %#x\n", params->device, params->fenceCount, params->pFences);

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkResetFences(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->fenceCount, (const VkFence *)UlongToPtr(params->pFences));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetQueryPool(void *args)
{
    struct vkResetQueryPool_params *params = args;

    TRACE("%p, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    wine_device_from_handle(params->device)->funcs.p_vkResetQueryPool(wine_device_from_handle(params->device)->device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetQueryPool(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkResetQueryPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetQueryPoolEXT(void *args)
{
    struct vkResetQueryPoolEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    wine_device_from_handle(params->device)->funcs.p_vkResetQueryPoolEXT(wine_device_from_handle(params->device)->device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetQueryPoolEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkResetQueryPoolEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetDebugUtilsObjectNameEXT(void *args)
{
    struct vkSetDebugUtilsObjectNameEXT_params *params = args;
    VkDebugUtilsObjectNameInfoEXT pNameInfo_host;

    TRACE("%p, %p\n", params->device, params->pNameInfo);

    convert_VkDebugUtilsObjectNameInfoEXT_win64_to_host(params->pNameInfo, &pNameInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkSetDebugUtilsObjectNameEXT(wine_device_from_handle(params->device)->device, &pNameInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetDebugUtilsObjectNameEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pNameInfo;
        VkResult result;
    } *params = args;
    VkDebugUtilsObjectNameInfoEXT pNameInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pNameInfo);

    convert_VkDebugUtilsObjectNameInfoEXT_win32_to_host((const VkDebugUtilsObjectNameInfoEXT32 *)UlongToPtr(params->pNameInfo), &pNameInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetDebugUtilsObjectNameEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pNameInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetDebugUtilsObjectTagEXT(void *args)
{
    struct vkSetDebugUtilsObjectTagEXT_params *params = args;
    VkDebugUtilsObjectTagInfoEXT pTagInfo_host;

    TRACE("%p, %p\n", params->device, params->pTagInfo);

    convert_VkDebugUtilsObjectTagInfoEXT_win64_to_host(params->pTagInfo, &pTagInfo_host);
    params->result = wine_device_from_handle(params->device)->funcs.p_vkSetDebugUtilsObjectTagEXT(wine_device_from_handle(params->device)->device, &pTagInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetDebugUtilsObjectTagEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pTagInfo;
        VkResult result;
    } *params = args;
    VkDebugUtilsObjectTagInfoEXT pTagInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pTagInfo);

    convert_VkDebugUtilsObjectTagInfoEXT_win32_to_host((const VkDebugUtilsObjectTagInfoEXT32 *)UlongToPtr(params->pTagInfo), &pTagInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetDebugUtilsObjectTagEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, &pTagInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetDeviceMemoryPriorityEXT(void *args)
{
    struct vkSetDeviceMemoryPriorityEXT_params *params = args;

    TRACE("%p, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);

    wine_device_from_handle(params->device)->funcs.p_vkSetDeviceMemoryPriorityEXT(wine_device_from_handle(params->device)->device, wine_device_memory_from_handle(params->memory)->memory, params->priority);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetDeviceMemoryPriorityEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        float priority;
    } *params = args;

    TRACE("%#x, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetDeviceMemoryPriorityEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_device_memory_from_handle(params->memory)->memory, params->priority);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetEvent(void *args)
{
    struct vkSetEvent_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkSetEvent(wine_device_from_handle(params->device)->device, params->event);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetEvent(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetEvent(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->event);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetHdrMetadataEXT(void *args)
{
    struct vkSetHdrMetadataEXT_params *params = args;
    const VkSwapchainKHR *pSwapchains_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, %p\n", params->device, params->swapchainCount, params->pSwapchains, params->pMetadata);

    init_conversion_context(ctx);
    pSwapchains_host = convert_VkSwapchainKHR_array_win64_to_host(ctx, params->pSwapchains, params->swapchainCount);
    wine_device_from_handle(params->device)->funcs.p_vkSetHdrMetadataEXT(wine_device_from_handle(params->device)->device, params->swapchainCount, pSwapchains_host, params->pMetadata);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetHdrMetadataEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t swapchainCount;
        PTR32 pSwapchains;
        PTR32 pMetadata;
    } *params = args;
    const VkSwapchainKHR *pSwapchains_host;
    const VkHdrMetadataEXT *pMetadata_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x\n", params->device, params->swapchainCount, params->pSwapchains, params->pMetadata);

    init_conversion_context(ctx);
    pSwapchains_host = convert_VkSwapchainKHR_array_win32_to_host(ctx, (const VkSwapchainKHR *)UlongToPtr(params->pSwapchains), params->swapchainCount);
    pMetadata_host = convert_VkHdrMetadataEXT_array_win32_to_host(ctx, (const VkHdrMetadataEXT32 *)UlongToPtr(params->pMetadata), params->swapchainCount);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetHdrMetadataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->swapchainCount, pSwapchains_host, pMetadata_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetLatencyMarkerNV(void *args)
{
    struct vkSetLatencyMarkerNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pLatencyMarkerInfo);

    wine_device_from_handle(params->device)->funcs.p_vkSetLatencyMarkerNV(wine_device_from_handle(params->device)->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->pLatencyMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetLatencyMarkerNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pLatencyMarkerInfo;
    } *params = args;
    VkSetLatencyMarkerInfoNV pLatencyMarkerInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pLatencyMarkerInfo);

    convert_VkSetLatencyMarkerInfoNV_win32_to_host((const VkSetLatencyMarkerInfoNV32 *)UlongToPtr(params->pLatencyMarkerInfo), &pLatencyMarkerInfo_host);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetLatencyMarkerNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_swapchain_from_handle(params->swapchain)->swapchain, &pLatencyMarkerInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetLatencySleepModeNV(void *args)
{
    struct vkSetLatencySleepModeNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepModeInfo);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkSetLatencySleepModeNV(wine_device_from_handle(params->device)->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->pSleepModeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetLatencySleepModeNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pSleepModeInfo;
        VkResult result;
    } *params = args;
    VkLatencySleepModeInfoNV pSleepModeInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepModeInfo);

    convert_VkLatencySleepModeInfoNV_win32_to_host((const VkLatencySleepModeInfoNV32 *)UlongToPtr(params->pSleepModeInfo), &pSleepModeInfo_host);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetLatencySleepModeNV(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_swapchain_from_handle(params->swapchain)->swapchain, &pSleepModeInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetPrivateData(void *args)
{
    struct vkSetPrivateData_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkSetPrivateData(wine_device_from_handle(params->device)->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetPrivateData(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        uint64_t DECLSPEC_ALIGN(8) data;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetPrivateData(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetPrivateDataEXT(void *args)
{
    struct vkSetPrivateDataEXT_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkSetPrivateDataEXT(wine_device_from_handle(params->device)->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetPrivateDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        uint64_t DECLSPEC_ALIGN(8) data;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetPrivateDataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSignalSemaphore(void *args)
{
    struct vkSignalSemaphore_params *params = args;

    TRACE("%p, %p\n", params->device, params->pSignalInfo);

    params->result = wine_vkSignalSemaphore(params->device, params->pSignalInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSignalSemaphore(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pSignalInfo;
        VkResult result;
    } *params = args;
    VkSemaphoreSignalInfo pSignalInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pSignalInfo);

    convert_VkSemaphoreSignalInfo_win32_to_unwrapped_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
    params->result = wine_vkSignalSemaphore((VkDevice)UlongToPtr(params->device), &pSignalInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSignalSemaphoreKHR(void *args)
{
    struct vkSignalSemaphoreKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pSignalInfo);

    params->result = wine_vkSignalSemaphoreKHR(params->device, params->pSignalInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSignalSemaphoreKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pSignalInfo;
        VkResult result;
    } *params = args;
    VkSemaphoreSignalInfo pSignalInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pSignalInfo);

    convert_VkSemaphoreSignalInfo_win32_to_unwrapped_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
    params->result = wine_vkSignalSemaphoreKHR((VkDevice)UlongToPtr(params->device), &pSignalInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSubmitDebugUtilsMessageEXT(void *args)
{
    struct vkSubmitDebugUtilsMessageEXT_params *params = args;
    VkDebugUtilsMessengerCallbackDataEXT pCallbackData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %#x, %#x, %p\n", params->instance, params->messageSeverity, params->messageTypes, params->pCallbackData);

    init_conversion_context(ctx);
    convert_VkDebugUtilsMessengerCallbackDataEXT_win64_to_host(ctx, params->pCallbackData, &pCallbackData_host);
    wine_instance_from_handle(params->instance)->funcs.p_vkSubmitDebugUtilsMessageEXT(wine_instance_from_handle(params->instance)->instance, params->messageSeverity, params->messageTypes, &pCallbackData_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSubmitDebugUtilsMessageEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
        VkDebugUtilsMessageTypeFlagsEXT messageTypes;
        PTR32 pCallbackData;
    } *params = args;
    VkDebugUtilsMessengerCallbackDataEXT pCallbackData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->messageSeverity, params->messageTypes, params->pCallbackData);

    init_conversion_context(ctx);
    convert_VkDebugUtilsMessengerCallbackDataEXT_win32_to_host(ctx, (const VkDebugUtilsMessengerCallbackDataEXT32 *)UlongToPtr(params->pCallbackData), &pCallbackData_host);
    wine_instance_from_handle((VkInstance)UlongToPtr(params->instance))->funcs.p_vkSubmitDebugUtilsMessageEXT(wine_instance_from_handle((VkInstance)UlongToPtr(params->instance))->instance, params->messageSeverity, params->messageTypes, &pCallbackData_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTransitionImageLayoutEXT(void *args)
{
    struct vkTransitionImageLayoutEXT_params *params = args;

    TRACE("%p, %u, %p\n", params->device, params->transitionCount, params->pTransitions);

    params->result = wine_device_from_handle(params->device)->funcs.p_vkTransitionImageLayoutEXT(wine_device_from_handle(params->device)->device, params->transitionCount, params->pTransitions);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTransitionImageLayoutEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t transitionCount;
        PTR32 pTransitions;
        VkResult result;
    } *params = args;
    const VkHostImageLayoutTransitionInfoEXT *pTransitions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->transitionCount, params->pTransitions);

    init_conversion_context(ctx);
    pTransitions_host = convert_VkHostImageLayoutTransitionInfoEXT_array_win32_to_host(ctx, (const VkHostImageLayoutTransitionInfoEXT32 *)UlongToPtr(params->pTransitions), params->transitionCount);
    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkTransitionImageLayoutEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->transitionCount, pTransitions_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTrimCommandPool(void *args)
{
    struct vkTrimCommandPool_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    wine_device_from_handle(params->device)->funcs.p_vkTrimCommandPool(wine_device_from_handle(params->device)->device, wine_cmd_pool_from_handle(params->commandPool)->command_pool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTrimCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        VkCommandPoolTrimFlags flags;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkTrimCommandPool(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_cmd_pool_from_handle(params->commandPool)->command_pool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTrimCommandPoolKHR(void *args)
{
    struct vkTrimCommandPoolKHR_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    wine_device_from_handle(params->device)->funcs.p_vkTrimCommandPoolKHR(wine_device_from_handle(params->device)->device, wine_cmd_pool_from_handle(params->commandPool)->command_pool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTrimCommandPoolKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        VkCommandPoolTrimFlags flags;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkTrimCommandPoolKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_cmd_pool_from_handle(params->commandPool)->command_pool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUninitializePerformanceApiINTEL(void *args)
{
    struct vkUninitializePerformanceApiINTEL_params *params = args;

    TRACE("%p\n", params->device);

    wine_device_from_handle(params->device)->funcs.p_vkUninitializePerformanceApiINTEL(wine_device_from_handle(params->device)->device);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUninitializePerformanceApiINTEL(void *args)
{
    struct
    {
        PTR32 device;
    } *params = args;

    TRACE("%#x\n", params->device);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkUninitializePerformanceApiINTEL(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUnmapMemory(void *args)
{
    struct vkUnmapMemory_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));

    wine_vkUnmapMemory(params->device, params->memory);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUnmapMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));

    wine_vkUnmapMemory((VkDevice)UlongToPtr(params->device), params->memory);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUnmapMemory2KHR(void *args)
{
    struct vkUnmapMemory2KHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pMemoryUnmapInfo);

    params->result = wine_vkUnmapMemory2KHR(params->device, params->pMemoryUnmapInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUnmapMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pMemoryUnmapInfo;
        VkResult result;
    } *params = args;
    VkMemoryUnmapInfoKHR pMemoryUnmapInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pMemoryUnmapInfo);

    convert_VkMemoryUnmapInfoKHR_win32_to_unwrapped_host((const VkMemoryUnmapInfoKHR32 *)UlongToPtr(params->pMemoryUnmapInfo), &pMemoryUnmapInfo_host);
    params->result = wine_vkUnmapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryUnmapInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkUpdateDescriptorSetWithTemplate(void *args)
{
    struct vkUpdateDescriptorSetWithTemplate_params *params = args;

    wine_device_from_handle(params->device)->funcs.p_vkUpdateDescriptorSetWithTemplate(wine_device_from_handle(params->device)->device, params->descriptorSet, params->descriptorUpdateTemplate, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkUpdateDescriptorSetWithTemplate(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSet DECLSPEC_ALIGN(8) descriptorSet;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pData;
    } *params = args;

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkUpdateDescriptorSetWithTemplate(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorSet, params->descriptorUpdateTemplate, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUpdateDescriptorSetWithTemplateKHR(void *args)
{
    struct vkUpdateDescriptorSetWithTemplateKHR_params *params = args;

    TRACE("%p, 0x%s, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorSet), wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pData);

    wine_device_from_handle(params->device)->funcs.p_vkUpdateDescriptorSetWithTemplateKHR(wine_device_from_handle(params->device)->device, params->descriptorSet, params->descriptorUpdateTemplate, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUpdateDescriptorSetWithTemplateKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSet DECLSPEC_ALIGN(8) descriptorSet;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pData;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorSet), wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pData);

    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkUpdateDescriptorSetWithTemplateKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorSet, params->descriptorUpdateTemplate, (const void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkUpdateDescriptorSets(void *args)
{
    struct vkUpdateDescriptorSets_params *params = args;

    wine_device_from_handle(params->device)->funcs.p_vkUpdateDescriptorSets(wine_device_from_handle(params->device)->device, params->descriptorWriteCount, params->pDescriptorWrites, params->descriptorCopyCount, params->pDescriptorCopies);
}
#endif /* _WIN64 */

static void thunk32_vkUpdateDescriptorSets(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t descriptorWriteCount;
        PTR32 pDescriptorWrites;
        uint32_t descriptorCopyCount;
        PTR32 pDescriptorCopies;
    } *params = args;
    const VkWriteDescriptorSet *pDescriptorWrites_host;
    const VkCopyDescriptorSet *pDescriptorCopies_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
    pDescriptorCopies_host = convert_VkCopyDescriptorSet_array_win32_to_host(ctx, (const VkCopyDescriptorSet32 *)UlongToPtr(params->pDescriptorCopies), params->descriptorCopyCount);
    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkUpdateDescriptorSets(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->descriptorWriteCount, pDescriptorWrites_host, params->descriptorCopyCount, pDescriptorCopies_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitForFences(void *args)
{
    struct vkWaitForFences_params *params = args;

    TRACE("%p, %u, %p, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkWaitForFences(wine_device_from_handle(params->device)->device, params->fenceCount, params->pFences, params->waitAll, params->timeout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitForFences(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t fenceCount;
        PTR32 pFences;
        VkBool32 waitAll;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, %#x, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkWaitForFences(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->fenceCount, (const VkFence *)UlongToPtr(params->pFences), params->waitAll, params->timeout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitForPresentKHR(void *args)
{
    struct vkWaitForPresentKHR_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->presentId), wine_dbgstr_longlong(params->timeout));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkWaitForPresentKHR(wine_device_from_handle(params->device)->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->presentId, params->timeout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitForPresentKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        uint64_t DECLSPEC_ALIGN(8) presentId;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->presentId), wine_dbgstr_longlong(params->timeout));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkWaitForPresentKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, wine_swapchain_from_handle(params->swapchain)->swapchain, params->presentId, params->timeout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitSemaphores(void *args)
{
    struct vkWaitSemaphores_params *params = args;

    TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    params->result = wine_vkWaitSemaphores(params->device, params->pWaitInfo, params->timeout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitSemaphores(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pWaitInfo;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;
    VkSemaphoreWaitInfo pWaitInfo_host;

    TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    convert_VkSemaphoreWaitInfo_win32_to_unwrapped_host((const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
    params->result = wine_vkWaitSemaphores((VkDevice)UlongToPtr(params->device), &pWaitInfo_host, params->timeout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitSemaphoresKHR(void *args)
{
    struct vkWaitSemaphoresKHR_params *params = args;

    TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    params->result = wine_vkWaitSemaphoresKHR(params->device, params->pWaitInfo, params->timeout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitSemaphoresKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pWaitInfo;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;
    VkSemaphoreWaitInfo pWaitInfo_host;

    TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    convert_VkSemaphoreWaitInfo_win32_to_unwrapped_host((const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
    params->result = wine_vkWaitSemaphoresKHR((VkDevice)UlongToPtr(params->device), &pWaitInfo_host, params->timeout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct vkWriteAccelerationStructuresPropertiesKHR_params *params = args;

    TRACE("%p, %u, %p, %#x, 0x%s, %p, 0x%s\n", params->device, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkWriteAccelerationStructuresPropertiesKHR(wine_device_from_handle(params->device)->device, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->dataSize, params->pData, params->stride);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t accelerationStructureCount;
        PTR32 pAccelerationStructures;
        VkQueryType queryType;
        PTR32 dataSize;
        PTR32 pData;
        PTR32 stride;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, %#x, %#x, 0x%s, %#x, 0x%s\n", params->device, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkWriteAccelerationStructuresPropertiesKHR(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->dataSize, (void *)UlongToPtr(params->pData), params->stride);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWriteMicromapsPropertiesEXT(void *args)
{
    struct vkWriteMicromapsPropertiesEXT_params *params = args;

    TRACE("%p, %u, %p, %#x, 0x%s, %p, 0x%s\n", params->device, params->micromapCount, params->pMicromaps, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = wine_device_from_handle(params->device)->funcs.p_vkWriteMicromapsPropertiesEXT(wine_device_from_handle(params->device)->device, params->micromapCount, params->pMicromaps, params->queryType, params->dataSize, params->pData, params->stride);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWriteMicromapsPropertiesEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t micromapCount;
        PTR32 pMicromaps;
        VkQueryType queryType;
        PTR32 dataSize;
        PTR32 pData;
        PTR32 stride;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, %#x, %#x, 0x%s, %#x, 0x%s\n", params->device, params->micromapCount, params->pMicromaps, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkWriteMicromapsPropertiesEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->dataSize, (void *)UlongToPtr(params->pData), params->stride);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_wine_vkAcquireKeyedMutex(void *args)
{
    struct wine_vkAcquireKeyedMutex_params *params = args;

    TRACE("%p, 0x%s, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key), params->timeout_ms);

    params->result = wine_wine_vkAcquireKeyedMutex(params->device, params->memory, params->key, params->timeout_ms);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_wine_vkAcquireKeyedMutex(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        uint64_t DECLSPEC_ALIGN(8) key;
        uint32_t timeout_ms;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key), params->timeout_ms);

    params->result = wine_wine_vkAcquireKeyedMutex((VkDevice)UlongToPtr(params->device), params->memory, params->key, params->timeout_ms);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_wine_vkReleaseKeyedMutex(void *args)
{
    struct wine_vkReleaseKeyedMutex_params *params = args;

    TRACE("%p, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key));

    params->result = wine_wine_vkReleaseKeyedMutex(params->device, params->memory, params->key);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_wine_vkReleaseKeyedMutex(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        uint64_t DECLSPEC_ALIGN(8) key;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key));

    params->result = wine_wine_vkReleaseKeyedMutex((VkDevice)UlongToPtr(params->device), params->memory, params->key);
    return STATUS_SUCCESS;
}

static const char * const vk_device_extensions[] =
{
    "VK_AMD_buffer_marker",
    "VK_AMD_device_coherent_memory",
    "VK_AMD_draw_indirect_count",
    "VK_AMD_gcn_shader",
    "VK_AMD_gpu_shader_half_float",
    "VK_AMD_gpu_shader_int16",
    "VK_AMD_memory_overallocation_behavior",
    "VK_AMD_mixed_attachment_samples",
    "VK_AMD_negative_viewport_height",
    "VK_AMD_pipeline_compiler_control",
    "VK_AMD_rasterization_order",
    "VK_AMD_shader_ballot",
    "VK_AMD_shader_core_properties",
    "VK_AMD_shader_core_properties2",
    "VK_AMD_shader_early_and_late_fragment_tests",
    "VK_AMD_shader_explicit_vertex_parameter",
    "VK_AMD_shader_fragment_mask",
    "VK_AMD_shader_image_load_store_lod",
    "VK_AMD_shader_info",
    "VK_AMD_shader_trinary_minmax",
    "VK_AMD_texture_gather_bias_lod",
    "VK_ARM_rasterization_order_attachment_access",
    "VK_ARM_shader_core_builtins",
    "VK_ARM_shader_core_properties",
    "VK_EXT_4444_formats",
    "VK_EXT_astc_decode_mode",
    "VK_EXT_attachment_feedback_loop_dynamic_state",
    "VK_EXT_attachment_feedback_loop_layout",
    "VK_EXT_blend_operation_advanced",
    "VK_EXT_border_color_swizzle",
    "VK_EXT_buffer_device_address",
    "VK_EXT_calibrated_timestamps",
    "VK_EXT_color_write_enable",
    "VK_EXT_conditional_rendering",
    "VK_EXT_conservative_rasterization",
    "VK_EXT_custom_border_color",
    "VK_EXT_debug_marker",
    "VK_EXT_depth_bias_control",
    "VK_EXT_depth_clamp_zero_one",
    "VK_EXT_depth_clip_control",
    "VK_EXT_depth_clip_enable",
    "VK_EXT_depth_range_unrestricted",
    "VK_EXT_descriptor_buffer",
    "VK_EXT_descriptor_indexing",
    "VK_EXT_device_address_binding_report",
    "VK_EXT_device_fault",
    "VK_EXT_discard_rectangles",
    "VK_EXT_dynamic_rendering_unused_attachments",
    "VK_EXT_extended_dynamic_state",
    "VK_EXT_extended_dynamic_state2",
    "VK_EXT_extended_dynamic_state3",
    "VK_EXT_external_memory_acquire_unmodified",
    "VK_EXT_external_memory_host",
    "VK_EXT_filter_cubic",
    "VK_EXT_fragment_density_map",
    "VK_EXT_fragment_density_map2",
    "VK_EXT_fragment_shader_interlock",
    "VK_EXT_frame_boundary",
    "VK_EXT_global_priority",
    "VK_EXT_global_priority_query",
    "VK_EXT_graphics_pipeline_library",
    "VK_EXT_hdr_metadata",
    "VK_EXT_host_image_copy",
    "VK_EXT_host_query_reset",
    "VK_EXT_image_2d_view_of_3d",
    "VK_EXT_image_compression_control",
    "VK_EXT_image_compression_control_swapchain",
    "VK_EXT_image_robustness",
    "VK_EXT_image_sliced_view_of_3d",
    "VK_EXT_image_view_min_lod",
    "VK_EXT_index_type_uint8",
    "VK_EXT_inline_uniform_block",
    "VK_EXT_legacy_dithering",
    "VK_EXT_line_rasterization",
    "VK_EXT_load_store_op_none",
    "VK_EXT_memory_budget",
    "VK_EXT_memory_priority",
    "VK_EXT_mesh_shader",
    "VK_EXT_multi_draw",
    "VK_EXT_multisampled_render_to_single_sampled",
    "VK_EXT_mutable_descriptor_type",
    "VK_EXT_nested_command_buffer",
    "VK_EXT_non_seamless_cube_map",
    "VK_EXT_opacity_micromap",
    "VK_EXT_pageable_device_local_memory",
    "VK_EXT_pci_bus_info",
    "VK_EXT_pipeline_creation_cache_control",
    "VK_EXT_pipeline_creation_feedback",
    "VK_EXT_pipeline_library_group_handles",
    "VK_EXT_pipeline_properties",
    "VK_EXT_pipeline_protected_access",
    "VK_EXT_pipeline_robustness",
    "VK_EXT_post_depth_coverage",
    "VK_EXT_primitive_topology_list_restart",
    "VK_EXT_primitives_generated_query",
    "VK_EXT_private_data",
    "VK_EXT_provoking_vertex",
    "VK_EXT_queue_family_foreign",
    "VK_EXT_rasterization_order_attachment_access",
    "VK_EXT_rgba10x6_formats",
    "VK_EXT_robustness2",
    "VK_EXT_sample_locations",
    "VK_EXT_sampler_filter_minmax",
    "VK_EXT_scalar_block_layout",
    "VK_EXT_separate_stencil_usage",
    "VK_EXT_shader_atomic_float",
    "VK_EXT_shader_atomic_float2",
    "VK_EXT_shader_demote_to_helper_invocation",
    "VK_EXT_shader_image_atomic_int64",
    "VK_EXT_shader_module_identifier",
    "VK_EXT_shader_object",
    "VK_EXT_shader_stencil_export",
    "VK_EXT_shader_subgroup_ballot",
    "VK_EXT_shader_subgroup_vote",
    "VK_EXT_shader_tile_image",
    "VK_EXT_shader_viewport_index_layer",
    "VK_EXT_subgroup_size_control",
    "VK_EXT_subpass_merge_feedback",
    "VK_EXT_swapchain_maintenance1",
    "VK_EXT_texel_buffer_alignment",
    "VK_EXT_texture_compression_astc_hdr",
    "VK_EXT_tooling_info",
    "VK_EXT_transform_feedback",
    "VK_EXT_validation_cache",
    "VK_EXT_vertex_attribute_divisor",
    "VK_EXT_vertex_input_dynamic_state",
    "VK_EXT_ycbcr_2plane_444_formats",
    "VK_EXT_ycbcr_image_arrays",
    "VK_GOOGLE_decorate_string",
    "VK_GOOGLE_hlsl_functionality1",
    "VK_GOOGLE_user_type",
    "VK_HUAWEI_cluster_culling_shader",
    "VK_HUAWEI_invocation_mask",
    "VK_HUAWEI_subpass_shading",
    "VK_IMG_filter_cubic",
    "VK_IMG_format_pvrtc",
    "VK_INTEL_performance_query",
    "VK_INTEL_shader_integer_functions2",
    "VK_KHR_16bit_storage",
    "VK_KHR_8bit_storage",
    "VK_KHR_acceleration_structure",
    "VK_KHR_bind_memory2",
    "VK_KHR_buffer_device_address",
    "VK_KHR_cooperative_matrix",
    "VK_KHR_copy_commands2",
    "VK_KHR_create_renderpass2",
    "VK_KHR_dedicated_allocation",
    "VK_KHR_deferred_host_operations",
    "VK_KHR_depth_stencil_resolve",
    "VK_KHR_descriptor_update_template",
    "VK_KHR_device_group",
    "VK_KHR_draw_indirect_count",
    "VK_KHR_driver_properties",
    "VK_KHR_dynamic_rendering",
    "VK_KHR_external_fence",
    "VK_KHR_external_memory",
    "VK_KHR_external_memory_fd",
    "VK_KHR_external_memory_win32",
    "VK_KHR_external_semaphore",
    "VK_KHR_external_semaphore_fd",
    "VK_KHR_external_semaphore_win32",
    "VK_KHR_format_feature_flags2",
    "VK_KHR_fragment_shader_barycentric",
    "VK_KHR_fragment_shading_rate",
    "VK_KHR_get_memory_requirements2",
    "VK_KHR_global_priority",
    "VK_KHR_image_format_list",
    "VK_KHR_imageless_framebuffer",
    "VK_KHR_incremental_present",
    "VK_KHR_maintenance1",
    "VK_KHR_maintenance2",
    "VK_KHR_maintenance3",
    "VK_KHR_maintenance4",
    "VK_KHR_maintenance5",
    "VK_KHR_map_memory2",
    "VK_KHR_multiview",
    "VK_KHR_performance_query",
    "VK_KHR_pipeline_executable_properties",
    "VK_KHR_pipeline_library",
    "VK_KHR_present_id",
    "VK_KHR_present_wait",
    "VK_KHR_push_descriptor",
    "VK_KHR_ray_query",
    "VK_KHR_ray_tracing_maintenance1",
    "VK_KHR_ray_tracing_pipeline",
    "VK_KHR_ray_tracing_position_fetch",
    "VK_KHR_relaxed_block_layout",
    "VK_KHR_sampler_mirror_clamp_to_edge",
    "VK_KHR_sampler_ycbcr_conversion",
    "VK_KHR_separate_depth_stencil_layouts",
    "VK_KHR_shader_atomic_int64",
    "VK_KHR_shader_clock",
    "VK_KHR_shader_draw_parameters",
    "VK_KHR_shader_float16_int8",
    "VK_KHR_shader_float_controls",
    "VK_KHR_shader_integer_dot_product",
    "VK_KHR_shader_non_semantic_info",
    "VK_KHR_shader_subgroup_extended_types",
    "VK_KHR_shader_subgroup_uniform_control_flow",
    "VK_KHR_shader_terminate_invocation",
    "VK_KHR_spirv_1_4",
    "VK_KHR_storage_buffer_storage_class",
    "VK_KHR_swapchain",
    "VK_KHR_swapchain_mutable_format",
    "VK_KHR_synchronization2",
    "VK_KHR_timeline_semaphore",
    "VK_KHR_uniform_buffer_standard_layout",
    "VK_KHR_variable_pointers",
    "VK_KHR_vulkan_memory_model",
    "VK_KHR_win32_keyed_mutex",
    "VK_KHR_workgroup_memory_explicit_layout",
    "VK_KHR_zero_initialize_workgroup_memory",
    "VK_MSFT_layered_driver",
    "VK_NVX_binary_import",
    "VK_NVX_image_view_handle",
    "VK_NV_clip_space_w_scaling",
    "VK_NV_compute_shader_derivatives",
    "VK_NV_cooperative_matrix",
    "VK_NV_copy_memory_indirect",
    "VK_NV_corner_sampled_image",
    "VK_NV_coverage_reduction_mode",
    "VK_NV_dedicated_allocation",
    "VK_NV_dedicated_allocation_image_aliasing",
    "VK_NV_descriptor_pool_overallocation",
    "VK_NV_device_diagnostic_checkpoints",
    "VK_NV_device_diagnostics_config",
    "VK_NV_device_generated_commands",
    "VK_NV_device_generated_commands_compute",
    "VK_NV_extended_sparse_address_space",
    "VK_NV_fill_rectangle",
    "VK_NV_fragment_coverage_to_color",
    "VK_NV_fragment_shader_barycentric",
    "VK_NV_fragment_shading_rate_enums",
    "VK_NV_framebuffer_mixed_samples",
    "VK_NV_geometry_shader_passthrough",
    "VK_NV_glsl_shader",
    "VK_NV_inherited_viewport_scissor",
    "VK_NV_linear_color_attachment",
    "VK_NV_low_latency",
    "VK_NV_low_latency2",
    "VK_NV_memory_decompression",
    "VK_NV_mesh_shader",
    "VK_NV_optical_flow",
    "VK_NV_present_barrier",
    "VK_NV_ray_tracing",
    "VK_NV_ray_tracing_invocation_reorder",
    "VK_NV_ray_tracing_motion_blur",
    "VK_NV_representative_fragment_test",
    "VK_NV_sample_mask_override_coverage",
    "VK_NV_scissor_exclusive",
    "VK_NV_shader_image_footprint",
    "VK_NV_shader_sm_builtins",
    "VK_NV_shader_subgroup_partitioned",
    "VK_NV_shading_rate_image",
    "VK_NV_viewport_array2",
    "VK_NV_viewport_swizzle",
    "VK_QCOM_filter_cubic_clamp",
    "VK_QCOM_filter_cubic_weights",
    "VK_QCOM_fragment_density_map_offset",
    "VK_QCOM_image_processing",
    "VK_QCOM_image_processing2",
    "VK_QCOM_multiview_per_view_render_areas",
    "VK_QCOM_multiview_per_view_viewports",
    "VK_QCOM_render_pass_shader_resolve",
    "VK_QCOM_render_pass_store_ops",
    "VK_QCOM_render_pass_transform",
    "VK_QCOM_rotated_copy_commands",
    "VK_QCOM_tile_properties",
    "VK_QCOM_ycbcr_degamma",
    "VK_VALVE_descriptor_set_host_mapping",
    "VK_VALVE_mutable_descriptor_type",
};

static const char * const vk_instance_extensions[] =
{
    "VK_EXT_debug_report",
    "VK_EXT_debug_utils",
    "VK_EXT_surface_maintenance1",
    "VK_EXT_swapchain_colorspace",
    "VK_EXT_validation_features",
    "VK_EXT_validation_flags",
    "VK_KHR_device_group_creation",
    "VK_KHR_external_fence_capabilities",
    "VK_KHR_external_memory_capabilities",
    "VK_KHR_external_semaphore_capabilities",
    "VK_KHR_get_physical_device_properties2",
    "VK_KHR_get_surface_capabilities2",
    "VK_KHR_portability_enumeration",
    "VK_KHR_surface",
    "VK_KHR_win32_surface",
};

BOOL wine_vk_device_extension_supported(const char *name)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(vk_device_extensions); i++)
    {
        if (strcmp(vk_device_extensions[i], name) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL wine_vk_instance_extension_supported(const char *name)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(vk_instance_extensions); i++)
    {
        if (strcmp(vk_instance_extensions[i], name) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL wine_vk_is_type_wrapped(VkObjectType type)
{
    return FALSE ||
        type == VK_OBJECT_TYPE_COMMAND_BUFFER ||
        type == VK_OBJECT_TYPE_COMMAND_POOL ||
        type == VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT ||
        type == VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT ||
        type == VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR ||
        type == VK_OBJECT_TYPE_DEVICE ||
        type == VK_OBJECT_TYPE_DEVICE_MEMORY ||
        type == VK_OBJECT_TYPE_INSTANCE ||
        type == VK_OBJECT_TYPE_PHYSICAL_DEVICE ||
        type == VK_OBJECT_TYPE_QUEUE ||
        type == VK_OBJECT_TYPE_SEMAPHORE ||
        type == VK_OBJECT_TYPE_SURFACE_KHR ||
        type == VK_OBJECT_TYPE_SWAPCHAIN_KHR;
}

#ifdef _WIN64

const unixlib_entry_t __wine_unix_call_funcs[] =
{
    init_vulkan,
    vk_is_available_instance_function,
    vk_is_available_device_function,
    thunk64_vkAcquireNextImage2KHR,
    thunk64_vkAcquireNextImageKHR,
    thunk64_vkAcquirePerformanceConfigurationINTEL,
    thunk64_vkAcquireProfilingLockKHR,
    thunk64_vkAllocateCommandBuffers,
    thunk64_vkAllocateDescriptorSets,
    thunk64_vkAllocateMemory,
    thunk64_vkBeginCommandBuffer,
    thunk64_vkBindAccelerationStructureMemoryNV,
    thunk64_vkBindBufferMemory,
    thunk64_vkBindBufferMemory2,
    thunk64_vkBindBufferMemory2KHR,
    thunk64_vkBindImageMemory,
    thunk64_vkBindImageMemory2,
    thunk64_vkBindImageMemory2KHR,
    thunk64_vkBindOpticalFlowSessionImageNV,
    thunk64_vkBuildAccelerationStructuresKHR,
    thunk64_vkBuildMicromapsEXT,
    (void *)thunk64_vkCmdBeginConditionalRenderingEXT,
    (void *)thunk64_vkCmdBeginDebugUtilsLabelEXT,
    (void *)thunk64_vkCmdBeginQuery,
    (void *)thunk64_vkCmdBeginQueryIndexedEXT,
    (void *)thunk64_vkCmdBeginRenderPass,
    (void *)thunk64_vkCmdBeginRenderPass2,
    (void *)thunk64_vkCmdBeginRenderPass2KHR,
    (void *)thunk64_vkCmdBeginRendering,
    (void *)thunk64_vkCmdBeginRenderingKHR,
    (void *)thunk64_vkCmdBeginTransformFeedbackEXT,
    (void *)thunk64_vkCmdBindDescriptorBufferEmbeddedSamplersEXT,
    (void *)thunk64_vkCmdBindDescriptorBuffersEXT,
    (void *)thunk64_vkCmdBindDescriptorSets,
    (void *)thunk64_vkCmdBindIndexBuffer,
    (void *)thunk64_vkCmdBindIndexBuffer2KHR,
    (void *)thunk64_vkCmdBindInvocationMaskHUAWEI,
    (void *)thunk64_vkCmdBindPipeline,
    (void *)thunk64_vkCmdBindPipelineShaderGroupNV,
    (void *)thunk64_vkCmdBindShadersEXT,
    (void *)thunk64_vkCmdBindShadingRateImageNV,
    (void *)thunk64_vkCmdBindTransformFeedbackBuffersEXT,
    (void *)thunk64_vkCmdBindVertexBuffers,
    (void *)thunk64_vkCmdBindVertexBuffers2,
    (void *)thunk64_vkCmdBindVertexBuffers2EXT,
    (void *)thunk64_vkCmdBlitImage,
    (void *)thunk64_vkCmdBlitImage2,
    (void *)thunk64_vkCmdBlitImage2KHR,
    (void *)thunk64_vkCmdBuildAccelerationStructureNV,
    (void *)thunk64_vkCmdBuildAccelerationStructuresIndirectKHR,
    (void *)thunk64_vkCmdBuildAccelerationStructuresKHR,
    (void *)thunk64_vkCmdBuildMicromapsEXT,
    (void *)thunk64_vkCmdClearAttachments,
    (void *)thunk64_vkCmdClearColorImage,
    (void *)thunk64_vkCmdClearDepthStencilImage,
    (void *)thunk64_vkCmdCopyAccelerationStructureKHR,
    (void *)thunk64_vkCmdCopyAccelerationStructureNV,
    (void *)thunk64_vkCmdCopyAccelerationStructureToMemoryKHR,
    (void *)thunk64_vkCmdCopyBuffer,
    (void *)thunk64_vkCmdCopyBuffer2,
    (void *)thunk64_vkCmdCopyBuffer2KHR,
    (void *)thunk64_vkCmdCopyBufferToImage,
    (void *)thunk64_vkCmdCopyBufferToImage2,
    (void *)thunk64_vkCmdCopyBufferToImage2KHR,
    (void *)thunk64_vkCmdCopyImage,
    (void *)thunk64_vkCmdCopyImage2,
    (void *)thunk64_vkCmdCopyImage2KHR,
    (void *)thunk64_vkCmdCopyImageToBuffer,
    (void *)thunk64_vkCmdCopyImageToBuffer2,
    (void *)thunk64_vkCmdCopyImageToBuffer2KHR,
    (void *)thunk64_vkCmdCopyMemoryIndirectNV,
    (void *)thunk64_vkCmdCopyMemoryToAccelerationStructureKHR,
    (void *)thunk64_vkCmdCopyMemoryToImageIndirectNV,
    (void *)thunk64_vkCmdCopyMemoryToMicromapEXT,
    (void *)thunk64_vkCmdCopyMicromapEXT,
    (void *)thunk64_vkCmdCopyMicromapToMemoryEXT,
    (void *)thunk64_vkCmdCopyQueryPoolResults,
    (void *)thunk64_vkCmdCuLaunchKernelNVX,
    (void *)thunk64_vkCmdDebugMarkerBeginEXT,
    (void *)thunk64_vkCmdDebugMarkerEndEXT,
    (void *)thunk64_vkCmdDebugMarkerInsertEXT,
    (void *)thunk64_vkCmdDecompressMemoryIndirectCountNV,
    (void *)thunk64_vkCmdDecompressMemoryNV,
    (void *)thunk64_vkCmdDispatch,
    (void *)thunk64_vkCmdDispatchBase,
    (void *)thunk64_vkCmdDispatchBaseKHR,
    (void *)thunk64_vkCmdDispatchIndirect,
    (void *)thunk64_vkCmdDraw,
    (void *)thunk64_vkCmdDrawClusterHUAWEI,
    (void *)thunk64_vkCmdDrawClusterIndirectHUAWEI,
    (void *)thunk64_vkCmdDrawIndexed,
    (void *)thunk64_vkCmdDrawIndexedIndirect,
    (void *)thunk64_vkCmdDrawIndexedIndirectCount,
    (void *)thunk64_vkCmdDrawIndexedIndirectCountAMD,
    (void *)thunk64_vkCmdDrawIndexedIndirectCountKHR,
    (void *)thunk64_vkCmdDrawIndirect,
    (void *)thunk64_vkCmdDrawIndirectByteCountEXT,
    (void *)thunk64_vkCmdDrawIndirectCount,
    (void *)thunk64_vkCmdDrawIndirectCountAMD,
    (void *)thunk64_vkCmdDrawIndirectCountKHR,
    (void *)thunk64_vkCmdDrawMeshTasksEXT,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectCountEXT,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectCountNV,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectEXT,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectNV,
    (void *)thunk64_vkCmdDrawMeshTasksNV,
    (void *)thunk64_vkCmdDrawMultiEXT,
    (void *)thunk64_vkCmdDrawMultiIndexedEXT,
    (void *)thunk64_vkCmdEndConditionalRenderingEXT,
    (void *)thunk64_vkCmdEndDebugUtilsLabelEXT,
    (void *)thunk64_vkCmdEndQuery,
    (void *)thunk64_vkCmdEndQueryIndexedEXT,
    (void *)thunk64_vkCmdEndRenderPass,
    (void *)thunk64_vkCmdEndRenderPass2,
    (void *)thunk64_vkCmdEndRenderPass2KHR,
    (void *)thunk64_vkCmdEndRendering,
    (void *)thunk64_vkCmdEndRenderingKHR,
    (void *)thunk64_vkCmdEndTransformFeedbackEXT,
    (void *)thunk64_vkCmdExecuteCommands,
    (void *)thunk64_vkCmdExecuteGeneratedCommandsNV,
    (void *)thunk64_vkCmdFillBuffer,
    (void *)thunk64_vkCmdInsertDebugUtilsLabelEXT,
    (void *)thunk64_vkCmdNextSubpass,
    (void *)thunk64_vkCmdNextSubpass2,
    (void *)thunk64_vkCmdNextSubpass2KHR,
    (void *)thunk64_vkCmdOpticalFlowExecuteNV,
    (void *)thunk64_vkCmdPipelineBarrier,
    (void *)thunk64_vkCmdPipelineBarrier2,
    (void *)thunk64_vkCmdPipelineBarrier2KHR,
    (void *)thunk64_vkCmdPreprocessGeneratedCommandsNV,
    (void *)thunk64_vkCmdPushConstants,
    (void *)thunk64_vkCmdPushDescriptorSetKHR,
    (void *)thunk64_vkCmdPushDescriptorSetWithTemplateKHR,
    (void *)thunk64_vkCmdResetEvent,
    (void *)thunk64_vkCmdResetEvent2,
    (void *)thunk64_vkCmdResetEvent2KHR,
    (void *)thunk64_vkCmdResetQueryPool,
    (void *)thunk64_vkCmdResolveImage,
    (void *)thunk64_vkCmdResolveImage2,
    (void *)thunk64_vkCmdResolveImage2KHR,
    (void *)thunk64_vkCmdSetAlphaToCoverageEnableEXT,
    (void *)thunk64_vkCmdSetAlphaToOneEnableEXT,
    (void *)thunk64_vkCmdSetAttachmentFeedbackLoopEnableEXT,
    (void *)thunk64_vkCmdSetBlendConstants,
    (void *)thunk64_vkCmdSetCheckpointNV,
    (void *)thunk64_vkCmdSetCoarseSampleOrderNV,
    (void *)thunk64_vkCmdSetColorBlendAdvancedEXT,
    (void *)thunk64_vkCmdSetColorBlendEnableEXT,
    (void *)thunk64_vkCmdSetColorBlendEquationEXT,
    (void *)thunk64_vkCmdSetColorWriteEnableEXT,
    (void *)thunk64_vkCmdSetColorWriteMaskEXT,
    (void *)thunk64_vkCmdSetConservativeRasterizationModeEXT,
    (void *)thunk64_vkCmdSetCoverageModulationModeNV,
    (void *)thunk64_vkCmdSetCoverageModulationTableEnableNV,
    (void *)thunk64_vkCmdSetCoverageModulationTableNV,
    (void *)thunk64_vkCmdSetCoverageReductionModeNV,
    (void *)thunk64_vkCmdSetCoverageToColorEnableNV,
    (void *)thunk64_vkCmdSetCoverageToColorLocationNV,
    (void *)thunk64_vkCmdSetCullMode,
    (void *)thunk64_vkCmdSetCullModeEXT,
    (void *)thunk64_vkCmdSetDepthBias,
    (void *)thunk64_vkCmdSetDepthBias2EXT,
    (void *)thunk64_vkCmdSetDepthBiasEnable,
    (void *)thunk64_vkCmdSetDepthBiasEnableEXT,
    (void *)thunk64_vkCmdSetDepthBounds,
    (void *)thunk64_vkCmdSetDepthBoundsTestEnable,
    (void *)thunk64_vkCmdSetDepthBoundsTestEnableEXT,
    (void *)thunk64_vkCmdSetDepthClampEnableEXT,
    (void *)thunk64_vkCmdSetDepthClipEnableEXT,
    (void *)thunk64_vkCmdSetDepthClipNegativeOneToOneEXT,
    (void *)thunk64_vkCmdSetDepthCompareOp,
    (void *)thunk64_vkCmdSetDepthCompareOpEXT,
    (void *)thunk64_vkCmdSetDepthTestEnable,
    (void *)thunk64_vkCmdSetDepthTestEnableEXT,
    (void *)thunk64_vkCmdSetDepthWriteEnable,
    (void *)thunk64_vkCmdSetDepthWriteEnableEXT,
    (void *)thunk64_vkCmdSetDescriptorBufferOffsetsEXT,
    (void *)thunk64_vkCmdSetDeviceMask,
    (void *)thunk64_vkCmdSetDeviceMaskKHR,
    (void *)thunk64_vkCmdSetDiscardRectangleEXT,
    (void *)thunk64_vkCmdSetDiscardRectangleEnableEXT,
    (void *)thunk64_vkCmdSetDiscardRectangleModeEXT,
    (void *)thunk64_vkCmdSetEvent,
    (void *)thunk64_vkCmdSetEvent2,
    (void *)thunk64_vkCmdSetEvent2KHR,
    (void *)thunk64_vkCmdSetExclusiveScissorEnableNV,
    (void *)thunk64_vkCmdSetExclusiveScissorNV,
    (void *)thunk64_vkCmdSetExtraPrimitiveOverestimationSizeEXT,
    (void *)thunk64_vkCmdSetFragmentShadingRateEnumNV,
    (void *)thunk64_vkCmdSetFragmentShadingRateKHR,
    (void *)thunk64_vkCmdSetFrontFace,
    (void *)thunk64_vkCmdSetFrontFaceEXT,
    (void *)thunk64_vkCmdSetLineRasterizationModeEXT,
    (void *)thunk64_vkCmdSetLineStippleEXT,
    (void *)thunk64_vkCmdSetLineStippleEnableEXT,
    (void *)thunk64_vkCmdSetLineWidth,
    (void *)thunk64_vkCmdSetLogicOpEXT,
    (void *)thunk64_vkCmdSetLogicOpEnableEXT,
    (void *)thunk64_vkCmdSetPatchControlPointsEXT,
    thunk64_vkCmdSetPerformanceMarkerINTEL,
    thunk64_vkCmdSetPerformanceOverrideINTEL,
    thunk64_vkCmdSetPerformanceStreamMarkerINTEL,
    (void *)thunk64_vkCmdSetPolygonModeEXT,
    (void *)thunk64_vkCmdSetPrimitiveRestartEnable,
    (void *)thunk64_vkCmdSetPrimitiveRestartEnableEXT,
    (void *)thunk64_vkCmdSetPrimitiveTopology,
    (void *)thunk64_vkCmdSetPrimitiveTopologyEXT,
    (void *)thunk64_vkCmdSetProvokingVertexModeEXT,
    (void *)thunk64_vkCmdSetRasterizationSamplesEXT,
    (void *)thunk64_vkCmdSetRasterizationStreamEXT,
    (void *)thunk64_vkCmdSetRasterizerDiscardEnable,
    (void *)thunk64_vkCmdSetRasterizerDiscardEnableEXT,
    (void *)thunk64_vkCmdSetRayTracingPipelineStackSizeKHR,
    (void *)thunk64_vkCmdSetRepresentativeFragmentTestEnableNV,
    (void *)thunk64_vkCmdSetSampleLocationsEXT,
    (void *)thunk64_vkCmdSetSampleLocationsEnableEXT,
    (void *)thunk64_vkCmdSetSampleMaskEXT,
    (void *)thunk64_vkCmdSetScissor,
    (void *)thunk64_vkCmdSetScissorWithCount,
    (void *)thunk64_vkCmdSetScissorWithCountEXT,
    (void *)thunk64_vkCmdSetShadingRateImageEnableNV,
    (void *)thunk64_vkCmdSetStencilCompareMask,
    (void *)thunk64_vkCmdSetStencilOp,
    (void *)thunk64_vkCmdSetStencilOpEXT,
    (void *)thunk64_vkCmdSetStencilReference,
    (void *)thunk64_vkCmdSetStencilTestEnable,
    (void *)thunk64_vkCmdSetStencilTestEnableEXT,
    (void *)thunk64_vkCmdSetStencilWriteMask,
    (void *)thunk64_vkCmdSetTessellationDomainOriginEXT,
    (void *)thunk64_vkCmdSetVertexInputEXT,
    (void *)thunk64_vkCmdSetViewport,
    (void *)thunk64_vkCmdSetViewportShadingRatePaletteNV,
    (void *)thunk64_vkCmdSetViewportSwizzleNV,
    (void *)thunk64_vkCmdSetViewportWScalingEnableNV,
    (void *)thunk64_vkCmdSetViewportWScalingNV,
    (void *)thunk64_vkCmdSetViewportWithCount,
    (void *)thunk64_vkCmdSetViewportWithCountEXT,
    (void *)thunk64_vkCmdSubpassShadingHUAWEI,
    (void *)thunk64_vkCmdTraceRaysIndirect2KHR,
    (void *)thunk64_vkCmdTraceRaysIndirectKHR,
    (void *)thunk64_vkCmdTraceRaysKHR,
    (void *)thunk64_vkCmdTraceRaysNV,
    (void *)thunk64_vkCmdUpdateBuffer,
    (void *)thunk64_vkCmdUpdatePipelineIndirectBufferNV,
    (void *)thunk64_vkCmdWaitEvents,
    (void *)thunk64_vkCmdWaitEvents2,
    (void *)thunk64_vkCmdWaitEvents2KHR,
    (void *)thunk64_vkCmdWriteAccelerationStructuresPropertiesKHR,
    (void *)thunk64_vkCmdWriteAccelerationStructuresPropertiesNV,
    (void *)thunk64_vkCmdWriteBufferMarker2AMD,
    (void *)thunk64_vkCmdWriteBufferMarkerAMD,
    (void *)thunk64_vkCmdWriteMicromapsPropertiesEXT,
    (void *)thunk64_vkCmdWriteTimestamp,
    (void *)thunk64_vkCmdWriteTimestamp2,
    (void *)thunk64_vkCmdWriteTimestamp2KHR,
    thunk64_vkCompileDeferredNV,
    thunk64_vkCopyAccelerationStructureKHR,
    thunk64_vkCopyAccelerationStructureToMemoryKHR,
    thunk64_vkCopyImageToImageEXT,
    thunk64_vkCopyImageToMemoryEXT,
    thunk64_vkCopyMemoryToAccelerationStructureKHR,
    thunk64_vkCopyMemoryToImageEXT,
    thunk64_vkCopyMemoryToMicromapEXT,
    thunk64_vkCopyMicromapEXT,
    thunk64_vkCopyMicromapToMemoryEXT,
    thunk64_vkCreateAccelerationStructureKHR,
    thunk64_vkCreateAccelerationStructureNV,
    thunk64_vkCreateBuffer,
    thunk64_vkCreateBufferView,
    thunk64_vkCreateCommandPool,
    thunk64_vkCreateComputePipelines,
    thunk64_vkCreateCuFunctionNVX,
    thunk64_vkCreateCuModuleNVX,
    thunk64_vkCreateDebugReportCallbackEXT,
    thunk64_vkCreateDebugUtilsMessengerEXT,
    thunk64_vkCreateDeferredOperationKHR,
    thunk64_vkCreateDescriptorPool,
    thunk64_vkCreateDescriptorSetLayout,
    thunk64_vkCreateDescriptorUpdateTemplate,
    thunk64_vkCreateDescriptorUpdateTemplateKHR,
    thunk64_vkCreateDevice,
    thunk64_vkCreateEvent,
    thunk64_vkCreateFence,
    thunk64_vkCreateFramebuffer,
    thunk64_vkCreateGraphicsPipelines,
    thunk64_vkCreateImage,
    thunk64_vkCreateImageView,
    thunk64_vkCreateIndirectCommandsLayoutNV,
    thunk64_vkCreateInstance,
    thunk64_vkCreateMicromapEXT,
    thunk64_vkCreateOpticalFlowSessionNV,
    thunk64_vkCreatePipelineCache,
    thunk64_vkCreatePipelineLayout,
    thunk64_vkCreatePrivateDataSlot,
    thunk64_vkCreatePrivateDataSlotEXT,
    thunk64_vkCreateQueryPool,
    thunk64_vkCreateRayTracingPipelinesKHR,
    thunk64_vkCreateRayTracingPipelinesNV,
    thunk64_vkCreateRenderPass,
    thunk64_vkCreateRenderPass2,
    thunk64_vkCreateRenderPass2KHR,
    thunk64_vkCreateSampler,
    thunk64_vkCreateSamplerYcbcrConversion,
    thunk64_vkCreateSamplerYcbcrConversionKHR,
    thunk64_vkCreateSemaphore,
    thunk64_vkCreateShaderModule,
    thunk64_vkCreateShadersEXT,
    thunk64_vkCreateSwapchainKHR,
    thunk64_vkCreateValidationCacheEXT,
    thunk64_vkCreateWin32SurfaceKHR,
    thunk64_vkDebugMarkerSetObjectNameEXT,
    thunk64_vkDebugMarkerSetObjectTagEXT,
    thunk64_vkDebugReportMessageEXT,
    thunk64_vkDeferredOperationJoinKHR,
    thunk64_vkDestroyAccelerationStructureKHR,
    thunk64_vkDestroyAccelerationStructureNV,
    thunk64_vkDestroyBuffer,
    thunk64_vkDestroyBufferView,
    thunk64_vkDestroyCommandPool,
    thunk64_vkDestroyCuFunctionNVX,
    thunk64_vkDestroyCuModuleNVX,
    thunk64_vkDestroyDebugReportCallbackEXT,
    thunk64_vkDestroyDebugUtilsMessengerEXT,
    thunk64_vkDestroyDeferredOperationKHR,
    thunk64_vkDestroyDescriptorPool,
    thunk64_vkDestroyDescriptorSetLayout,
    thunk64_vkDestroyDescriptorUpdateTemplate,
    thunk64_vkDestroyDescriptorUpdateTemplateKHR,
    thunk64_vkDestroyDevice,
    thunk64_vkDestroyEvent,
    thunk64_vkDestroyFence,
    thunk64_vkDestroyFramebuffer,
    thunk64_vkDestroyImage,
    thunk64_vkDestroyImageView,
    thunk64_vkDestroyIndirectCommandsLayoutNV,
    thunk64_vkDestroyInstance,
    thunk64_vkDestroyMicromapEXT,
    thunk64_vkDestroyOpticalFlowSessionNV,
    thunk64_vkDestroyPipeline,
    thunk64_vkDestroyPipelineCache,
    thunk64_vkDestroyPipelineLayout,
    thunk64_vkDestroyPrivateDataSlot,
    thunk64_vkDestroyPrivateDataSlotEXT,
    thunk64_vkDestroyQueryPool,
    thunk64_vkDestroyRenderPass,
    thunk64_vkDestroySampler,
    thunk64_vkDestroySamplerYcbcrConversion,
    thunk64_vkDestroySamplerYcbcrConversionKHR,
    thunk64_vkDestroySemaphore,
    thunk64_vkDestroyShaderEXT,
    thunk64_vkDestroyShaderModule,
    thunk64_vkDestroySurfaceKHR,
    thunk64_vkDestroySwapchainKHR,
    thunk64_vkDestroyValidationCacheEXT,
    thunk64_vkDeviceWaitIdle,
    thunk64_vkEndCommandBuffer,
    thunk64_vkEnumerateDeviceExtensionProperties,
    thunk64_vkEnumerateDeviceLayerProperties,
    thunk64_vkEnumerateInstanceExtensionProperties,
    thunk64_vkEnumerateInstanceVersion,
    thunk64_vkEnumeratePhysicalDeviceGroups,
    thunk64_vkEnumeratePhysicalDeviceGroupsKHR,
    thunk64_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
    thunk64_vkEnumeratePhysicalDevices,
    thunk64_vkFlushMappedMemoryRanges,
    thunk64_vkFreeCommandBuffers,
    thunk64_vkFreeDescriptorSets,
    thunk64_vkFreeMemory,
    thunk64_vkGetAccelerationStructureBuildSizesKHR,
    thunk64_vkGetAccelerationStructureDeviceAddressKHR,
    thunk64_vkGetAccelerationStructureHandleNV,
    thunk64_vkGetAccelerationStructureMemoryRequirementsNV,
    thunk64_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetBufferDeviceAddress,
    thunk64_vkGetBufferDeviceAddressEXT,
    thunk64_vkGetBufferDeviceAddressKHR,
    thunk64_vkGetBufferMemoryRequirements,
    thunk64_vkGetBufferMemoryRequirements2,
    thunk64_vkGetBufferMemoryRequirements2KHR,
    thunk64_vkGetBufferOpaqueCaptureAddress,
    thunk64_vkGetBufferOpaqueCaptureAddressKHR,
    thunk64_vkGetBufferOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetCalibratedTimestampsEXT,
    thunk64_vkGetDeferredOperationMaxConcurrencyKHR,
    thunk64_vkGetDeferredOperationResultKHR,
    (void *)thunk64_vkGetDescriptorEXT,
    thunk64_vkGetDescriptorSetHostMappingVALVE,
    thunk64_vkGetDescriptorSetLayoutBindingOffsetEXT,
    thunk64_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
    thunk64_vkGetDescriptorSetLayoutSizeEXT,
    thunk64_vkGetDescriptorSetLayoutSupport,
    thunk64_vkGetDescriptorSetLayoutSupportKHR,
    thunk64_vkGetDeviceAccelerationStructureCompatibilityKHR,
    thunk64_vkGetDeviceBufferMemoryRequirements,
    thunk64_vkGetDeviceBufferMemoryRequirementsKHR,
    thunk64_vkGetDeviceFaultInfoEXT,
    thunk64_vkGetDeviceGroupPeerMemoryFeatures,
    thunk64_vkGetDeviceGroupPeerMemoryFeaturesKHR,
    thunk64_vkGetDeviceGroupPresentCapabilitiesKHR,
    thunk64_vkGetDeviceGroupSurfacePresentModesKHR,
    thunk64_vkGetDeviceImageMemoryRequirements,
    thunk64_vkGetDeviceImageMemoryRequirementsKHR,
    thunk64_vkGetDeviceImageSparseMemoryRequirements,
    thunk64_vkGetDeviceImageSparseMemoryRequirementsKHR,
    thunk64_vkGetDeviceImageSubresourceLayoutKHR,
    thunk64_vkGetDeviceMemoryCommitment,
    thunk64_vkGetDeviceMemoryOpaqueCaptureAddress,
    thunk64_vkGetDeviceMemoryOpaqueCaptureAddressKHR,
    thunk64_vkGetDeviceMicromapCompatibilityEXT,
    thunk64_vkGetDeviceQueue,
    thunk64_vkGetDeviceQueue2,
    thunk64_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
    thunk64_vkGetDynamicRenderingTilePropertiesQCOM,
    thunk64_vkGetEventStatus,
    thunk64_vkGetFenceStatus,
    thunk64_vkGetFramebufferTilePropertiesQCOM,
    thunk64_vkGetGeneratedCommandsMemoryRequirementsNV,
    thunk64_vkGetImageMemoryRequirements,
    thunk64_vkGetImageMemoryRequirements2,
    thunk64_vkGetImageMemoryRequirements2KHR,
    thunk64_vkGetImageOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetImageSparseMemoryRequirements,
    thunk64_vkGetImageSparseMemoryRequirements2,
    thunk64_vkGetImageSparseMemoryRequirements2KHR,
    thunk64_vkGetImageSubresourceLayout,
    thunk64_vkGetImageSubresourceLayout2EXT,
    thunk64_vkGetImageSubresourceLayout2KHR,
    thunk64_vkGetImageViewAddressNVX,
    thunk64_vkGetImageViewHandleNVX,
    thunk64_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetLatencyTimingsNV,
    thunk64_vkGetMemoryFdKHR,
    thunk64_vkGetMemoryFdPropertiesKHR,
    thunk64_vkGetMemoryHostPointerPropertiesEXT,
    thunk64_vkGetMemoryWin32HandleKHR,
    thunk64_vkGetMemoryWin32HandlePropertiesKHR,
    thunk64_vkGetMicromapBuildSizesEXT,
    thunk64_vkGetPerformanceParameterINTEL,
    thunk64_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
    thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
    thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
    thunk64_vkGetPhysicalDeviceExternalBufferProperties,
    thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
    thunk64_vkGetPhysicalDeviceExternalFenceProperties,
    thunk64_vkGetPhysicalDeviceExternalFencePropertiesKHR,
    thunk64_vkGetPhysicalDeviceExternalSemaphoreProperties,
    thunk64_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
    thunk64_vkGetPhysicalDeviceFeatures,
    thunk64_vkGetPhysicalDeviceFeatures2,
    thunk64_vkGetPhysicalDeviceFeatures2KHR,
    thunk64_vkGetPhysicalDeviceFormatProperties,
    thunk64_vkGetPhysicalDeviceFormatProperties2,
    thunk64_vkGetPhysicalDeviceFormatProperties2KHR,
    thunk64_vkGetPhysicalDeviceFragmentShadingRatesKHR,
    thunk64_vkGetPhysicalDeviceImageFormatProperties,
    thunk64_vkGetPhysicalDeviceImageFormatProperties2,
    thunk64_vkGetPhysicalDeviceImageFormatProperties2KHR,
    thunk64_vkGetPhysicalDeviceMemoryProperties,
    thunk64_vkGetPhysicalDeviceMemoryProperties2,
    thunk64_vkGetPhysicalDeviceMemoryProperties2KHR,
    thunk64_vkGetPhysicalDeviceMultisamplePropertiesEXT,
    thunk64_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
    thunk64_vkGetPhysicalDevicePresentRectanglesKHR,
    thunk64_vkGetPhysicalDeviceProperties,
    thunk64_vkGetPhysicalDeviceProperties2,
    thunk64_vkGetPhysicalDeviceProperties2KHR,
    thunk64_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
    thunk64_vkGetPhysicalDeviceQueueFamilyProperties,
    thunk64_vkGetPhysicalDeviceQueueFamilyProperties2,
    thunk64_vkGetPhysicalDeviceQueueFamilyProperties2KHR,
    thunk64_vkGetPhysicalDeviceSparseImageFormatProperties,
    thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2,
    thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
    thunk64_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
    thunk64_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
    thunk64_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
    thunk64_vkGetPhysicalDeviceSurfaceFormats2KHR,
    thunk64_vkGetPhysicalDeviceSurfaceFormatsKHR,
    thunk64_vkGetPhysicalDeviceSurfacePresentModesKHR,
    thunk64_vkGetPhysicalDeviceSurfaceSupportKHR,
    thunk64_vkGetPhysicalDeviceToolProperties,
    thunk64_vkGetPhysicalDeviceToolPropertiesEXT,
    thunk64_vkGetPhysicalDeviceWin32PresentationSupportKHR,
    thunk64_vkGetPipelineCacheData,
    thunk64_vkGetPipelineExecutableInternalRepresentationsKHR,
    thunk64_vkGetPipelineExecutablePropertiesKHR,
    thunk64_vkGetPipelineExecutableStatisticsKHR,
    thunk64_vkGetPipelineIndirectDeviceAddressNV,
    thunk64_vkGetPipelineIndirectMemoryRequirementsNV,
    thunk64_vkGetPipelinePropertiesEXT,
    thunk64_vkGetPrivateData,
    thunk64_vkGetPrivateDataEXT,
    thunk64_vkGetQueryPoolResults,
    thunk64_vkGetQueueCheckpointData2NV,
    thunk64_vkGetQueueCheckpointDataNV,
    thunk64_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
    thunk64_vkGetRayTracingShaderGroupHandlesKHR,
    thunk64_vkGetRayTracingShaderGroupHandlesNV,
    thunk64_vkGetRayTracingShaderGroupStackSizeKHR,
    thunk64_vkGetRenderAreaGranularity,
    thunk64_vkGetRenderingAreaGranularityKHR,
    thunk64_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetSemaphoreCounterValue,
    thunk64_vkGetSemaphoreCounterValueKHR,
    thunk64_vkGetSemaphoreFdKHR,
    thunk64_vkGetSemaphoreWin32HandleKHR,
    thunk64_vkGetShaderBinaryDataEXT,
    thunk64_vkGetShaderInfoAMD,
    thunk64_vkGetShaderModuleCreateInfoIdentifierEXT,
    thunk64_vkGetShaderModuleIdentifierEXT,
    thunk64_vkGetSwapchainImagesKHR,
    thunk64_vkGetValidationCacheDataEXT,
    thunk64_vkImportSemaphoreFdKHR,
    thunk64_vkImportSemaphoreWin32HandleKHR,
    thunk64_vkInitializePerformanceApiINTEL,
    thunk64_vkInvalidateMappedMemoryRanges,
    thunk64_vkLatencySleepNV,
    thunk64_vkMapMemory,
    thunk64_vkMapMemory2KHR,
    thunk64_vkMergePipelineCaches,
    thunk64_vkMergeValidationCachesEXT,
    thunk64_vkQueueBeginDebugUtilsLabelEXT,
    thunk64_vkQueueBindSparse,
    thunk64_vkQueueEndDebugUtilsLabelEXT,
    thunk64_vkQueueInsertDebugUtilsLabelEXT,
    thunk64_vkQueueNotifyOutOfBandNV,
    thunk64_vkQueuePresentKHR,
    thunk64_vkQueueSetPerformanceConfigurationINTEL,
    thunk64_vkQueueSubmit,
    thunk64_vkQueueSubmit2,
    thunk64_vkQueueSubmit2KHR,
    thunk64_vkQueueWaitIdle,
    thunk64_vkReleasePerformanceConfigurationINTEL,
    thunk64_vkReleaseProfilingLockKHR,
    thunk64_vkReleaseSwapchainImagesEXT,
    thunk64_vkResetCommandBuffer,
    thunk64_vkResetCommandPool,
    thunk64_vkResetDescriptorPool,
    thunk64_vkResetEvent,
    thunk64_vkResetFences,
    thunk64_vkResetQueryPool,
    thunk64_vkResetQueryPoolEXT,
    thunk64_vkSetDebugUtilsObjectNameEXT,
    thunk64_vkSetDebugUtilsObjectTagEXT,
    thunk64_vkSetDeviceMemoryPriorityEXT,
    thunk64_vkSetEvent,
    thunk64_vkSetHdrMetadataEXT,
    thunk64_vkSetLatencyMarkerNV,
    thunk64_vkSetLatencySleepModeNV,
    thunk64_vkSetPrivateData,
    thunk64_vkSetPrivateDataEXT,
    thunk64_vkSignalSemaphore,
    thunk64_vkSignalSemaphoreKHR,
    thunk64_vkSubmitDebugUtilsMessageEXT,
    thunk64_vkTransitionImageLayoutEXT,
    thunk64_vkTrimCommandPool,
    thunk64_vkTrimCommandPoolKHR,
    thunk64_vkUninitializePerformanceApiINTEL,
    thunk64_vkUnmapMemory,
    thunk64_vkUnmapMemory2KHR,
    (void *)thunk64_vkUpdateDescriptorSetWithTemplate,
    thunk64_vkUpdateDescriptorSetWithTemplateKHR,
    (void *)thunk64_vkUpdateDescriptorSets,
    thunk64_vkWaitForFences,
    thunk64_vkWaitForPresentKHR,
    thunk64_vkWaitSemaphores,
    thunk64_vkWaitSemaphoresKHR,
    thunk64_vkWriteAccelerationStructuresPropertiesKHR,
    thunk64_vkWriteMicromapsPropertiesEXT,
    thunk64_wine_vkAcquireKeyedMutex,
    thunk64_wine_vkReleaseKeyedMutex,
};
C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);

#endif /* _WIN64 */

#ifdef _WIN64
const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
#else
const unixlib_entry_t __wine_unix_call_funcs[] =
#endif
{
    init_vulkan,
    vk_is_available_instance_function32,
    vk_is_available_device_function32,
    thunk32_vkAcquireNextImage2KHR,
    thunk32_vkAcquireNextImageKHR,
    thunk32_vkAcquirePerformanceConfigurationINTEL,
    thunk32_vkAcquireProfilingLockKHR,
    thunk32_vkAllocateCommandBuffers,
    thunk32_vkAllocateDescriptorSets,
    thunk32_vkAllocateMemory,
    thunk32_vkBeginCommandBuffer,
    thunk32_vkBindAccelerationStructureMemoryNV,
    thunk32_vkBindBufferMemory,
    thunk32_vkBindBufferMemory2,
    thunk32_vkBindBufferMemory2KHR,
    thunk32_vkBindImageMemory,
    thunk32_vkBindImageMemory2,
    thunk32_vkBindImageMemory2KHR,
    thunk32_vkBindOpticalFlowSessionImageNV,
    thunk32_vkBuildAccelerationStructuresKHR,
    thunk32_vkBuildMicromapsEXT,
    (void *)thunk32_vkCmdBeginConditionalRenderingEXT,
    (void *)thunk32_vkCmdBeginDebugUtilsLabelEXT,
    (void *)thunk32_vkCmdBeginQuery,
    (void *)thunk32_vkCmdBeginQueryIndexedEXT,
    (void *)thunk32_vkCmdBeginRenderPass,
    (void *)thunk32_vkCmdBeginRenderPass2,
    (void *)thunk32_vkCmdBeginRenderPass2KHR,
    (void *)thunk32_vkCmdBeginRendering,
    (void *)thunk32_vkCmdBeginRenderingKHR,
    (void *)thunk32_vkCmdBeginTransformFeedbackEXT,
    (void *)thunk32_vkCmdBindDescriptorBufferEmbeddedSamplersEXT,
    (void *)thunk32_vkCmdBindDescriptorBuffersEXT,
    (void *)thunk32_vkCmdBindDescriptorSets,
    (void *)thunk32_vkCmdBindIndexBuffer,
    (void *)thunk32_vkCmdBindIndexBuffer2KHR,
    (void *)thunk32_vkCmdBindInvocationMaskHUAWEI,
    (void *)thunk32_vkCmdBindPipeline,
    (void *)thunk32_vkCmdBindPipelineShaderGroupNV,
    (void *)thunk32_vkCmdBindShadersEXT,
    (void *)thunk32_vkCmdBindShadingRateImageNV,
    (void *)thunk32_vkCmdBindTransformFeedbackBuffersEXT,
    (void *)thunk32_vkCmdBindVertexBuffers,
    (void *)thunk32_vkCmdBindVertexBuffers2,
    (void *)thunk32_vkCmdBindVertexBuffers2EXT,
    (void *)thunk32_vkCmdBlitImage,
    (void *)thunk32_vkCmdBlitImage2,
    (void *)thunk32_vkCmdBlitImage2KHR,
    (void *)thunk32_vkCmdBuildAccelerationStructureNV,
    (void *)thunk32_vkCmdBuildAccelerationStructuresIndirectKHR,
    (void *)thunk32_vkCmdBuildAccelerationStructuresKHR,
    (void *)thunk32_vkCmdBuildMicromapsEXT,
    (void *)thunk32_vkCmdClearAttachments,
    (void *)thunk32_vkCmdClearColorImage,
    (void *)thunk32_vkCmdClearDepthStencilImage,
    (void *)thunk32_vkCmdCopyAccelerationStructureKHR,
    (void *)thunk32_vkCmdCopyAccelerationStructureNV,
    (void *)thunk32_vkCmdCopyAccelerationStructureToMemoryKHR,
    (void *)thunk32_vkCmdCopyBuffer,
    (void *)thunk32_vkCmdCopyBuffer2,
    (void *)thunk32_vkCmdCopyBuffer2KHR,
    (void *)thunk32_vkCmdCopyBufferToImage,
    (void *)thunk32_vkCmdCopyBufferToImage2,
    (void *)thunk32_vkCmdCopyBufferToImage2KHR,
    (void *)thunk32_vkCmdCopyImage,
    (void *)thunk32_vkCmdCopyImage2,
    (void *)thunk32_vkCmdCopyImage2KHR,
    (void *)thunk32_vkCmdCopyImageToBuffer,
    (void *)thunk32_vkCmdCopyImageToBuffer2,
    (void *)thunk32_vkCmdCopyImageToBuffer2KHR,
    (void *)thunk32_vkCmdCopyMemoryIndirectNV,
    (void *)thunk32_vkCmdCopyMemoryToAccelerationStructureKHR,
    (void *)thunk32_vkCmdCopyMemoryToImageIndirectNV,
    (void *)thunk32_vkCmdCopyMemoryToMicromapEXT,
    (void *)thunk32_vkCmdCopyMicromapEXT,
    (void *)thunk32_vkCmdCopyMicromapToMemoryEXT,
    (void *)thunk32_vkCmdCopyQueryPoolResults,
    (void *)thunk32_vkCmdCuLaunchKernelNVX,
    (void *)thunk32_vkCmdDebugMarkerBeginEXT,
    (void *)thunk32_vkCmdDebugMarkerEndEXT,
    (void *)thunk32_vkCmdDebugMarkerInsertEXT,
    (void *)thunk32_vkCmdDecompressMemoryIndirectCountNV,
    (void *)thunk32_vkCmdDecompressMemoryNV,
    (void *)thunk32_vkCmdDispatch,
    (void *)thunk32_vkCmdDispatchBase,
    (void *)thunk32_vkCmdDispatchBaseKHR,
    (void *)thunk32_vkCmdDispatchIndirect,
    (void *)thunk32_vkCmdDraw,
    (void *)thunk32_vkCmdDrawClusterHUAWEI,
    (void *)thunk32_vkCmdDrawClusterIndirectHUAWEI,
    (void *)thunk32_vkCmdDrawIndexed,
    (void *)thunk32_vkCmdDrawIndexedIndirect,
    (void *)thunk32_vkCmdDrawIndexedIndirectCount,
    (void *)thunk32_vkCmdDrawIndexedIndirectCountAMD,
    (void *)thunk32_vkCmdDrawIndexedIndirectCountKHR,
    (void *)thunk32_vkCmdDrawIndirect,
    (void *)thunk32_vkCmdDrawIndirectByteCountEXT,
    (void *)thunk32_vkCmdDrawIndirectCount,
    (void *)thunk32_vkCmdDrawIndirectCountAMD,
    (void *)thunk32_vkCmdDrawIndirectCountKHR,
    (void *)thunk32_vkCmdDrawMeshTasksEXT,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectCountEXT,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectCountNV,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectEXT,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectNV,
    (void *)thunk32_vkCmdDrawMeshTasksNV,
    (void *)thunk32_vkCmdDrawMultiEXT,
    (void *)thunk32_vkCmdDrawMultiIndexedEXT,
    (void *)thunk32_vkCmdEndConditionalRenderingEXT,
    (void *)thunk32_vkCmdEndDebugUtilsLabelEXT,
    (void *)thunk32_vkCmdEndQuery,
    (void *)thunk32_vkCmdEndQueryIndexedEXT,
    (void *)thunk32_vkCmdEndRenderPass,
    (void *)thunk32_vkCmdEndRenderPass2,
    (void *)thunk32_vkCmdEndRenderPass2KHR,
    (void *)thunk32_vkCmdEndRendering,
    (void *)thunk32_vkCmdEndRenderingKHR,
    (void *)thunk32_vkCmdEndTransformFeedbackEXT,
    (void *)thunk32_vkCmdExecuteCommands,
    (void *)thunk32_vkCmdExecuteGeneratedCommandsNV,
    (void *)thunk32_vkCmdFillBuffer,
    (void *)thunk32_vkCmdInsertDebugUtilsLabelEXT,
    (void *)thunk32_vkCmdNextSubpass,
    (void *)thunk32_vkCmdNextSubpass2,
    (void *)thunk32_vkCmdNextSubpass2KHR,
    (void *)thunk32_vkCmdOpticalFlowExecuteNV,
    (void *)thunk32_vkCmdPipelineBarrier,
    (void *)thunk32_vkCmdPipelineBarrier2,
    (void *)thunk32_vkCmdPipelineBarrier2KHR,
    (void *)thunk32_vkCmdPreprocessGeneratedCommandsNV,
    (void *)thunk32_vkCmdPushConstants,
    (void *)thunk32_vkCmdPushDescriptorSetKHR,
    (void *)thunk32_vkCmdPushDescriptorSetWithTemplateKHR,
    (void *)thunk32_vkCmdResetEvent,
    (void *)thunk32_vkCmdResetEvent2,
    (void *)thunk32_vkCmdResetEvent2KHR,
    (void *)thunk32_vkCmdResetQueryPool,
    (void *)thunk32_vkCmdResolveImage,
    (void *)thunk32_vkCmdResolveImage2,
    (void *)thunk32_vkCmdResolveImage2KHR,
    (void *)thunk32_vkCmdSetAlphaToCoverageEnableEXT,
    (void *)thunk32_vkCmdSetAlphaToOneEnableEXT,
    (void *)thunk32_vkCmdSetAttachmentFeedbackLoopEnableEXT,
    (void *)thunk32_vkCmdSetBlendConstants,
    (void *)thunk32_vkCmdSetCheckpointNV,
    (void *)thunk32_vkCmdSetCoarseSampleOrderNV,
    (void *)thunk32_vkCmdSetColorBlendAdvancedEXT,
    (void *)thunk32_vkCmdSetColorBlendEnableEXT,
    (void *)thunk32_vkCmdSetColorBlendEquationEXT,
    (void *)thunk32_vkCmdSetColorWriteEnableEXT,
    (void *)thunk32_vkCmdSetColorWriteMaskEXT,
    (void *)thunk32_vkCmdSetConservativeRasterizationModeEXT,
    (void *)thunk32_vkCmdSetCoverageModulationModeNV,
    (void *)thunk32_vkCmdSetCoverageModulationTableEnableNV,
    (void *)thunk32_vkCmdSetCoverageModulationTableNV,
    (void *)thunk32_vkCmdSetCoverageReductionModeNV,
    (void *)thunk32_vkCmdSetCoverageToColorEnableNV,
    (void *)thunk32_vkCmdSetCoverageToColorLocationNV,
    (void *)thunk32_vkCmdSetCullMode,
    (void *)thunk32_vkCmdSetCullModeEXT,
    (void *)thunk32_vkCmdSetDepthBias,
    (void *)thunk32_vkCmdSetDepthBias2EXT,
    (void *)thunk32_vkCmdSetDepthBiasEnable,
    (void *)thunk32_vkCmdSetDepthBiasEnableEXT,
    (void *)thunk32_vkCmdSetDepthBounds,
    (void *)thunk32_vkCmdSetDepthBoundsTestEnable,
    (void *)thunk32_vkCmdSetDepthBoundsTestEnableEXT,
    (void *)thunk32_vkCmdSetDepthClampEnableEXT,
    (void *)thunk32_vkCmdSetDepthClipEnableEXT,
    (void *)thunk32_vkCmdSetDepthClipNegativeOneToOneEXT,
    (void *)thunk32_vkCmdSetDepthCompareOp,
    (void *)thunk32_vkCmdSetDepthCompareOpEXT,
    (void *)thunk32_vkCmdSetDepthTestEnable,
    (void *)thunk32_vkCmdSetDepthTestEnableEXT,
    (void *)thunk32_vkCmdSetDepthWriteEnable,
    (void *)thunk32_vkCmdSetDepthWriteEnableEXT,
    (void *)thunk32_vkCmdSetDescriptorBufferOffsetsEXT,
    (void *)thunk32_vkCmdSetDeviceMask,
    (void *)thunk32_vkCmdSetDeviceMaskKHR,
    (void *)thunk32_vkCmdSetDiscardRectangleEXT,
    (void *)thunk32_vkCmdSetDiscardRectangleEnableEXT,
    (void *)thunk32_vkCmdSetDiscardRectangleModeEXT,
    (void *)thunk32_vkCmdSetEvent,
    (void *)thunk32_vkCmdSetEvent2,
    (void *)thunk32_vkCmdSetEvent2KHR,
    (void *)thunk32_vkCmdSetExclusiveScissorEnableNV,
    (void *)thunk32_vkCmdSetExclusiveScissorNV,
    (void *)thunk32_vkCmdSetExtraPrimitiveOverestimationSizeEXT,
    (void *)thunk32_vkCmdSetFragmentShadingRateEnumNV,
    (void *)thunk32_vkCmdSetFragmentShadingRateKHR,
    (void *)thunk32_vkCmdSetFrontFace,
    (void *)thunk32_vkCmdSetFrontFaceEXT,
    (void *)thunk32_vkCmdSetLineRasterizationModeEXT,
    (void *)thunk32_vkCmdSetLineStippleEXT,
    (void *)thunk32_vkCmdSetLineStippleEnableEXT,
    (void *)thunk32_vkCmdSetLineWidth,
    (void *)thunk32_vkCmdSetLogicOpEXT,
    (void *)thunk32_vkCmdSetLogicOpEnableEXT,
    (void *)thunk32_vkCmdSetPatchControlPointsEXT,
    thunk32_vkCmdSetPerformanceMarkerINTEL,
    thunk32_vkCmdSetPerformanceOverrideINTEL,
    thunk32_vkCmdSetPerformanceStreamMarkerINTEL,
    (void *)thunk32_vkCmdSetPolygonModeEXT,
    (void *)thunk32_vkCmdSetPrimitiveRestartEnable,
    (void *)thunk32_vkCmdSetPrimitiveRestartEnableEXT,
    (void *)thunk32_vkCmdSetPrimitiveTopology,
    (void *)thunk32_vkCmdSetPrimitiveTopologyEXT,
    (void *)thunk32_vkCmdSetProvokingVertexModeEXT,
    (void *)thunk32_vkCmdSetRasterizationSamplesEXT,
    (void *)thunk32_vkCmdSetRasterizationStreamEXT,
    (void *)thunk32_vkCmdSetRasterizerDiscardEnable,
    (void *)thunk32_vkCmdSetRasterizerDiscardEnableEXT,
    (void *)thunk32_vkCmdSetRayTracingPipelineStackSizeKHR,
    (void *)thunk32_vkCmdSetRepresentativeFragmentTestEnableNV,
    (void *)thunk32_vkCmdSetSampleLocationsEXT,
    (void *)thunk32_vkCmdSetSampleLocationsEnableEXT,
    (void *)thunk32_vkCmdSetSampleMaskEXT,
    (void *)thunk32_vkCmdSetScissor,
    (void *)thunk32_vkCmdSetScissorWithCount,
    (void *)thunk32_vkCmdSetScissorWithCountEXT,
    (void *)thunk32_vkCmdSetShadingRateImageEnableNV,
    (void *)thunk32_vkCmdSetStencilCompareMask,
    (void *)thunk32_vkCmdSetStencilOp,
    (void *)thunk32_vkCmdSetStencilOpEXT,
    (void *)thunk32_vkCmdSetStencilReference,
    (void *)thunk32_vkCmdSetStencilTestEnable,
    (void *)thunk32_vkCmdSetStencilTestEnableEXT,
    (void *)thunk32_vkCmdSetStencilWriteMask,
    (void *)thunk32_vkCmdSetTessellationDomainOriginEXT,
    (void *)thunk32_vkCmdSetVertexInputEXT,
    (void *)thunk32_vkCmdSetViewport,
    (void *)thunk32_vkCmdSetViewportShadingRatePaletteNV,
    (void *)thunk32_vkCmdSetViewportSwizzleNV,
    (void *)thunk32_vkCmdSetViewportWScalingEnableNV,
    (void *)thunk32_vkCmdSetViewportWScalingNV,
    (void *)thunk32_vkCmdSetViewportWithCount,
    (void *)thunk32_vkCmdSetViewportWithCountEXT,
    (void *)thunk32_vkCmdSubpassShadingHUAWEI,
    (void *)thunk32_vkCmdTraceRaysIndirect2KHR,
    (void *)thunk32_vkCmdTraceRaysIndirectKHR,
    (void *)thunk32_vkCmdTraceRaysKHR,
    (void *)thunk32_vkCmdTraceRaysNV,
    (void *)thunk32_vkCmdUpdateBuffer,
    (void *)thunk32_vkCmdUpdatePipelineIndirectBufferNV,
    (void *)thunk32_vkCmdWaitEvents,
    (void *)thunk32_vkCmdWaitEvents2,
    (void *)thunk32_vkCmdWaitEvents2KHR,
    (void *)thunk32_vkCmdWriteAccelerationStructuresPropertiesKHR,
    (void *)thunk32_vkCmdWriteAccelerationStructuresPropertiesNV,
    (void *)thunk32_vkCmdWriteBufferMarker2AMD,
    (void *)thunk32_vkCmdWriteBufferMarkerAMD,
    (void *)thunk32_vkCmdWriteMicromapsPropertiesEXT,
    (void *)thunk32_vkCmdWriteTimestamp,
    (void *)thunk32_vkCmdWriteTimestamp2,
    (void *)thunk32_vkCmdWriteTimestamp2KHR,
    thunk32_vkCompileDeferredNV,
    thunk32_vkCopyAccelerationStructureKHR,
    thunk32_vkCopyAccelerationStructureToMemoryKHR,
    thunk32_vkCopyImageToImageEXT,
    thunk32_vkCopyImageToMemoryEXT,
    thunk32_vkCopyMemoryToAccelerationStructureKHR,
    thunk32_vkCopyMemoryToImageEXT,
    thunk32_vkCopyMemoryToMicromapEXT,
    thunk32_vkCopyMicromapEXT,
    thunk32_vkCopyMicromapToMemoryEXT,
    thunk32_vkCreateAccelerationStructureKHR,
    thunk32_vkCreateAccelerationStructureNV,
    thunk32_vkCreateBuffer,
    thunk32_vkCreateBufferView,
    thunk32_vkCreateCommandPool,
    thunk32_vkCreateComputePipelines,
    thunk32_vkCreateCuFunctionNVX,
    thunk32_vkCreateCuModuleNVX,
    thunk32_vkCreateDebugReportCallbackEXT,
    thunk32_vkCreateDebugUtilsMessengerEXT,
    thunk32_vkCreateDeferredOperationKHR,
    thunk32_vkCreateDescriptorPool,
    thunk32_vkCreateDescriptorSetLayout,
    thunk32_vkCreateDescriptorUpdateTemplate,
    thunk32_vkCreateDescriptorUpdateTemplateKHR,
    thunk32_vkCreateDevice,
    thunk32_vkCreateEvent,
    thunk32_vkCreateFence,
    thunk32_vkCreateFramebuffer,
    thunk32_vkCreateGraphicsPipelines,
    thunk32_vkCreateImage,
    thunk32_vkCreateImageView,
    thunk32_vkCreateIndirectCommandsLayoutNV,
    thunk32_vkCreateInstance,
    thunk32_vkCreateMicromapEXT,
    thunk32_vkCreateOpticalFlowSessionNV,
    thunk32_vkCreatePipelineCache,
    thunk32_vkCreatePipelineLayout,
    thunk32_vkCreatePrivateDataSlot,
    thunk32_vkCreatePrivateDataSlotEXT,
    thunk32_vkCreateQueryPool,
    thunk32_vkCreateRayTracingPipelinesKHR,
    thunk32_vkCreateRayTracingPipelinesNV,
    thunk32_vkCreateRenderPass,
    thunk32_vkCreateRenderPass2,
    thunk32_vkCreateRenderPass2KHR,
    thunk32_vkCreateSampler,
    thunk32_vkCreateSamplerYcbcrConversion,
    thunk32_vkCreateSamplerYcbcrConversionKHR,
    thunk32_vkCreateSemaphore,
    thunk32_vkCreateShaderModule,
    thunk32_vkCreateShadersEXT,
    thunk32_vkCreateSwapchainKHR,
    thunk32_vkCreateValidationCacheEXT,
    thunk32_vkCreateWin32SurfaceKHR,
    thunk32_vkDebugMarkerSetObjectNameEXT,
    thunk32_vkDebugMarkerSetObjectTagEXT,
    thunk32_vkDebugReportMessageEXT,
    thunk32_vkDeferredOperationJoinKHR,
    thunk32_vkDestroyAccelerationStructureKHR,
    thunk32_vkDestroyAccelerationStructureNV,
    thunk32_vkDestroyBuffer,
    thunk32_vkDestroyBufferView,
    thunk32_vkDestroyCommandPool,
    thunk32_vkDestroyCuFunctionNVX,
    thunk32_vkDestroyCuModuleNVX,
    thunk32_vkDestroyDebugReportCallbackEXT,
    thunk32_vkDestroyDebugUtilsMessengerEXT,
    thunk32_vkDestroyDeferredOperationKHR,
    thunk32_vkDestroyDescriptorPool,
    thunk32_vkDestroyDescriptorSetLayout,
    thunk32_vkDestroyDescriptorUpdateTemplate,
    thunk32_vkDestroyDescriptorUpdateTemplateKHR,
    thunk32_vkDestroyDevice,
    thunk32_vkDestroyEvent,
    thunk32_vkDestroyFence,
    thunk32_vkDestroyFramebuffer,
    thunk32_vkDestroyImage,
    thunk32_vkDestroyImageView,
    thunk32_vkDestroyIndirectCommandsLayoutNV,
    thunk32_vkDestroyInstance,
    thunk32_vkDestroyMicromapEXT,
    thunk32_vkDestroyOpticalFlowSessionNV,
    thunk32_vkDestroyPipeline,
    thunk32_vkDestroyPipelineCache,
    thunk32_vkDestroyPipelineLayout,
    thunk32_vkDestroyPrivateDataSlot,
    thunk32_vkDestroyPrivateDataSlotEXT,
    thunk32_vkDestroyQueryPool,
    thunk32_vkDestroyRenderPass,
    thunk32_vkDestroySampler,
    thunk32_vkDestroySamplerYcbcrConversion,
    thunk32_vkDestroySamplerYcbcrConversionKHR,
    thunk32_vkDestroySemaphore,
    thunk32_vkDestroyShaderEXT,
    thunk32_vkDestroyShaderModule,
    thunk32_vkDestroySurfaceKHR,
    thunk32_vkDestroySwapchainKHR,
    thunk32_vkDestroyValidationCacheEXT,
    thunk32_vkDeviceWaitIdle,
    thunk32_vkEndCommandBuffer,
    thunk32_vkEnumerateDeviceExtensionProperties,
    thunk32_vkEnumerateDeviceLayerProperties,
    thunk32_vkEnumerateInstanceExtensionProperties,
    thunk32_vkEnumerateInstanceVersion,
    thunk32_vkEnumeratePhysicalDeviceGroups,
    thunk32_vkEnumeratePhysicalDeviceGroupsKHR,
    thunk32_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
    thunk32_vkEnumeratePhysicalDevices,
    thunk32_vkFlushMappedMemoryRanges,
    thunk32_vkFreeCommandBuffers,
    thunk32_vkFreeDescriptorSets,
    thunk32_vkFreeMemory,
    thunk32_vkGetAccelerationStructureBuildSizesKHR,
    thunk32_vkGetAccelerationStructureDeviceAddressKHR,
    thunk32_vkGetAccelerationStructureHandleNV,
    thunk32_vkGetAccelerationStructureMemoryRequirementsNV,
    thunk32_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetBufferDeviceAddress,
    thunk32_vkGetBufferDeviceAddressEXT,
    thunk32_vkGetBufferDeviceAddressKHR,
    thunk32_vkGetBufferMemoryRequirements,
    thunk32_vkGetBufferMemoryRequirements2,
    thunk32_vkGetBufferMemoryRequirements2KHR,
    thunk32_vkGetBufferOpaqueCaptureAddress,
    thunk32_vkGetBufferOpaqueCaptureAddressKHR,
    thunk32_vkGetBufferOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetCalibratedTimestampsEXT,
    thunk32_vkGetDeferredOperationMaxConcurrencyKHR,
    thunk32_vkGetDeferredOperationResultKHR,
    (void *)thunk32_vkGetDescriptorEXT,
    thunk32_vkGetDescriptorSetHostMappingVALVE,
    thunk32_vkGetDescriptorSetLayoutBindingOffsetEXT,
    thunk32_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
    thunk32_vkGetDescriptorSetLayoutSizeEXT,
    thunk32_vkGetDescriptorSetLayoutSupport,
    thunk32_vkGetDescriptorSetLayoutSupportKHR,
    thunk32_vkGetDeviceAccelerationStructureCompatibilityKHR,
    thunk32_vkGetDeviceBufferMemoryRequirements,
    thunk32_vkGetDeviceBufferMemoryRequirementsKHR,
    thunk32_vkGetDeviceFaultInfoEXT,
    thunk32_vkGetDeviceGroupPeerMemoryFeatures,
    thunk32_vkGetDeviceGroupPeerMemoryFeaturesKHR,
    thunk32_vkGetDeviceGroupPresentCapabilitiesKHR,
    thunk32_vkGetDeviceGroupSurfacePresentModesKHR,
    thunk32_vkGetDeviceImageMemoryRequirements,
    thunk32_vkGetDeviceImageMemoryRequirementsKHR,
    thunk32_vkGetDeviceImageSparseMemoryRequirements,
    thunk32_vkGetDeviceImageSparseMemoryRequirementsKHR,
    thunk32_vkGetDeviceImageSubresourceLayoutKHR,
    thunk32_vkGetDeviceMemoryCommitment,
    thunk32_vkGetDeviceMemoryOpaqueCaptureAddress,
    thunk32_vkGetDeviceMemoryOpaqueCaptureAddressKHR,
    thunk32_vkGetDeviceMicromapCompatibilityEXT,
    thunk32_vkGetDeviceQueue,
    thunk32_vkGetDeviceQueue2,
    thunk32_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
    thunk32_vkGetDynamicRenderingTilePropertiesQCOM,
    thunk32_vkGetEventStatus,
    thunk32_vkGetFenceStatus,
    thunk32_vkGetFramebufferTilePropertiesQCOM,
    thunk32_vkGetGeneratedCommandsMemoryRequirementsNV,
    thunk32_vkGetImageMemoryRequirements,
    thunk32_vkGetImageMemoryRequirements2,
    thunk32_vkGetImageMemoryRequirements2KHR,
    thunk32_vkGetImageOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetImageSparseMemoryRequirements,
    thunk32_vkGetImageSparseMemoryRequirements2,
    thunk32_vkGetImageSparseMemoryRequirements2KHR,
    thunk32_vkGetImageSubresourceLayout,
    thunk32_vkGetImageSubresourceLayout2EXT,
    thunk32_vkGetImageSubresourceLayout2KHR,
    thunk32_vkGetImageViewAddressNVX,
    thunk32_vkGetImageViewHandleNVX,
    thunk32_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetLatencyTimingsNV,
    thunk32_vkGetMemoryFdKHR,
    thunk32_vkGetMemoryFdPropertiesKHR,
    thunk32_vkGetMemoryHostPointerPropertiesEXT,
    thunk32_vkGetMemoryWin32HandleKHR,
    thunk32_vkGetMemoryWin32HandlePropertiesKHR,
    thunk32_vkGetMicromapBuildSizesEXT,
    thunk32_vkGetPerformanceParameterINTEL,
    thunk32_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
    thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
    thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
    thunk32_vkGetPhysicalDeviceExternalBufferProperties,
    thunk32_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
    thunk32_vkGetPhysicalDeviceExternalFenceProperties,
    thunk32_vkGetPhysicalDeviceExternalFencePropertiesKHR,
    thunk32_vkGetPhysicalDeviceExternalSemaphoreProperties,
    thunk32_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
    thunk32_vkGetPhysicalDeviceFeatures,
    thunk32_vkGetPhysicalDeviceFeatures2,
    thunk32_vkGetPhysicalDeviceFeatures2KHR,
    thunk32_vkGetPhysicalDeviceFormatProperties,
    thunk32_vkGetPhysicalDeviceFormatProperties2,
    thunk32_vkGetPhysicalDeviceFormatProperties2KHR,
    thunk32_vkGetPhysicalDeviceFragmentShadingRatesKHR,
    thunk32_vkGetPhysicalDeviceImageFormatProperties,
    thunk32_vkGetPhysicalDeviceImageFormatProperties2,
    thunk32_vkGetPhysicalDeviceImageFormatProperties2KHR,
    thunk32_vkGetPhysicalDeviceMemoryProperties,
    thunk32_vkGetPhysicalDeviceMemoryProperties2,
    thunk32_vkGetPhysicalDeviceMemoryProperties2KHR,
    thunk32_vkGetPhysicalDeviceMultisamplePropertiesEXT,
    thunk32_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
    thunk32_vkGetPhysicalDevicePresentRectanglesKHR,
    thunk32_vkGetPhysicalDeviceProperties,
    thunk32_vkGetPhysicalDeviceProperties2,
    thunk32_vkGetPhysicalDeviceProperties2KHR,
    thunk32_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
    thunk32_vkGetPhysicalDeviceQueueFamilyProperties,
    thunk32_vkGetPhysicalDeviceQueueFamilyProperties2,
    thunk32_vkGetPhysicalDeviceQueueFamilyProperties2KHR,
    thunk32_vkGetPhysicalDeviceSparseImageFormatProperties,
    thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2,
    thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
    thunk32_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
    thunk32_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
    thunk32_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
    thunk32_vkGetPhysicalDeviceSurfaceFormats2KHR,
    thunk32_vkGetPhysicalDeviceSurfaceFormatsKHR,
    thunk32_vkGetPhysicalDeviceSurfacePresentModesKHR,
    thunk32_vkGetPhysicalDeviceSurfaceSupportKHR,
    thunk32_vkGetPhysicalDeviceToolProperties,
    thunk32_vkGetPhysicalDeviceToolPropertiesEXT,
    thunk32_vkGetPhysicalDeviceWin32PresentationSupportKHR,
    thunk32_vkGetPipelineCacheData,
    thunk32_vkGetPipelineExecutableInternalRepresentationsKHR,
    thunk32_vkGetPipelineExecutablePropertiesKHR,
    thunk32_vkGetPipelineExecutableStatisticsKHR,
    thunk32_vkGetPipelineIndirectDeviceAddressNV,
    thunk32_vkGetPipelineIndirectMemoryRequirementsNV,
    thunk32_vkGetPipelinePropertiesEXT,
    thunk32_vkGetPrivateData,
    thunk32_vkGetPrivateDataEXT,
    thunk32_vkGetQueryPoolResults,
    thunk32_vkGetQueueCheckpointData2NV,
    thunk32_vkGetQueueCheckpointDataNV,
    thunk32_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
    thunk32_vkGetRayTracingShaderGroupHandlesKHR,
    thunk32_vkGetRayTracingShaderGroupHandlesNV,
    thunk32_vkGetRayTracingShaderGroupStackSizeKHR,
    thunk32_vkGetRenderAreaGranularity,
    thunk32_vkGetRenderingAreaGranularityKHR,
    thunk32_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetSemaphoreCounterValue,
    thunk32_vkGetSemaphoreCounterValueKHR,
    thunk32_vkGetSemaphoreFdKHR,
    thunk32_vkGetSemaphoreWin32HandleKHR,
    thunk32_vkGetShaderBinaryDataEXT,
    thunk32_vkGetShaderInfoAMD,
    thunk32_vkGetShaderModuleCreateInfoIdentifierEXT,
    thunk32_vkGetShaderModuleIdentifierEXT,
    thunk32_vkGetSwapchainImagesKHR,
    thunk32_vkGetValidationCacheDataEXT,
    thunk32_vkImportSemaphoreFdKHR,
    thunk32_vkImportSemaphoreWin32HandleKHR,
    thunk32_vkInitializePerformanceApiINTEL,
    thunk32_vkInvalidateMappedMemoryRanges,
    thunk32_vkLatencySleepNV,
    thunk32_vkMapMemory,
    thunk32_vkMapMemory2KHR,
    thunk32_vkMergePipelineCaches,
    thunk32_vkMergeValidationCachesEXT,
    thunk32_vkQueueBeginDebugUtilsLabelEXT,
    thunk32_vkQueueBindSparse,
    thunk32_vkQueueEndDebugUtilsLabelEXT,
    thunk32_vkQueueInsertDebugUtilsLabelEXT,
    thunk32_vkQueueNotifyOutOfBandNV,
    thunk32_vkQueuePresentKHR,
    thunk32_vkQueueSetPerformanceConfigurationINTEL,
    thunk32_vkQueueSubmit,
    thunk32_vkQueueSubmit2,
    thunk32_vkQueueSubmit2KHR,
    thunk32_vkQueueWaitIdle,
    thunk32_vkReleasePerformanceConfigurationINTEL,
    thunk32_vkReleaseProfilingLockKHR,
    thunk32_vkReleaseSwapchainImagesEXT,
    thunk32_vkResetCommandBuffer,
    thunk32_vkResetCommandPool,
    thunk32_vkResetDescriptorPool,
    thunk32_vkResetEvent,
    thunk32_vkResetFences,
    thunk32_vkResetQueryPool,
    thunk32_vkResetQueryPoolEXT,
    thunk32_vkSetDebugUtilsObjectNameEXT,
    thunk32_vkSetDebugUtilsObjectTagEXT,
    thunk32_vkSetDeviceMemoryPriorityEXT,
    thunk32_vkSetEvent,
    thunk32_vkSetHdrMetadataEXT,
    thunk32_vkSetLatencyMarkerNV,
    thunk32_vkSetLatencySleepModeNV,
    thunk32_vkSetPrivateData,
    thunk32_vkSetPrivateDataEXT,
    thunk32_vkSignalSemaphore,
    thunk32_vkSignalSemaphoreKHR,
    thunk32_vkSubmitDebugUtilsMessageEXT,
    thunk32_vkTransitionImageLayoutEXT,
    thunk32_vkTrimCommandPool,
    thunk32_vkTrimCommandPoolKHR,
    thunk32_vkUninitializePerformanceApiINTEL,
    thunk32_vkUnmapMemory,
    thunk32_vkUnmapMemory2KHR,
    (void *)thunk32_vkUpdateDescriptorSetWithTemplate,
    thunk32_vkUpdateDescriptorSetWithTemplateKHR,
    (void *)thunk32_vkUpdateDescriptorSets,
    thunk32_vkWaitForFences,
    thunk32_vkWaitForPresentKHR,
    thunk32_vkWaitSemaphores,
    thunk32_vkWaitSemaphoresKHR,
    thunk32_vkWriteAccelerationStructuresPropertiesKHR,
    thunk32_vkWriteMicromapsPropertiesEXT,
    thunk32_wine_vkAcquireKeyedMutex,
    thunk32_wine_vkReleaseKeyedMutex,
};
C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
